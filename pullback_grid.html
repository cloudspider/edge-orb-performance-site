
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pullback Grid Backtest</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.tailframes.com/releases/latest/tailframes.min.js" defer></script>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"
  />
  <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
  <!-- Apache ECharts for interactive charts (mobile pinch-zoom supported) -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    .num-pos { color: #119d6e !important; }
    .num-neg { color: #ff0000 !important; }
    .pnl-strong { font-size: 1.8rem !important; }
    .sticky-th { position: sticky; top: 0; background: white; z-index: 1; }
    .shadow-soft { box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
    thead th { position: sticky; top: 0; background: white; z-index: 1; }

    /* Hide native spin buttons for key numeric inputs */
    #inp_orb_m::-webkit-outer-spin-button,
    #inp_orb_m::-webkit-inner-spin-button,
    #inp_target_R::-webkit-outer-spin-button,
    #inp_target_R::-webkit-inner-spin-button,
    #inp_stop_R::-webkit-outer-spin-button,
    #inp_stop_R::-webkit-inner-spin-button,
    #inp_risk_pct::-webkit-outer-spin-button,
    #inp_risk_pct::-webkit-inner-spin-button,
    #inp_aum0::-webkit-outer-spin-button,
    #inp_aum0::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    #inp_orb_m,
    #inp_target_R,
    #inp_stop_R,
    #inp_risk_pct,
    #inp_aum0 {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Generic: hide spinners for any future number input */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Segment controls responsive layout */
    #tickerSegment {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      grid-auto-rows: 1fr;
      width: 100%;
      gap: 1px;
    }
    #tickerSegment button {
      width: 100%;
      height: 100%;
    }
    #sessionSegment {
      display: flex;
      flex-wrap: wrap;
      max-width: 100%;
      min-width: 0;
      white-space: normal;
    }
    #sessionSegment button {
      flex: 0 0 auto;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Site navigation -->
  <nav class="bg-white border-b border-slate-200 sticky top-0 z-50 shadow-sm">
    <div class="max-w-screen-2xl mx-auto px-6 py-3 flex items-center gap-4">
      <div class="flex items-center gap-6 flex-1 min-w-0">
        <div class="flex items-center gap-2 font-semibold text-slate-800">
          <svg class="h-5 w-5 text-emerald-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" fill="currentColor" aria-hidden="true"><path d="M192 384L88.5 384C63.6 384 48.3 356.9 61.1 335.5L114 247.3C122.7 232.8 138.3 224 155.2 224L250.2 224C326.3 95.1 439.8 88.6 515.7 99.7C528.5 101.6 538.5 111.6 540.3 124.3C551.4 200.2 544.9 313.7 416 389.8L416 484.8C416 501.7 407.2 517.3 392.7 526L304.5 578.9C283.2 591.7 256 576.3 256 551.5L256 448C256 412.7 227.3 384 192 384L191.9 384zM464 224C464 197.5 442.5 176 416 176C389.5 176 368 197.5 368 224C368 250.5 389.5 272 416 272C442.5 272 464 250.5 464 224z"/></svg>
          <span>ORB</span>
        </div>
        <div class="flex items-center gap-2 flex-wrap">
          <a data-nav href="index.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Performance</a>
          <a data-nav href="backtest.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Backtest</a>
          <a data-nav href="results.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Results</a>
          <a data-nav href="pullback_grid.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Pullback Grid</a>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button
          type="button"
          id="btnExportData"
          class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600"
          title="Export saved backtest data"
        >
          <i class="fa fa-download"></i>
          <span>Export</span>
        </button>
        <button
          type="button"
          id="btnImportData"
          class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600"
          title="Import saved backtest data"
        >
          <i class="fa fa-upload"></i>
          <span>Import</span>
        </button>
        <input
          type="file"
          id="inputImportData"
          accept="application/json"
          class="hidden"
        />
      </div>
    </div>
  </nav>
  <script>
    // Activate nav item for current page
    (function(){
      try {
        const file = (location.pathname.split('/').pop() || 'pullback_grid.html').toLowerCase();
        document.querySelectorAll('a[data-nav]').forEach(a => {
          const href = (a.getAttribute('href') || '').toLowerCase();
          const active = href === file || (file === '' && href.endsWith('index.html'));
          a.classList.toggle('bg-slate-800', active);
          a.classList.toggle('text-white', active);
          a.classList.toggle('hover:bg-slate-100', !active);
          if (active) a.setAttribute('aria-current','page'); else a.removeAttribute('aria-current');
        });
      } catch {}
    })();
  </script>

  <div class="max-w-screen-2xl mx-auto p-6 space-y-6">
    <header class="mb-2">
      <h1 id="mainTitle" class="text-2xl md:text-3xl font-semibold">Pullback Grid Backtest</h1>
      <p class="text-slate-600 mt-1">Under construction. Hook up pullback grid datasets and controls here.</p>
    </header>

    <section id="symbolPicker" class="bg-white rounded-2xl shadow-soft p-3 md:p-4">
      <div class="overflow-x-auto -mx-3 md:mx-0 px-3 md:px-0">
        <nav class="flex min-w-max border-b border-slate-200 gap-1" role="tablist">
          <button type="button" class="inline-flex items-center gap-2 border-b-2 border-blue-500 px-3 py-2 text-sm font-medium text-slate-900 transition">
            <span class="inline-flex h-8 w-8 items-center justify-center text-emerald-500">
              <ion-icon name="grid-outline" class="text-2xl"></ion-icon>
            </span>
            <span>Pullback Grid</span>
          </button>
        </nav>
      </div>

      <div class="flex-1 min-w-0 mt-4">
        <div class="flex items-center gap-2 mb-2">
          <div class="flex-1 min-w-0">
            <div id="tickerSegment" class="w-full rounded-xl border border-slate-200 bg-slate-200 p-px overflow-hidden">
              <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
            </div>
          </div>
        </div>
        <div id="status" class="text-xs text-slate-500"></div>
      </div>
    </section>

    <section class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-3">
      <div class="flex flex-col gap-1">
        <h2 class="font-semibold text-slate-700">Dataset</h2>
        <p id="dataSummary" class="text-sm text-slate-500">Select a symbol to load intraday data.</p>
      </div>
      <div class="rounded-xl border border-slate-200 bg-slate-50 p-4 text-xs text-slate-500 leading-relaxed">
        <p>Files must contain 1-minute OHLC data with columns for <code>caldt</code>, <code>day</code>, <code>open</code>, <code>high</code>, <code>low</code>, and <code>close</code>. The pullback grid simulation evaluates each minute to detect fills, so ensure the CSV spans the period you want to test.</p>
      </div>
    </section>

    <section id="gridParameters" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
        <div>
          <h2 class="font-semibold text-slate-700">Grid Parameters</h2>
          <p class="text-sm text-slate-500">Adjust spacing and sizing, then run the backtest on the loaded symbol.</p>
        </div>
        <button
          type="button"
          id="btnRunGridBacktest"
          class="inline-flex items-center justify-center gap-2 rounded-xl bg-emerald-600 px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-emerald-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-500 disabled:cursor-not-allowed disabled:bg-slate-300"
          disabled
        >
          <ion-icon name="play-outline" class="text-lg"></ion-icon>
          <span>Run Backtest</span>
        </button>
      </div>

      <div class="grid gap-4 md:grid-cols-6">
        <label class="block">
          <span class="text-sm text-slate-600">Grid Type</span>
          <div class="relative mt-1">
            <select
              id="selGridType"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="pullback" selected>Pullback Grid</option>
              <option value="progressive">Progressive Grid</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Grid Size ($)</span>
          <div class="mt-1 relative">
            <input
              id="inpGridSize"
              type="number"
              step="0.5"
              min="0.5"
              value="5"
              class="w-full border border-slate-200 bg-white text-slate-700 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            />
            <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase grid size" data-num-target="inpGridSize" data-num-step="1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd" /></svg>
              </button>
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease grid size" data-num-target="inpGridSize" data-num-step="-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd" /></svg>
              </button>
            </div>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Grid Offset ($)</span>
          <div class="mt-1 relative">
            <input
              id="inpGridOffset"
              type="number"
              step="0.5"
              value="0"
              class="w-full border border-slate-200 bg-white text-slate-700 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            />
            <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase grid offset" data-num-target="inpGridOffset" data-num-step="1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd" /></svg>
              </button>
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease grid offset" data-num-target="inpGridOffset" data-num-step="-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd" /></svg>
              </button>
            </div>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Trade Value ($)</span>
          <input
            id="inpTradeValue"
            type="number"
            step="1"
            min="1"
            value="1000"
            class="mt-1 w-full appearance-none rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
          />
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Initial Cash ($)</span>
          <input
            id="inpInitialCash"
            type="number"
            step="100"
            min="0"
            value="10000"
            class="mt-1 w-full appearance-none rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
          />
        </label>
        <label class="flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-600 shadow-sm transition focus-within:ring-2 focus-within:ring-emerald-500/60">
          <input
            id="inpFractionalShares"
            type="checkbox"
            class="h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-500"
            checked
          />
          <span>Allow fractional shares</span>
        </label>
      </div>
    </section>

    <section id="gridSummarySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
        <div>
          <h2 class="font-semibold text-slate-700">Summary</h2>
          <p id="gridStatus" class="text-sm text-slate-500">Load data and run the backtest to populate results.</p>
        </div>
        <div class="flex flex-wrap items-center gap-x-6 gap-y-2 text-xs text-slate-500">
          <span>Cash:</span>
          <span id="summaryCash" class="text-sm font-semibold text-slate-800">$0.00</span>
          <span>Shares:</span>
          <span id="summaryShares" class="text-sm font-semibold text-slate-800">0</span>
        </div>
      </div>
      <dl class="grid gap-4 sm:grid-cols-2 lg:grid-cols-8">
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Completed Trades</dt>
          <dd id="summaryTotalTrades" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Net Profit</dt>
          <dd id="summaryNetProfit" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Final Equity</dt>
          <dd id="summaryFinalEquity" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">CAGR</dt>
          <dd id="summaryCagr" class="mt-2 text-xl font-semibold text-slate-800">0.00%</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Retained Shares</dt>
          <dd id="summaryRetained" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Drawdown</dt>
          <dd id="summaryMaxDD" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Drawdown %</dt>
          <dd id="summaryMaxDDPct" class="mt-2 text-xl font-semibold text-slate-800">0.00%</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Shares Held</dt>
          <dd id="summaryMaxShares" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
        </div>
      </dl>
    </section>

    <section id="gridEquitySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Equity Curve</h2>
        <span id="equitySummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="gridEquityChart" class="w-full h-72 md:h-96"></div>
        <div id="gridEquityEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to plot equity over time.
        </div>
      </div>
    </section>

    <section id="gridTradesSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Trade Log</h2>
        <span id="tradeCountLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="overflow-x-auto">
        <table class="min-w-full divide-y divide-slate-200 text-sm">
          <thead class="bg-slate-50 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">
            <tr>
              <th class="px-3 py-2">Buy Time</th>
              <th class="px-3 py-2 text-right">Buy Price</th>
              <th class="px-3 py-2 text-right">Buy Qty</th>
              <th class="px-3 py-2">Sell Time</th>
              <th class="px-3 py-2 text-right">Sell Price</th>
              <th class="px-3 py-2 text-right">Sell Qty</th>
              <th class="px-3 py-2 text-right">Qty Retained</th>
              <th class="px-3 py-2 text-right">Cum Retained</th>
              <th class="px-3 py-2 text-right">Days Held</th>
              <th class="px-3 py-2 text-right">Profit $</th>
              <th class="px-3 py-2 text-right">ROI %</th>
            </tr>
          </thead>
          <tbody id="gridTradeRows" class="divide-y divide-slate-100"></tbody>
        </table>
        <div id="gridTradesEmpty" class="py-6 text-center text-sm text-slate-500">Run the backtest to see individual trades.</div>
      </div>
    </section>
  </div>
<script>
  (function(){
    const DEFAULT_PRICE_PRECISION = 2;
    const GRID_DEFAULTS = {
      gridSize: 5,
      tradeValue: 1000,
      initialCash: 10000,
      fractionalShares: true
    };
    const CURRENCY_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const NUMBER_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const NUMBER_FORMAT_4 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 4, maximumFractionDigits: 4 });
    const PERCENT_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });

    const pad2 = (n) => String(n).padStart(2, '0');
    const dateKeyFromStr = (val) => {
      if (val == null) return null;
      if (typeof val === 'string') {
        const m = val.trim().match(/^(\d{4}-\d{2}-\d{2})/);
        if (m) return m[1];
      }
      const d = new Date(val);
      if (isNaN(d)) return null;
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
    };

    let currentTicker = '';
    let ROWS = [];
    let DAY_GROUPS = new Map();
    let DAYS = [];
    let SYMBOL_META = new Map();
    let GRID_STATE = { trades: [], summary: null, equitySeries: [] };
    let gridEquityChartInst = null;

    function setStatus(msg) {
      const el = document.getElementById('status');
      if (el) el.textContent = msg || '';
    }

    function setGridStatus(msg) {
      const el = document.getElementById('gridStatus');
      if (el) el.textContent = msg || '';
    }

    function setRunButtonEnabled(enabled) {
      const btn = document.getElementById('btnRunGridBacktest');
      if (!btn) return;
      btn.disabled = !enabled;
      btn.classList.toggle('opacity-70', !enabled);
    }

    function ensureSymbolMetaEntry(symbol) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return null;
      if (!SYMBOL_META.has(sym)) {
        SYMBOL_META.set(sym, { symbol: sym, name: sym, multiplier: 1, precision: DEFAULT_PRICE_PRECISION });
      }
      const meta = SYMBOL_META.get(sym);
      if (meta && !meta.symbol) meta.symbol = sym;
      return meta || null;
    }

    function countPriceDecimals(value) {
      if (!Number.isFinite(value)) return 0;
      const str = Number(value).toFixed(8).replace(/0+$/,'').replace(/\.$/,'');
      const idx = str.indexOf('.');
      return idx >= 0 ? (str.length - idx - 1) : 0;
    }

    function inferPricePrecisionFromRows(rows) {
      if (!Array.isArray(rows)) return DEFAULT_PRICE_PRECISION;
      let maxDecimals = 0;
      const limit = Math.min(rows.length, 400);
      for (let i = 0; i < limit; i++) {
        const row = rows[i];
        if (!row) continue;
        const values = [row.open, row.high, row.low, row.close];
        for (const val of values) {
          const decimals = countPriceDecimals(val);
          if (decimals > maxDecimals) {
            maxDecimals = decimals;
            if (maxDecimals >= 6) return 6;
          }
        }
      }
      return Math.min(Math.max(maxDecimals, DEFAULT_PRICE_PRECISION), 8);
    }

    function updateSymbolPrecisionFromRows(symbol, rows) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return;
      const precision = inferPricePrecisionFromRows(rows);
      const meta = ensureSymbolMetaEntry(sym);
      if (meta) {
        meta.precision = precision;
        SYMBOL_META.set(sym, meta);
      }
    }

    function countDecimals(value) {
      if (!Number.isFinite(value)) return 0;
      const s = String(value);
      if (!s.includes('.')) return 0;
      const trimmed = s.replace(/0+$/, '');
      const idx = trimmed.indexOf('.');
      return idx >= 0 ? (trimmed.length - idx - 1) : 0;
    }

    function formatCurrency(value) {
      if (!Number.isFinite(value)) return '$0.00';
      return `$${CURRENCY_FORMAT.format(value)}`;
    }

    function formatNumber(value, digits = 2) {
      if (!Number.isFinite(value)) return digits === 4 ? '0.0000' : '0.00';
      if (digits === 4) return NUMBER_FORMAT_4.format(value);
      return NUMBER_FORMAT.format(value);
    }

    function formatPercent(value) {
      if (!Number.isFinite(value)) return '0.00%';
      return `${PERCENT_FORMAT.format(value)}%`;
    }

    function formatDateTime(value) {
      if (!(value instanceof Date) || isNaN(value)) return '';
      const year = value.getFullYear();
      const month = pad2(value.getMonth() + 1);
      const day = pad2(value.getDate());
      const hour = pad2(value.getHours());
      const minute = pad2(value.getMinutes());
      return `${year}-${month}-${day} ${hour}:${minute}`;
    }

    // Numeric steppers for grid controls
    (function(){
      function decimals(stepStr){
        if (!stepStr) return 0;
        const s = String(stepStr);
        const idx = s.indexOf('.');
        return idx === -1 ? 0 : (s.length - idx - 1);
      }
      function roundTo(value, step){
        const d = decimals(step);
        return Number(value.toFixed(d));
      }
      function adjustNumberInput(id, deltaUnits){
        const el = document.getElementById(id);
        if (!el) return;
        const stepAttr = parseFloat(el.getAttribute('step') || '1');
        const step = Number.isFinite(stepAttr) && stepAttr > 0 ? stepAttr : 1;
        const minAttr = parseFloat(el.getAttribute('min'));
        const maxAttr = parseFloat(el.getAttribute('max'));
        const defAttr = parseFloat(el.getAttribute('data-default'));
        const curVal = parseFloat(el.value);
        const base = Number.isFinite(curVal) ? curVal : (Number.isFinite(defAttr) ? defAttr : 0);
        const next = base + (Number(deltaUnits) || 0) * step;
        const clamped = Math.min(Number.isFinite(maxAttr) ? maxAttr : Infinity, Math.max(Number.isFinite(minAttr) ? minAttr : -Infinity, next));
        const rounded = roundTo(clamped, step);
        el.value = String(rounded);
        el.dispatchEvent(new Event('change', { bubbles: true }));
      }
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-num-target][data-num-step]');
        if (!btn) return;
        const id = btn.getAttribute('data-num-target');
        const delta = parseFloat(btn.getAttribute('data-num-step')) || 0;
        adjustNumberInput(id, delta);
      });
    })();

    function getGridParamsFromUI() {
      const gridSize = Number(document.getElementById('inpGridSize')?.value ?? GRID_DEFAULTS.gridSize);
      const gridOffset = Number(document.getElementById('inpGridOffset')?.value ?? 0);
      const tradeValue = Number(document.getElementById('inpTradeValue')?.value ?? GRID_DEFAULTS.tradeValue);
      const initialCash = Number(document.getElementById('inpInitialCash')?.value ?? GRID_DEFAULTS.initialCash);
      const fractionalShares = !!document.getElementById('inpFractionalShares')?.checked;
      const gridType = (document.getElementById('selGridType')?.value || 'pullback').toLowerCase();
      return {
        gridSize: Number.isFinite(gridSize) ? gridSize : GRID_DEFAULTS.gridSize,
        gridOffset: Number.isFinite(gridOffset) ? gridOffset : 0,
        tradeValue: Number.isFinite(tradeValue) ? tradeValue : GRID_DEFAULTS.tradeValue,
        initialCash: Number.isFinite(initialCash) ? initialCash : GRID_DEFAULTS.initialCash,
        fractionalShares,
        gridType
      };
    }

    function renderGridSummary(summary) {
      const totalTradesEl = document.getElementById('summaryTotalTrades');
      const netProfitEl = document.getElementById('summaryNetProfit');
      const finalEquityEl = document.getElementById('summaryFinalEquity');
      const retainedEl = document.getElementById('summaryRetained');
      const cagrEl = document.getElementById('summaryCagr');
      const maxDdEl = document.getElementById('summaryMaxDD');
      const maxDdPctEl = document.getElementById('summaryMaxDDPct');
      const maxSharesEl = document.getElementById('summaryMaxShares');
      const cashEl = document.getElementById('summaryCash');
      const sharesEl = document.getElementById('summaryShares');
      if (!summary) {
        if (totalTradesEl) totalTradesEl.textContent = '0';
        if (netProfitEl) {
          netProfitEl.textContent = '$0.00';
          netProfitEl.classList.remove('text-emerald-600', 'text-red-600');
          netProfitEl.classList.add('text-slate-800');
        }
        if (finalEquityEl) finalEquityEl.textContent = '$0.00';
        if (retainedEl) retainedEl.textContent = '0';
        if (cagrEl) {
          cagrEl.textContent = '0.00%';
          cagrEl.classList.remove('text-emerald-600', 'text-red-600');
          cagrEl.classList.add('text-slate-800');
        }
        if (maxDdEl) {
          maxDdEl.textContent = '$0.00';
          maxDdEl.classList.remove('text-red-600');
          maxDdEl.classList.add('text-slate-800');
        }
        if (maxDdPctEl) {
          maxDdPctEl.textContent = '0.00%';
          maxDdPctEl.classList.remove('text-red-600');
          maxDdPctEl.classList.add('text-slate-800');
        }
        if (maxSharesEl) maxSharesEl.textContent = '0';
        if (cashEl) cashEl.textContent = '$0.00';
        if (sharesEl) sharesEl.textContent = '0';
        return;
      }
      if (totalTradesEl) totalTradesEl.textContent = String(summary.totalTrades ?? 0);
      if (netProfitEl) {
        const net = summary.netProfit ?? 0;
        netProfitEl.textContent = formatCurrency(net);
        netProfitEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (net > 1e-8) {
          netProfitEl.classList.add('text-emerald-600');
        } else if (net < -1e-8) {
          netProfitEl.classList.add('text-red-600');
        } else {
          netProfitEl.classList.add('text-slate-800');
        }
      }
      if (finalEquityEl) finalEquityEl.textContent = formatCurrency(summary.finalEquity ?? 0);
      if (retainedEl) retainedEl.textContent = formatNumber(summary.totalRetainedShares ?? 0, 4);
      if (cagrEl) {
        const cagr = summary.cagr ?? 0;
        const pct = cagr * 100;
        cagrEl.textContent = formatPercent(pct);
        cagrEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (cagr > 1e-6) {
          cagrEl.classList.add('text-emerald-600');
        } else if (cagr < -1e-6) {
          cagrEl.classList.add('text-red-600');
        } else {
          cagrEl.classList.add('text-slate-800');
        }
      }
      if (maxDdEl) {
        const maxDd = summary.maxDrawdown ?? 0;
        maxDdEl.textContent = formatCurrency(maxDd);
        maxDdEl.classList.remove('text-slate-800', 'text-red-600');
        if (maxDd < -1e-8) {
          maxDdEl.classList.add('text-red-600');
        } else {
          maxDdEl.classList.add('text-slate-800');
        }
      }
      if (maxDdPctEl) {
        const maxDdPct = summary.maxDrawdownPct ?? 0;
        const pctStr = `${PERCENT_FORMAT.format(maxDdPct)}%`;
        maxDdPctEl.textContent = pctStr;
        maxDdPctEl.classList.remove('text-slate-800', 'text-red-600');
        if (maxDdPct < -1e-8) {
          maxDdPctEl.classList.add('text-red-600');
        } else {
          maxDdPctEl.classList.add('text-slate-800');
        }
      }
      if (maxSharesEl) maxSharesEl.textContent = formatNumber(summary.maxSharesHeld ?? 0, 4);
      if (cashEl) cashEl.textContent = formatCurrency(summary.cash ?? 0);
      if (sharesEl) sharesEl.textContent = formatNumber(summary.shares ?? 0, 4);
    }

    function renderGridTrades(trades) {
      const tbody = document.getElementById('gridTradeRows');
      const emptyState = document.getElementById('gridTradesEmpty');
      const label = document.getElementById('tradeCountLabel');
      if (!tbody) return;
      tbody.innerHTML = '';
      if (!Array.isArray(trades) || !trades.length) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '0 trades';
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const frag = document.createDocumentFragment();
      for (const trade of trades) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="px-3 py-2 whitespace-nowrap">${formatDateTime(trade.buyTime)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.buyPrice, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.buyQty, 4)}</td>
          <td class="px-3 py-2 whitespace-nowrap">${formatDateTime(trade.sellTime)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.sellPrice, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.sellQty, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.qtyRetained ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.cumQtyRetained ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.daysHeld ?? 0, 2)}</td>
          <td class="px-3 py-2 text-right ${trade.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(trade.profit)}</td>
          <td class="px-3 py-2 text-right ${trade.roiPct >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatPercent(trade.roiPct)}</td>
        `;
        frag.appendChild(tr);
      }
      tbody.appendChild(frag);
      if (label) label.textContent = `${trades.length} trade${trades.length === 1 ? '' : 's'}`;
    }

    function renderGridEquityChart(series) {
      const container = document.getElementById('gridEquityChart');
      const emptyState = document.getElementById('gridEquityEmpty');
      const label = document.getElementById('equitySummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!gridEquityChartInst) {
        gridEquityChartInst = echarts.init(container);
      }
      if (!Array.isArray(series) || !series.length) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        gridEquityChartInst.clear();
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const data = series.map(point => {
        const time = point.time instanceof Date ? point.time : new Date(point.time);
        return [time.getTime(), Number(point.equity) || 0];
      }).filter(item => Number.isFinite(item[0]) && Number.isFinite(item[1]));
      data.sort((a, b) => a[0] - b[0]);
      if (!data.length) {
        gridEquityChartInst.clear();
        if (label) label.textContent = '';
        if (emptyState) emptyState.classList.remove('hidden');
        return;
      }
      const first = data[0];
      const last = data[data.length - 1];
      if (label && first && last) {
        const start = new Date(first[0]);
        const end = new Date(last[0]);
        label.textContent = `${start.toISOString().slice(0, 10)} → ${end.toISOString().slice(0, 10)} (${data.length.toLocaleString()} points)`;
      }
      const gradient = (echarts.graphic && echarts.graphic.LinearGradient)
        ? new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: 'rgba(15, 118, 110, 0.25)' },
            { offset: 1, color: 'rgba(15, 118, 110, 0)' }
          ])
        : 'rgba(15, 118, 110, 0.1)';
      gridEquityChartInst.setOption({
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'cross' },
          valueFormatter: (val) => formatCurrency(val)
        },
        xAxis: {
          type: 'time',
          boundaryGap: false,
          axisLabel: { color: '#64748b' }
        },
        yAxis: {
          type: 'value',
          scale: true,
          axisLabel: {
            formatter: (val) => formatCurrency(val).replace('$', ''),
            color: '#64748b'
          },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [{
          name: 'Equity',
          type: 'line',
          smooth: true,
          showSymbol: false,
          lineStyle: { color: '#0f766e', width: 2 },
          areaStyle: gradient ? { color: gradient } : undefined,
          data
        }]
      }, true);
    }

    function highlightTickerButton(symbol) {
      const seg = document.getElementById('tickerSegment');
      if (!seg) return;
      const upper = (symbol || '').toUpperCase();
      seg.querySelectorAll('button[data-symbol]').forEach(btn => {
        const active = (btn.getAttribute('data-symbol') || '').toUpperCase() === upper;
        btn.classList.toggle('bg-emerald-600', active);
        btn.classList.toggle('text-white', active);
        btn.classList.toggle('hover:bg-emerald-600', active);
        btn.classList.toggle('bg-white', !active);
        btn.classList.toggle('hover:bg-emerald-50', !active);
        const nameSpan = btn.querySelector('[data-symbol-name]');
        if (nameSpan) {
          nameSpan.classList.toggle('text-emerald-100', active);
          nameSpan.classList.toggle('text-slate-500', !active);
        }
      });
    }

    function renderDataSummary() {
      const summaryEl = document.getElementById('dataSummary');
      if (!summaryEl) return;
      if (!currentTicker) {
        summaryEl.textContent = 'Select a symbol to load intraday data.';
        return;
      }
      if (!ROWS.length) {
        summaryEl.innerHTML = `<span class="font-semibold">${currentTicker}</span> selected. Choose another symbol or verify data files exist in the <code>data/</code> folder.`;
        return;
      }
      const firstDay = DAYS[0];
      const lastDay = DAYS[DAYS.length - 1];
      summaryEl.innerHTML = `
        <span class="font-semibold">${currentTicker}</span> loaded
        <span class="font-medium">${ROWS.length.toLocaleString()}</span> bars across
        <span class="font-medium">${DAYS.length.toLocaleString()}</span> trading day(s)
        (${firstDay || 'n/a'} → ${lastDay || 'n/a'}).
      `;
    }

    function setTicker(sym) {
      currentTicker = (sym || '').toUpperCase();
      const titleEl = document.getElementById('mainTitle');
      const meta = ensureSymbolMetaEntry(currentTicker);
      const friendlyName = meta && meta.name && meta.name.toUpperCase() !== currentTicker ? ` · ${meta.name}` : '';
      const fullTitle = currentTicker ? `${currentTicker}${friendlyName} - Pullback Grid Backtest` : 'Pullback Grid Backtest';
      if (titleEl) titleEl.textContent = fullTitle;
      document.title = fullTitle;
      highlightTickerButton(currentTicker);
      const loadingMsg = currentTicker ? `Loading data for ${currentTicker}…` : 'Load data and run the backtest to populate results.';
      resetGridOutputs(loadingMsg);
      setRunButtonEnabled(false);
      renderDataSummary();
    }

    function resetGridOutputs(message) {
      GRID_STATE = { trades: [], summary: null, equitySeries: [] };
      renderGridSummary(null);
      renderGridTrades([]);
      setGridStatus(message || 'Load data and run the backtest to populate results.');
      renderGridEquityChart(null);
    }

    function normalizeAndIndex(rows) {
      if (!rows || !rows.length) {
        ROWS = [];
        DAY_GROUPS = new Map();
        DAYS = [];
        return;
      }
      const required = ['caldt', 'day', 'open', 'high', 'low', 'close'];
      const missing = required.filter(c => !(c in rows[0]));
      if (missing.length) throw new Error('Missing columns: ' + missing.join(', '));

      ROWS = rows.map(r => {
        const caldt = new Date(r.caldt);
        const dayKey = dateKeyFromStr(r.day);
        const open = Number(r.open), high = Number(r.high), low = Number(r.low), close = Number(r.close);
        if (!dayKey || isNaN(caldt)) return null;
        if ([open, high, low, close].some(v => !Number.isFinite(v))) return null;
        return { caldt, dayKey, open, high, low, close };
      }).filter(Boolean);

      DAY_GROUPS = new Map();
      for (const row of ROWS) {
        if (!DAY_GROUPS.has(row.dayKey)) DAY_GROUPS.set(row.dayKey, []);
        DAY_GROUPS.get(row.dayKey).push(row);
      }
      for (const [key, arr] of DAY_GROUPS.entries()) arr.sort((a, b) => a.caldt - b.caldt);
      DAYS = Array.from(DAY_GROUPS.keys()).sort();
    }

    function collectOrdersInRange(map, minVal, maxVal, ascending) {
      const out = [];
      if (!map || !map.size) return out;
      const lower = Math.min(minVal, maxVal);
      const upper = Math.max(minVal, maxVal);
      const EPS = 1e-9;
      for (const arr of map.values()) {
        if (!Array.isArray(arr) || !arr.length) continue;
        for (const order of arr) {
          if (!order || !Number.isFinite(order.level)) continue;
          if (order.level >= (lower - EPS) && order.level <= (upper + EPS)) {
            out.push(order);
          }
        }
      }
      out.sort((a, b) => ascending ? (a.level - b.level) : (b.level - a.level));
      return out;
    }

    function runPullbackGridSimulation(rows, params) {
      const trades = [];
      const equitySeries = [];
      const mode = (params?.gridType || 'pullback').toLowerCase();
      if (mode === 'progressive') {
        return runProgressiveGrid(rows, params);
      }

      const summary = {
        totalTrades: 0,
        netProfit: 0,
        finalEquity: 0,
        totalRetainedShares: 0,
        cash: Number(params?.initialCash) || 0,
        shares: 0,
        maxDrawdown: 0,
        maxSharesHeld: 0,
        cagr: 0
      };
      if (!Array.isArray(rows) || !rows.length) {
        return { trades, summary, equitySeries };
      }
      const gridSize = Number(params?.gridSize);
      const gridOffset = Number(params?.gridOffset) || 0;
      const tradeValue = Number(params?.tradeValue);
      const initialCash = Number(params?.initialCash);
      const fractional = !!params?.fractionalShares;
      if (!Number.isFinite(gridSize) || gridSize <= 0 || !Number.isFinite(tradeValue) || tradeValue <= 0) {
        return { trades, summary, equitySeries };
      }
      let firstPrice = [rows[0]?.open, rows[0]?.close, rows[0]?.high, rows[0]?.low].map(Number).find(Number.isFinite);
      if (!Number.isFinite(firstPrice) || firstPrice <= 0) {
        return { trades, summary, equitySeries };
      }
      let minPrice = firstPrice;
      let maxPrice = firstPrice;
      for (const row of rows) {
        if (!row) continue;
        const low = Number(row.low);
        const high = Number(row.high);
        if (Number.isFinite(low)) minPrice = Math.min(minPrice, low);
        if (Number.isFinite(high)) maxPrice = Math.max(maxPrice, high);
      }
      if (!Number.isFinite(minPrice) || !Number.isFinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) {
        return { trades, summary, equitySeries };
      }

      const decimals = Math.min(Math.max(countDecimals(gridSize), 0), 4);
      const scale = Math.pow(10, Math.min(decimals + 2, 8));
      const roundToDecimals = (value) => Math.round(value * scale) / scale;
      const snapLevel = (value) => {
        if (!Number.isFinite(value)) return NaN;
        const snapped = gridOffset + Math.round((value - gridOffset) / gridSize) * gridSize;
        return roundToDecimals(snapped);
      };
      const keyFor = (value) => snapLevel(value).toFixed(6);
      const gridMin = snapLevel(Math.floor((minPrice - gridOffset) / gridSize) * gridSize + gridOffset);
      const gridMax = snapLevel(Math.ceil((maxPrice - gridOffset) / gridSize) * gridSize + gridOffset);

      const activeBuys = new Map();
      const activeSells = new Map();
      const queuedBuyActivations = [];
      let orderSeq = 1;
      let highestSeededBuyLevel = Number.NEGATIVE_INFINITY;

      const removeOrder = (map, order) => {
        if (!order || !Number.isFinite(order.level)) return;
        const key = keyFor(order.level);
        const arr = map.get(key);
        if (!arr) return;
        const idx = arr.indexOf(order);
        if (idx >= 0) arr.splice(idx, 1);
        if (!arr.length) map.delete(key);
      };

      const addBuyOrder = (level) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price) || price <= 0) return null;
        const key = keyFor(price);
        const existing = activeBuys.get(key);
        if (existing && existing.length) return existing[0];
        const order = { id: orderSeq++, level: price };
        activeBuys.set(key, [order]);
        if (!Number.isFinite(highestSeededBuyLevel) || price > highestSeededBuyLevel) {
          highestSeededBuyLevel = price;
        }
        return order;
      };

      const addSellOrder = (level, buyInfo) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price) || price <= 0) return null;
        const key = keyFor(price);
        if (!activeSells.has(key)) activeSells.set(key, []);
        const order = {
          id: orderSeq++,
          level: price,
          buyPrice: Number(buyInfo?.price),
          buyQty: Number(buyInfo?.qty),
          buyTime: buyInfo?.time instanceof Date ? new Date(buyInfo.time.getTime()) : new Date()
        };
        activeSells.get(key).push(order);
        return order;
      };

      for (let level = gridMin; level <= gridMax + gridSize / 2; ) {
        const price = snapLevel(level);
        if (price < firstPrice - 1e-9) {
          addBuyOrder(price);
        }
        const nextLevel = snapLevel(price + gridSize);
        if (!Number.isFinite(nextLevel) || nextLevel <= price) break;
        level = nextLevel;
      }
      if (!Number.isFinite(highestSeededBuyLevel) || highestSeededBuyLevel === Number.NEGATIVE_INFINITY) {
        const seedLevel = snapLevel(firstPrice - gridSize);
        addBuyOrder(seedLevel);
        highestSeededBuyLevel = seedLevel;
      }

      let cash = Number.isFinite(initialCash) ? initialCash : GRID_DEFAULTS.initialCash;
      const initialEquity = cash;
      const firstEquityTime = rows[0]?.caldt instanceof Date ? new Date(rows[0].caldt.getTime()) : null;
      let lastEquityTime = firstEquityTime;
      let shares = 0;
      let realizedProfit = 0;
      let cumulativeRetained = 0;
      let prevPrice = firstPrice;
      const EPS = 1e-9;
      let peakEquity = cash + shares * firstPrice;
      let maxDrawdown = 0;
      let maxDrawdownPct = 0;
      let maxSharesHeld = shares;

      const hasActiveBuy = (level) => {
        const price = snapLevel(level);
        const key = keyFor(price);
        const arr = activeBuys.get(key);
        return Array.isArray(arr) && arr.length > 0;
      };

      const hasQueuedBuyActivation = (level) => {
        const price = snapLevel(level);
        return queuedBuyActivations.some(entry => Math.abs(entry.buyLevel - price) < EPS);
      };

      const queueDelayedBuy = (sellPrice) => {
        const buyPrice = snapLevel(sellPrice);
        if (!Number.isFinite(buyPrice) || buyPrice <= 0) return;
        if (hasActiveBuy(buyPrice) || hasQueuedBuyActivation(buyPrice)) return;
        const triggerLevel = snapLevel(buyPrice + gridSize);
        queuedBuyActivations.push({ buyLevel: buyPrice, trigger: triggerLevel });
      };

      const ensureRunupBuys = (maxPrice) => {
        if (!Number.isFinite(maxPrice)) return;
        if (!Number.isFinite(highestSeededBuyLevel) || !Number.isFinite(gridSize)) return;
        let safety = 0;
        while (maxPrice >= (highestSeededBuyLevel + gridSize * 2) - EPS && safety < 1000) {
          const nextLevel = snapLevel(highestSeededBuyLevel + gridSize);
          if (!hasActiveBuy(nextLevel) && !hasQueuedBuyActivation(nextLevel)) {
            addBuyOrder(nextLevel);
          }
          if (nextLevel <= highestSeededBuyLevel + EPS) break;
          highestSeededBuyLevel = nextLevel;
          safety += 1;
        }
      };

      const activateQueuedBuys = (maxPrice) => {
        if (!Number.isFinite(maxPrice) || !queuedBuyActivations.length) return;
        for (let i = queuedBuyActivations.length - 1; i >= 0; i--) {
          const entry = queuedBuyActivations[i];
          if (!entry) continue;
          if (maxPrice >= entry.trigger - EPS) {
            addBuyOrder(entry.buyLevel);
            queuedBuyActivations.splice(i, 1);
          }
        }
      };

      const executeBuy = (order, timestamp) => {
        if (!order) return false;
        const price = order.level;
        const qtyRaw = tradeValue / price;
        let qty = fractional ? qtyRaw : Math.floor(qtyRaw);
        if (!Number.isFinite(qty) || qty <= 0) {
          removeOrder(activeBuys, order);
          return false;
        }
        const cost = qty * price;
        if (cost > cash + EPS) {
          return false;
        }
        cash -= cost;
        shares += qty;
        if (shares > maxSharesHeld) maxSharesHeld = shares;
        removeOrder(activeBuys, order);
        addSellOrder(price + gridSize, { price, qty, time: timestamp });
        return true;
      };

      const executeSell = (order, timestamp) => {
        if (!order) return false;
        const price = order.level;
        const desiredQtyRaw = tradeValue / price;
        let qty = fractional ? desiredQtyRaw : Math.floor(desiredQtyRaw);
        if (!Number.isFinite(qty) || qty <= 0) {
          removeOrder(activeSells, order);
          return false;
        }
        qty = Math.min(qty, order.buyQty, shares);
        if (qty <= 0) {
          removeOrder(activeSells, order);
          return false;
        }
        const revenue = qty * price;
        const costBasis = qty * order.buyPrice;
        cash += revenue;
        shares -= qty;
        removeOrder(activeSells, order);
        const profit = revenue - costBasis;
        realizedProfit += profit;
        const qtyRetained = order.buyQty - qty;
        cumulativeRetained += qtyRetained;
        const sellTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const buyTime = order.buyTime instanceof Date ? new Date(order.buyTime.getTime()) : new Date();
        const msHeld = sellTime.getTime() - buyTime.getTime();
        const daysHeld = Number.isFinite(msHeld) ? Math.max(0, msHeld / 86400000) : 0;
        trades.push({
          buyTime,
          buyPrice: order.buyPrice,
          buyQty: order.buyQty,
          sellTime,
          sellPrice: price,
          sellQty: qty,
          qtyRetained,
          cumQtyRetained: cumulativeRetained,
          daysHeld,
          profit,
          roiPct: costBasis > 0 ? (profit / costBasis) * 100 : 0
        });
        addBuyOrder(price - gridSize);
        queueDelayedBuy(price);
        return true;
      };

      const processMove = (start, end, timestamp) => {
        if (!Number.isFinite(start) || !Number.isFinite(end)) return;
        if (end > start + EPS) {
          const sells = collectOrdersInRange(activeSells, start, end, true);
          for (const order of sells) executeSell(order, timestamp);
        } else if (end < start - EPS) {
          const buys = collectOrdersInRange(activeBuys, end, start, false);
          for (const order of buys) executeBuy(order, timestamp);
        }
        const maxVal = Math.max(start, end);
        ensureRunupBuys(maxVal);
        activateQueuedBuys(maxVal);
      };

      const buildPath = (fromPrice, row) => {
        const path = [];
        let start = Number(fromPrice);
        if (!Number.isFinite(start)) start = Number(row.open) || Number(row.close) || 0;
        path.push(start);
        const addPoint = (value) => {
          const num = Number(value);
          if (!Number.isFinite(num)) return;
          if (Math.abs(num - path[path.length - 1]) < EPS) return;
          path.push(num);
        };
        const open = Number(row.open);
        const high = Number(row.high);
        const low = Number(row.low);
        const close = Number(row.close);
        if (Number.isFinite(open)) addPoint(open);
        const upBar = Number.isFinite(close) && Number.isFinite(open) ? (close >= open) : true;
        if (upBar) {
          if (Number.isFinite(high)) addPoint(high);
          if (Number.isFinite(low)) addPoint(low);
        } else {
          if (Number.isFinite(low)) addPoint(low);
          if (Number.isFinite(high)) addPoint(high);
        }
        if (Number.isFinite(close)) addPoint(close);
        return path;
      };

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const path = buildPath(prevPrice, row);
        for (let i = 1; i < path.length; i++) {
          const from = path[i - 1];
          const to = path[i];
          processMove(from, to, row.caldt);
        }
        prevPrice = path[path.length - 1];
        const equity = cash + shares * prevPrice;
        if (equity > peakEquity) peakEquity = equity;
        const drawdown = equity - peakEquity;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
        const equityPct = peakEquity > 0 ? (equity - peakEquity) / peakEquity : 0;
        if (equityPct < maxDrawdownPct) maxDrawdownPct = equityPct;
        lastEquityTime = new Date(row.caldt.getTime());
        equitySeries.push({
          time: new Date(row.caldt.getTime()),
          equity
        });
      }

      const finalEquity = cash + shares * prevPrice;
      const millis = firstEquityTime && lastEquityTime ? (lastEquityTime.getTime() - firstEquityTime.getTime()) : 0;
      const years = millis > 0 ? (millis / (365.25 * 24 * 60 * 60 * 1000)) : 0;
      const cagr = (years > 0 && initialEquity > 0 && finalEquity > 0)
        ? Math.pow(finalEquity / initialEquity, 1 / years) - 1
        : 0;
      summary.totalTrades = trades.length;
      summary.netProfit = realizedProfit;
      summary.finalEquity = finalEquity;
      summary.totalRetainedShares = shares;
      summary.cash = cash;
      summary.shares = shares;
      summary.maxDrawdown = maxDrawdown;
      summary.maxDrawdownPct = maxDrawdownPct * 100;
      summary.maxSharesHeld = maxSharesHeld;
      summary.cagr = cagr;
      return { trades, summary, equitySeries };
    }

    function runProgressiveGrid(rows, params) {
      const trades = [];
      const equitySeries = [];
      const summary = {
        totalTrades: 0,
        netProfit: 0,
        finalEquity: 0,
        totalRetainedShares: 0,
        cash: Number(params?.initialCash) || 0,
        shares: 0,
        maxDrawdown: 0,
        maxSharesHeld: 0,
        cagr: 0
      };
      if (!Array.isArray(rows) || !rows.length) {
        return { trades, summary, equitySeries };
      }
      const gridSize = Number(params?.gridSize);
      const gridOffset = Number(params?.gridOffset) || 0;
      const tradeValue = Number(params?.tradeValue);
      const initialCash = Number(params?.initialCash);
      const fractional = !!params?.fractionalShares;
      if (!Number.isFinite(gridSize) || gridSize <= 0 || !Number.isFinite(tradeValue) || tradeValue <= 0) {
        return { trades, summary, equitySeries };
      }
      let firstPrice = [rows[0]?.open, rows[0]?.close, rows[0]?.high, rows[0]?.low].map(Number).find(Number.isFinite);
      if (!Number.isFinite(firstPrice) || firstPrice <= 0) {
        return { trades, summary, equitySeries };
      }

      let minPrice = firstPrice;
      let maxPrice = firstPrice;
      for (const row of rows) {
        if (!row) continue;
        const low = Number(row.low);
        const high = Number(row.high);
        if (Number.isFinite(low)) minPrice = Math.min(minPrice, low);
        if (Number.isFinite(high)) maxPrice = Math.max(maxPrice, high);
      }
      if (!Number.isFinite(minPrice) || !Number.isFinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) {
        return { trades, summary, equitySeries };
      }

      const decimals = Math.min(Math.max(countDecimals(gridSize), 0), 4);
      const scale = Math.pow(10, Math.min(decimals + 2, 8));
      const roundToScale = (value) => Math.round(value * scale) / scale;
      const snapToGrid = (value, offset) => {
        if (!Number.isFinite(value)) return NaN;
        const snapped = Math.round((value - offset) / gridSize) * gridSize + offset;
        return roundToScale(snapped);
      };
      const floorToGrid = (value, offset) => {
        if (!Number.isFinite(value)) return NaN;
        const snapped = Math.floor((value - offset) / gridSize) * gridSize + offset;
        return roundToScale(snapped);
      };
      const EPS = 1e-9;

      const minGridLevel = floorToGrid(minPrice, gridOffset);

      let cash = Number.isFinite(initialCash) ? initialCash : GRID_DEFAULTS.initialCash;
      const initialEquity = cash;
      const firstEquityTime = rows[0]?.caldt instanceof Date ? new Date(rows[0].caldt.getTime()) : null;
      let lastEquityTime = firstEquityTime;
      let shares = 0;
      let realizedProfit = 0;
      let cumulativeRetained = 0;
      let prevPrice = firstPrice;
      let peakEquity = cash + shares * firstPrice;
      let maxDrawdown = 0;
      let maxDrawdownPct = 0;
      let maxSharesHeld = shares;

      const pendingBuys = new Map(); // key -> { key, level, groupId, direction }
      const pendingSells = new Set(); // entries with level, qty, buyPrice, buyTime
      let sellSeq = 1;
      let buyGroupSeq = 1;

      const queueBuy = (price, groupId = 0, direction = 'neutral') => {
        const level = snapToGrid(price, gridOffset);
        if (!Number.isFinite(level) || level <= 0) return null;
        const key = level.toFixed(6);
        if (pendingBuys.has(key)) {
          const existing = pendingBuys.get(key);
          if (groupId > 0) existing.groupId = groupId;
          if (direction) existing.direction = direction;
          return existing;
        }
        const entry = { key, level, groupId: groupId > 0 ? groupId : 0, direction };
        pendingBuys.set(key, entry);
        return entry;
      };

      const queueSell = (price, qty, buyPrice, buyTime) => {
        const level = snapToGrid(price, gridOffset);
        if (!Number.isFinite(level) || level <= 0) return null;
        const entry = {
          id: sellSeq++,
          level,
          qty,
          buyPrice,
          buyTime: buyTime instanceof Date ? new Date(buyTime.getTime()) : new Date()
        };
        pendingSells.add(entry);
        return entry;
      };

      const ensureDownCoverage = (fromLevel) => {
        let level = snapToGrid(fromLevel, gridOffset);
        if (!Number.isFinite(level)) return;
        while (level >= minGridLevel - EPS) {
          queueBuy(level, 0, 'down');
          const nextLevel = snapToGrid(level - gridSize, gridOffset);
          if (!Number.isFinite(nextLevel) || nextLevel >= level - EPS) break;
          level = nextLevel;
        }
      };

      const executeBuy = (entry, timestamp) => {
        if (!entry) return false;
        const price = entry.level;
        const qtyRaw = tradeValue / price;
        let qty = fractional ? qtyRaw : Math.floor(qtyRaw);
        if (!Number.isFinite(qty) || qty <= 0) return false;
        const cost = qty * price;
        if (cost > cash + EPS) return false;
        pendingBuys.delete(entry.key);
        if (entry.groupId > 0 && entry.direction === 'down') {
          const keysToRemove = [];
          for (const [otherKey, otherEntry] of pendingBuys.entries()) {
            if (otherEntry.groupId === entry.groupId) keysToRemove.push(otherKey);
          }
          for (const key of keysToRemove) pendingBuys.delete(key);
        }
        cash -= cost;
        shares += qty;
        if (shares > maxSharesHeld) maxSharesHeld = shares;
        const buyTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        queueSell(price + gridSize, qty, price, buyTime);
        if (entry.direction === 'down') {
          queueBuy(price - gridSize, buyGroupSeq++, 'down');
        } else if (entry.direction === 'up') {
          const desired = price - gridSize;
          const snapped = snapToGrid(desired, gridOffset);
          if (Number.isFinite(snapped)) {
            const key = snapped.toFixed(6);
            if (!pendingBuys.has(key)) {
              queueBuy(desired, buyGroupSeq++, 'down');
            }
          }
        }
        ensureDownCoverage(price - gridSize);
        return true;
      };

      const executeSell = (entry, timestamp) => {
        if (!entry) return false;
        pendingSells.delete(entry);
        const price = entry.level;
        const desiredRaw = tradeValue / price;
        let desired = fractional ? desiredRaw : Math.floor(desiredRaw);
        if (!Number.isFinite(desired) || desired <= 0) desired = entry.qty;
        let qty = Math.min(desired, entry.qty);
        if (shares + EPS < qty) qty = shares;
        if (qty <= 0) return false;
        const revenue = qty * price;
        const costBasis = qty * entry.buyPrice;
        cash += revenue;
        shares -= qty;
        const profit = revenue - costBasis;
        realizedProfit += profit;
        const qtyRetained = Math.max(0, entry.qty - qty);
        cumulativeRetained += qtyRetained;
        const sellTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const buyTime = entry.buyTime instanceof Date ? new Date(entry.buyTime.getTime()) : new Date();
        const msHeld = sellTime.getTime() - buyTime.getTime();
        const daysHeld = Number.isFinite(msHeld) ? Math.max(0, msHeld / 86400000) : 0;
        trades.push({
          buyTime,
          buyPrice: entry.buyPrice,
          buyQty: entry.qty,
          sellTime,
          sellPrice: price,
          sellQty: qty,
          qtyRetained,
          cumQtyRetained: cumulativeRetained,
          daysHeld,
          profit,
          roiPct: costBasis > 0 ? (profit / costBasis) * 100 : 0
        });
        const groupId = buyGroupSeq++;
        queueBuy(price + gridSize, groupId, 'up');
        queueBuy(price - gridSize, groupId, 'down');
        ensureDownCoverage(price - gridSize);
        return true;
      };

      const getNextSellAbove = (cursor, target) => {
        let best = null;
        for (const entry of pendingSells) {
          const lvl = entry.level;
          if (lvl > cursor + EPS && lvl <= target + EPS) {
            if (!best || lvl < best.level) best = entry;
          }
        }
        return best;
      };

      const getNextBuyAbove = (cursor, target) => {
        let best = null;
        for (const entry of pendingBuys.values()) {
          const lvl = entry.level;
          if (lvl > cursor + EPS && lvl <= target + EPS) {
            if (!best || lvl < best.level) best = entry;
          }
        }
        return best;
      };

      const getNextBuyBelow = (target, cursor) => {
        let best = null;
        for (const entry of pendingBuys.values()) {
          const lvl = entry.level;
          if (lvl < cursor - EPS && lvl >= target - EPS) {
            if (!best || lvl > best.level) best = entry;
          }
        }
        return best;
      };

      const processMove = (start, end, timestamp) => {
        const eventTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        if (end > start + EPS) {
          let cursor = start;
          const target = end;
          let guard = 0;
          while (guard < 2000) {
            guard += 1;
            const nextSell = getNextSellAbove(cursor, target);
            const nextBuy = getNextBuyAbove(cursor, target);
            let nextEntry = null;
            let type = null;
            if (nextSell && nextBuy) {
              if (nextSell.level <= nextBuy.level + EPS) {
                nextEntry = nextSell;
                type = 'sell';
              } else {
                nextEntry = nextBuy;
                type = 'buy';
              }
            } else if (nextSell) {
              nextEntry = nextSell;
              type = 'sell';
            } else if (nextBuy) {
              nextEntry = nextBuy;
              type = 'buy';
            } else {
              break;
            }
            cursor = nextEntry.level;
            if (type === 'sell') {
              if (!executeSell(nextEntry, eventTime)) break;
            } else {
              if (!executeBuy(nextEntry, eventTime)) break;
            }
          }
        } else if (end < start - EPS) {
          let cursor = start;
          const target = end;
          let guard = 0;
          while (guard < 2000) {
            guard += 1;
            const nextBuy = getNextBuyBelow(target, cursor);
            if (!nextBuy) break;
            cursor = nextBuy.level;
            if (!executeBuy(nextBuy, eventTime)) break;
          }
        }
      };

      const buildPath = (fromPrice, row) => {
        const path = [];
        let start = Number(fromPrice);
        if (!Number.isFinite(start)) start = Number(row.open) || Number(row.close) || 0;
        path.push(start);
        const addPoint = (value) => {
          const num = Number(value);
          if (!Number.isFinite(num)) return;
          if (Math.abs(num - path[path.length - 1]) < EPS) return;
          path.push(num);
        };
        const open = Number(row.open);
        const high = Number(row.high);
        const low = Number(row.low);
        const close = Number(row.close);
        if (Number.isFinite(open)) addPoint(open);
        const upBar = Number.isFinite(close) && Number.isFinite(open) ? (close >= open) : true;
        if (upBar) {
          if (Number.isFinite(high)) addPoint(high);
          if (Number.isFinite(low)) addPoint(low);
        } else {
          if (Number.isFinite(low)) addPoint(low);
          if (Number.isFinite(high)) addPoint(high);
        }
        if (Number.isFinite(close)) addPoint(close);
        return path;
      };

      const initialTime = rows[0]?.caldt instanceof Date ? new Date(rows[0].caldt.getTime()) : new Date();
      const initialBuy = queueBuy(firstPrice, buyGroupSeq++, 'down');
      if (initialBuy) executeBuy(initialBuy, initialTime);
      ensureDownCoverage(firstPrice - gridSize);

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const path = buildPath(prevPrice, row);
        for (let i = 1; i < path.length; i++) {
          const from = path[i - 1];
          const to = path[i];
          processMove(from, to, row.caldt);
        }
        prevPrice = path[path.length - 1];
        const equity = cash + shares * prevPrice;
        if (equity > peakEquity) peakEquity = equity;
        const drawdown = equity - peakEquity;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
        const drawdownPct = peakEquity > 0 ? drawdown / peakEquity : 0;
        if (drawdownPct < maxDrawdownPct) maxDrawdownPct = drawdownPct;
        lastEquityTime = new Date(row.caldt.getTime());
        equitySeries.push({
          time: new Date(row.caldt.getTime()),
          equity
        });
      }

      const finalEquity = cash + shares * prevPrice;
      const millis = firstEquityTime && lastEquityTime ? (lastEquityTime.getTime() - firstEquityTime.getTime()) : 0;
      const years = millis > 0 ? (millis / (365.25 * 24 * 60 * 60 * 1000)) : 0;
      const cagr = (years > 0 && initialEquity > 0 && finalEquity > 0)
        ? Math.pow(finalEquity / initialEquity, 1 / years) - 1
        : 0;
      summary.totalTrades = trades.length;
      summary.netProfit = realizedProfit;
      summary.finalEquity = finalEquity;
      summary.totalRetainedShares = shares;
      summary.cash = cash;
      summary.shares = shares;
      summary.maxDrawdown = maxDrawdown;
      summary.maxDrawdownPct = maxDrawdownPct * 100;
      summary.maxSharesHeld = maxSharesHeld;
      summary.cagr = cagr;
      return { trades, summary, equitySeries };
    }

    function runGridBacktest() {
      if (!Array.isArray(ROWS) || !ROWS.length) {
        setGridStatus('Load symbol data before running the backtest.');
        return;
      }
      const params = getGridParamsFromUI();
      setGridStatus('Running backtest…');
      try {
        const result = runPullbackGridSimulation(ROWS, params);
        GRID_STATE = result;
        renderGridSummary(result.summary);
        renderGridTrades(result.trades);
        renderGridEquityChart(result.equitySeries);
        if (result.trades.length) {
          const profitLabel = formatCurrency(result.summary?.netProfit ?? 0);
          setGridStatus(`Backtest completed with ${result.trades.length} trade${result.trades.length === 1 ? '' : 's'}. Net profit ${profitLabel}.`);
        } else {
          setGridStatus('No completed trades for the selected parameters.');
        }
      } catch (err) {
        console.error('Pullback grid backtest error', err);
        setGridStatus('Failed to run backtest. See console for details.');
      }
    }

    function initGridControls() {
      const btn = document.getElementById('btnRunGridBacktest');
      if (btn) {
        btn.addEventListener('click', () => runGridBacktest());
      }
      const inputs = [
        document.getElementById('selGridType'),
        document.getElementById('inpGridSize'),
        document.getElementById('inpGridOffset'),
        document.getElementById('inpTradeValue'),
        document.getElementById('inpInitialCash'),
        document.getElementById('inpFractionalShares')
      ];
      inputs.forEach(el => {
        if (!el) return;
        const handler = () => {
          if (!Array.isArray(ROWS) || !ROWS.length) return;
          runGridBacktest();
        };
        const eventName = el.tagName === 'SELECT' || el.type === 'checkbox' ? 'change' : 'input';
        el.addEventListener(eventName, handler);
      });
      resetGridOutputs('Load data and run the backtest to populate results.');
      setRunButtonEnabled(false);
    }


    async function loadSymbolData(sym) {
      const baseSymbol = (sym || '').trim();
      if (!baseSymbol) return false;
      setStatus(`Loading data for ${baseSymbol}…`);
      setGridStatus(`Loading data for ${baseSymbol}…`);
      setRunButtonEnabled(false);
      const candidates = Array.from(new Set([
        baseSymbol,
        baseSymbol.toUpperCase(),
        baseSymbol.toLowerCase()
      ])).filter(Boolean);
      let lastError = null;
      for (const candidate of candidates) {
        const path = `data/${candidate}_1m.csv`;
        try {
          const res = await fetch(path, { cache: 'no-cache' });
          if (!res.ok) {
            lastError = `HTTP ${res.status} loading ${path}`;
            continue;
          }
          const text = await res.text();
          const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
          if (parsed.errors && parsed.errors.length) {
            console.warn('CSV parse warnings:', parsed.errors.slice(0, 3));
          }
          normalizeAndIndex(parsed.data);
          if (!ROWS.length) {
            lastError = 'No valid rows in dataset.';
            continue;
          }
          updateSymbolPrecisionFromRows(baseSymbol, parsed.data);
          setStatus(`Loaded ${ROWS.length} rows across ${DAYS.length} day(s).`);
          renderGridSummary(null);
          renderGridTrades([]);
          renderGridEquityChart(null);
          renderDataSummary();
          setGridStatus(`Loaded ${ROWS.length.toLocaleString()} bars across ${DAYS.length.toLocaleString()} day(s). Running backtest…`);
          setRunButtonEnabled(true);
          runGridBacktest();
          return true;
        } catch (err) {
          lastError = err && err.message ? err.message : String(err);
        }
      }
      console.error(`Failed to load ${baseSymbol}: ${lastError || 'not found'}`);
      setStatus(`Error loading ${baseSymbol}: ${lastError || 'File not found.'}`);
      setGridStatus(`Error loading ${baseSymbol}: ${lastError || 'File not found.'}`);
      ROWS = [];
      DAY_GROUPS = new Map();
      DAYS = [];
      renderGridSummary(null);
      renderGridTrades([]);
      renderGridEquityChart(null);
      setRunButtonEnabled(false);
      renderDataSummary();
      return false;
    }

    function normalizeSymbolEntries(entries) {
      const map = new Map();
      const ordered = [];
      if (!Array.isArray(entries)) return { list: ordered, map };
      for (const entry of entries) {
        let symbol = '';
        let name = '';
        let multiplier = null;
        if (typeof entry === 'string') {
          symbol = entry;
          name = entry;
        } else if (entry && typeof entry === 'object') {
          symbol = entry.symbol;
          name = entry.name || entry.symbol || '';
          multiplier = entry.multiplier;
        } else {
          continue;
        }
        symbol = (symbol || '').toUpperCase().trim();
        if (!symbol || map.has(symbol)) continue;
        const existing = SYMBOL_META.get(symbol) || null;
        const parsedMultiplier = Number(multiplier);
        const finalMultiplier = Number.isFinite(parsedMultiplier) && parsedMultiplier > 0
          ? parsedMultiplier
          : (existing && Number.isFinite(existing.multiplier) ? existing.multiplier : 1);
        const providedPrecision = entry && typeof entry === 'object' && Number.isInteger(entry.precision) && entry.precision >= 0
          ? Math.min(entry.precision, 8)
          : null;
        const meta = {
          symbol,
          name: (typeof name === 'string' && name.trim()) ? name.trim() : (existing && existing.name ? existing.name : symbol),
          multiplier: finalMultiplier,
          precision: providedPrecision != null
            ? providedPrecision
            : (existing && Number.isInteger(existing.precision) ? existing.precision : null)
        };
        map.set(symbol, meta);
        ordered.push(meta);
      }
      return { list: ordered, map };
    }

    async function populateTickerSegment() {
      const container = document.getElementById('tickerSegment');
      if (!container) return;
      container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';
      const render = (entries) => {
        const normalized = normalizeSymbolEntries(entries);
        SYMBOL_META = normalized.map instanceof Map ? normalized.map : new Map();
        const list = Array.isArray(normalized.list) ? normalized.list : [];
        container.innerHTML = '';
        if (!list.length) {
          container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">No symbols available.</span>';
          highlightTickerButton(currentTicker);
          return;
        }
        list.forEach((meta) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'w-full h-full px-3 py-2 text-left bg-white hover:bg-emerald-50 transition flex flex-col justify-center gap-0.5 leading-tight';
          btn.setAttribute('data-symbol', meta.symbol);
          btn.setAttribute('title', meta.name);
          btn.dataset.multiplier = String(meta.multiplier);
          btn.innerHTML = `
            <span class="text-sm font-semibold">${meta.symbol}</span>
            <span class="text-xs text-slate-500" data-symbol-name>${meta.name}</span>
          `;
          container.appendChild(btn);
        });
        highlightTickerButton(currentTicker);
        if (!currentTicker && list[0]) {
          setTicker(list[0].symbol);
          loadSymbolData(list[0].symbol);
        }
      };
      try {
        const res = await fetch('data/index.json', { cache: 'no-cache' });
        if (res.ok) {
          const list = await res.json();
          if (Array.isArray(list) && list.length) { render(list); return; }
        }
      } catch (err) {
        console.warn('Failed to load index.json', err);
      }
      try {
        const res = await fetch('data/', { cache: 'no-cache' });
        if (res.ok) {
          const text = await res.text();
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let files = [];
          if (ct.includes('text/html')) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            files = Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href')).filter(Boolean);
          } else {
            files = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          }
          const regex = /^([A-Za-z0-9-]+)_1m\.csv$/i;
          const syms = [];
          for (const f of files) {
            const name = (f || '').split('/').pop();
            const m = name.match(regex);
            if (m) syms.push({ symbol: m[1].toUpperCase(), name: m[1].toUpperCase(), multiplier: undefined });
          }
          if (syms.length) { render(syms); return; }
        }
      } catch (err) {
        console.warn('Failed to enumerate data directory', err);
      }
      render(['TQQQ', 'TSLA', 'PLTR', 'UVXY']);
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#tickerSegment button[data-symbol]');
      if (!btn) return;
      const symbol = btn.getAttribute('data-symbol');
      if (!symbol) return;
      setTicker(symbol);
      loadSymbolData(symbol);
    });

    document.addEventListener('DOMContentLoaded', () => {
      initGridControls();
      populateTickerSegment();
    });

    window.addEventListener('resize', () => {
      if (gridEquityChartInst) {
        try { gridEquityChartInst.resize(); } catch {}
      }
    });
  })();
</script>
</body>
</html>
