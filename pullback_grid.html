
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grid Backtest</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"
  />
  <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
  <!-- Apache ECharts for interactive charts (mobile pinch-zoom supported) -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    .num-pos { color: #119d6e !important; }
    .num-neg { color: #ff0000 !important; }
    .pnl-strong { font-size: 1.8rem !important; }
    .sticky-th { position: sticky; top: 0; background: white; z-index: 1; }
    .shadow-soft { box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
    thead th { position: sticky; top: 0; background: white; z-index: 1; }
    th.sortable button {
      width: 100%;
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.35rem;
      font: inherit;
      color: inherit;
      background: transparent;
      border: none;
      padding: 0;
      cursor: pointer;
    }
    th.sortable button:focus-visible {
      outline: 2px solid rgba(16, 185, 129, 0.6);
      outline-offset: 2px;
    }
    th.sortable .sort-indicator {
      font-size: 0.65rem;
      opacity: 0.4;
    }
    th[data-sort="asc"] .sort-indicator::after {
      content: "▲";
      opacity: 0.9;
    }
    th[data-sort="desc"] .sort-indicator::after {
      content: "▼";
      opacity: 0.9;
    }
    th[data-sort="none"] .sort-indicator::after {
      content: "↕";
    }

    /* Hide native spin buttons for key numeric inputs */
    #inp_orb_m::-webkit-outer-spin-button,
    #inp_orb_m::-webkit-inner-spin-button,
    #inp_target_R::-webkit-outer-spin-button,
    #inp_target_R::-webkit-inner-spin-button,
    #inp_stop_R::-webkit-outer-spin-button,
    #inp_stop_R::-webkit-inner-spin-button,
    #inp_risk_pct::-webkit-outer-spin-button,
    #inp_risk_pct::-webkit-inner-spin-button,
    #inp_aum0::-webkit-outer-spin-button,
    #inp_aum0::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    #inp_orb_m,
    #inp_target_R,
    #inp_stop_R,
    #inp_risk_pct,
    #inp_aum0 {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Generic: hide spinners for any future number input */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Segment controls responsive layout */
    #tickerSegment {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      grid-auto-rows: 1fr;
      width: 100%;
      gap: 1px;
    }
    #tickerSegment button {
      width: 100%;
      height: 100%;
    }
    #sessionSegment {
      display: flex;
      flex-wrap: wrap;
      max-width: 100%;
      min-width: 0;
      white-space: normal;
    }
    #sessionSegment button {
      flex: 0 0 auto;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Site navigation -->
  <nav class="bg-white border-b border-slate-200 sticky top-0 z-50 shadow-sm">
    <div class="max-w-screen-2xl mx-auto px-6 py-3 flex items-center gap-4">
      <div class="flex items-center gap-6 flex-1 min-w-0">
        <div class="flex items-center gap-2 font-semibold text-slate-800">
          <svg class="h-5 w-5 text-emerald-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" fill="currentColor" aria-hidden="true"><path d="M192 384L88.5 384C63.6 384 48.3 356.9 61.1 335.5L114 247.3C122.7 232.8 138.3 224 155.2 224L250.2 224C326.3 95.1 439.8 88.6 515.7 99.7C528.5 101.6 538.5 111.6 540.3 124.3C551.4 200.2 544.9 313.7 416 389.8L416 484.8C416 501.7 407.2 517.3 392.7 526L304.5 578.9C283.2 591.7 256 576.3 256 551.5L256 448C256 412.7 227.3 384 192 384L191.9 384zM464 224C464 197.5 442.5 176 416 176C389.5 176 368 197.5 368 224C368 250.5 389.5 272 416 272C442.5 272 464 250.5 464 224z"/></svg>
          <span>GRID</span>
        </div>
        <div class="flex items-center gap-2 flex-wrap">
          <a data-nav href="pullback_grid.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Grid Backtest</a>
          <a data-nav href="grid_calc.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Grid Calculator</a>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button
          type="button"
          id="btnExportData"
          class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600"
          title="Export saved backtest data"
        >
          <i class="fa fa-download"></i>
          <span>Export</span>
        </button>
        <button
          type="button"
          id="btnImportData"
          class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600"
          title="Import saved backtest data"
        >
          <i class="fa fa-upload"></i>
          <span>Import</span>
        </button>
        <input
          type="file"
          id="inputImportData"
          accept="application/json"
          class="hidden"
        />
      </div>
    </div>
  </nav>
  <script>
    // Activate nav item for current page
    (function(){
      try {
        const file = (location.pathname.split('/').pop() || 'pullback_grid.html').toLowerCase();
        document.querySelectorAll('a[data-nav]').forEach(a => {
          const href = (a.getAttribute('href') || '').toLowerCase();
          const active = href === file || (file === '' && href.endsWith('index.html'));
          a.classList.toggle('bg-slate-800', active);
          a.classList.toggle('text-white', active);
          a.classList.toggle('hover:bg-slate-100', !active);
          if (active) a.setAttribute('aria-current','page'); else a.removeAttribute('aria-current');
        });
      } catch {}
    })();
  </script>

  <div class="max-w-screen-2xl mx-auto p-6 space-y-6">
    <header class="mb-2">
      <h1 id="mainTitle" class="text-2xl md:text-3xl font-semibold">Buy-the-Dip Grid Backtest</h1>
      <p class="text-slate-600 mt-1">Under construction. Hook up buy-the-dip grid datasets and controls here.</p>
    </header>

    <section id="symbolPicker" class="bg-white rounded-2xl shadow-soft p-3 md:p-4">
      <div class="overflow-x-auto -mx-3 md:mx-0 px-3 md:px-0">
        <nav class="flex min-w-max border-b border-slate-200 gap-1" role="tablist">
          <button type="button" class="inline-flex items-center gap-2 border-b-2 border-blue-500 px-3 py-2 text-sm font-medium text-slate-900 transition">
            <span class="inline-flex h-8 w-8 items-center justify-center text-emerald-500">
              <ion-icon name="grid-outline" class="text-2xl"></ion-icon>
            </span>
            <span>Buy-the-Dip Grid</span>
          </button>
        </nav>
      </div>

      <div class="flex-1 min-w-0 mt-4">
        <div class="flex items-center gap-2 mb-2">
          <div class="flex-1 min-w-0">
            <div id="tickerSegment" class="w-full rounded-xl border border-slate-200 bg-slate-200 p-px overflow-hidden">
              <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
            </div>
          </div>
        </div>
        <div id="status" class="text-xs text-slate-500"></div>
      </div>
    </section>

    <section class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-3">
      <div class="flex flex-col gap-1">
        <h2 class="font-semibold text-slate-700">Dataset</h2>
        <p id="dataSummary" class="text-sm text-slate-500">Select a symbol to load intraday data.</p>
      </div>
      <div class="rounded-xl border border-slate-200 bg-slate-50 p-4 text-xs text-slate-500 leading-relaxed">
        <p>Files must contain 1-minute OHLC data with columns for <code>caldt</code>, <code>day</code>, <code>open</code>, <code>high</code>, <code>low</code>, and <code>close</code>. The buy-the-dip grid simulation evaluates each minute to detect fills, so ensure the CSV spans the period you want to test.</p>
      </div>
    </section>

    <section id="gridParameters" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
        <div>
          <h2 class="font-semibold text-slate-700">Grid Parameters</h2>
          <p class="text-sm text-slate-500">Adjust spacing and sizing, then run the backtest on the loaded symbol.</p>
        </div>
        <button
          type="button"
          id="btnRunGridBacktest"
          class="inline-flex items-center justify-center gap-2 rounded-xl bg-emerald-600 px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-emerald-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-500 disabled:cursor-not-allowed disabled:bg-slate-300"
          disabled
        >
          <ion-icon name="play-outline" class="text-lg"></ion-icon>
          <span>Run Backtest</span>
        </button>
      </div>

      <div class="grid gap-4 md:grid-cols-8">
        <label class="block">
          <span class="text-sm text-slate-600">Grid Type</span>
          <div class="relative mt-1">
            <select
              id="selGridType"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="pullback" selected>Buy-the-Dip Grid</option>
              <option value="progressive">Progressive Grid</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Entry Filter</span>
          <div class="relative mt-1">
            <select
              id="selEntryFilter"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="none" selected>None</option>
              <option value="sma10">10 SMA</option>
              <option value="sma20">20 SMA</option>
              <option value="sma50">50 SMA</option>
              <option value="sma100">100 SMA</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Retained Shares</span>
          <div class="relative mt-1" title="Choose how much of a profitable leg to leave on after selling the trade-value portion.">
            <select
              id="selRetentionMode"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="none">None</option>
              <option value="profit" selected>Profit Portion</option>
              <option value="profit_plus_5">Profit + 5%</option>
              <option value="profit_plus_10">Profit + 10%</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Grid Spacing</span>
          <div class="relative mt-1">
            <select
              id="selGridSpacing"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="fixed">Fixed Price</option>
              <option value="percent" selected>Percentage</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span id="gridSizeLabel" class="text-sm text-slate-600">Grid Size ($)</span>
          <div class="mt-1 relative">
            <input
              id="inpGridSize"
              type="number"
              step="0.5"
              min="0.5"
              value="5"
              class="w-full border border-slate-200 bg-white text-slate-700 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            />
            <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase grid size" data-num-target="inpGridSize" data-num-step="1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd" /></svg>
              </button>
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease grid size" data-num-target="inpGridSize" data-num-step="-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd" /></svg>
              </button>
            </div>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Grid Offset ($)</span>
          <div class="mt-1 relative">
            <input
              id="inpGridOffset"
              type="number"
              step="0.5"
              value="0"
              class="w-full border border-slate-200 bg-white text-slate-700 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            />
            <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase grid offset" data-num-target="inpGridOffset" data-num-step="1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd" /></svg>
              </button>
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease grid offset" data-num-target="inpGridOffset" data-num-step="-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd" /></svg>
              </button>
            </div>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Trade Value ($)</span>
          <input
            id="inpTradeValue"
            type="number"
            step="100"
            min="100"
            value="1000"
            class="mt-1 w-full appearance-none rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
          />
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Initial Cash ($)</span>
          <input
            id="inpInitialCash"
            type="number"
            step="100"
            min="0"
            value="10000"
            class="mt-1 w-full appearance-none rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
          />
        </label>
        <label class="flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-600 shadow-sm transition focus-within:ring-2 focus-within:ring-emerald-500/60">
          <input
            id="inpFractionalShares"
            type="checkbox"
            class="h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-500"
            checked
          />
          <span>Allow fractional shares</span>
        </label>
        <label class="flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-600 shadow-sm transition focus-within:ring-2 focus-within:ring-emerald-500/60">
          <input
            id="inpAllowMargin"
            type="checkbox"
            class="h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-500"
            checked
          />
          <span>Allow margin (borrow cash)</span>
        </label>
      </div>
    </section>

    <section id="gridSummarySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
        <div>
          <h2 class="font-semibold text-slate-700">Summary</h2>
          <p id="gridStatus" class="text-sm text-slate-500">Load data and run the backtest to populate results.</p>
        </div>
        <div class="flex flex-wrap items-center gap-x-6 gap-y-2 text-xs text-slate-500">
          <span>Min Cash:</span>
          <span id="summaryMinCash" class="text-sm font-semibold text-slate-800">$0.00</span>
          <span>Cash:</span>
          <span id="summaryCash" class="text-sm font-semibold text-slate-800">$0.00</span>
          <span>Shares:</span>
          <span id="summaryShares" class="text-sm font-semibold text-slate-800">0</span>
        </div>
      </div>
      <dl class="grid gap-4 sm:grid-cols-2 lg:grid-cols-8">
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Completed Trades</dt>
          <dd id="summaryTotalTrades" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Net Profit</dt>
          <dd id="summaryNetProfit" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Final Equity</dt>
          <dd id="summaryFinalEquity" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">CAGR</dt>
          <dd id="summaryCagr" class="mt-2 text-xl font-semibold text-slate-800">0.00%</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Retained Shares</dt>
          <dd id="summaryRetained" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Drawdown</dt>
          <dd id="summaryMaxDD" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Drawdown %</dt>
          <dd id="summaryMaxDDPct" class="mt-2 text-xl font-semibold text-slate-800">0.00%</dd>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Shares Held</dt>
          <dd id="summaryMaxShares" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
        </div>
      </dl>
    </section>

    <section id="gridEquitySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Equity Curve</h2>
        <span id="equitySummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="gridEquityChart" class="w-full h-72 md:h-96"></div>
        <div id="gridEquityEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to plot equity over time.
        </div>
      </div>
    </section>

    <section id="gridLadderSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Ladder Activity</h2>
        <span id="ladderSummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="gridLadderChart" class="w-full h-72 md:h-80"></div>
        <div id="gridLadderEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to visualize ladder entries and exits.
        </div>
      </div>
    </section>

    <section id="gridTradesSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Trade Log</h2>
        <span id="tradeCountLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="overflow-x-auto">
        <table class="min-w-full divide-y divide-slate-200 text-sm">
          <thead class="bg-slate-50 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">
            <tr>
              <th class="px-3 py-2 sortable" data-sort-key="buyTime"><button type="button"><span>Buy Time</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="buyPrice"><button type="button"><span>Buy Price</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="buyQty"><button type="button"><span>Buy Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="gridLevel"><button type="button"><span>Grid Level</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 sortable" data-sort-key="sellTime"><button type="button"><span>Sell Time</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="sellPrice"><button type="button"><span>Sell Price</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="sellQty"><button type="button"><span>Sell Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="qtyRetained"><button type="button"><span>Qty Retained</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="cumQtyRetained"><button type="button"><span>Cum Retained</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="daysHeld"><button type="button"><span>Days Held</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="profit"><button type="button"><span>Profit $</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="roiPct"><button type="button"><span>ROI %</span><span class="sort-indicator"></span></button></th>
            </tr>
          </thead>
          <tbody id="gridTradeRows" class="divide-y divide-slate-100"></tbody>
        </table>
        <div id="gridTradesEmpty" class="py-6 text-center text-sm text-slate-500">Run the backtest to see individual trades.</div>
      </div>
    </section>
  </div>
<script>
  (function(){
    const DEFAULT_PRICE_PRECISION = 2;
    const GRID_DEFAULTS = {
      gridSize: 5,
      gridSpacingType: 'percent',
      tradeValue: 1000,
      initialCash: 10000,
      fractionalShares: true,
      entryFilter: 'none'
    };
    const CURRENCY_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const NUMBER_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const NUMBER_FORMAT_4 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 4, maximumFractionDigits: 4 });
    const PERCENT_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const DAILY_SMA_WINDOWS = [10, 20, 50, 100];
    const SMA_FILTER_LOOKUP = {
      sma10: 10,
      sma20: 20,
      sma50: 50,
      sma100: 100
    };
    const RESAMPLE_INTERVAL_MINUTES = 10;
    const SMA_PROPERTY_BY_WINDOW = {
      10: 'sma10',
      20: 'sma20',
      50: 'sma50',
      100: 'sma100'
    };
    const SMA_PROPERTIES = Object.values(SMA_PROPERTY_BY_WINDOW);

    const pad2 = (n) => String(n).padStart(2, '0');
    const dateKeyFromStr = (val) => {
      if (val == null) return null;
      if (typeof val === 'string') {
        const m = val.trim().match(/^(\d{4}-\d{2}-\d{2})/);
        if (m) return m[1];
      }
      const d = new Date(val);
      if (isNaN(d)) return null;
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
    };

    let currentTicker = '';
    let ROWS = [];
    let DAY_GROUPS = new Map();
    let DAYS = [];
    let DAY_SMA_MAPS = new Map();
    let SMA_METADATA = new Map();
    let SYMBOL_META = new Map();
    let GRID_STATE = { trades: [], summary: null, equitySeries: [], ladderHistory: [] };
    let TRADE_SORT_STATE = { key: 'buyTime', dir: 'asc' };
    let gridEquityChartInst = null;
    let gridLadderChartInst = null;

    function setStatus(msg) {
      const el = document.getElementById('status');
      if (el) el.textContent = msg || '';
    }

    function setGridStatus(msg) {
      const el = document.getElementById('gridStatus');
      if (el) el.textContent = msg || '';
    }

    function setRunButtonEnabled(enabled) {
      const btn = document.getElementById('btnRunGridBacktest');
      if (!btn) return;
      btn.disabled = !enabled;
      btn.classList.toggle('opacity-70', !enabled);
    }

    function updateGridSizeLabel() {
      const label = document.getElementById('gridSizeLabel');
      if (!label) return;
      const spacingType = (document.getElementById('selGridSpacing')?.value || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      label.textContent = spacingType === 'percent' ? 'Grid Size (%)' : 'Grid Size ($)';
      const input = document.getElementById('inpGridSize');
      if (input) {
        if (spacingType === 'percent') {
          input.min = '0.1';
          input.step = '0.1';
        } else {
          input.min = '0.5';
          input.step = '0.5';
        }
      }
    }

    function ensureSymbolMetaEntry(symbol) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return null;
      if (!SYMBOL_META.has(sym)) {
        SYMBOL_META.set(sym, { symbol: sym, name: sym, multiplier: 1, precision: DEFAULT_PRICE_PRECISION });
      }
      const meta = SYMBOL_META.get(sym);
      if (meta && !meta.symbol) meta.symbol = sym;
      return meta || null;
    }

    function countPriceDecimals(value) {
      if (!Number.isFinite(value)) return 0;
      const str = Number(value).toFixed(8).replace(/0+$/,'').replace(/\.$/,'');
      const idx = str.indexOf('.');
      return idx >= 0 ? (str.length - idx - 1) : 0;
    }

    function inferPricePrecisionFromRows(rows) {
      if (!Array.isArray(rows)) return DEFAULT_PRICE_PRECISION;
      let maxDecimals = 0;
      const limit = Math.min(rows.length, 400);
      for (let i = 0; i < limit; i++) {
        const row = rows[i];
        if (!row) continue;
        const values = [row.open, row.high, row.low, row.close];
        for (const val of values) {
          const decimals = countPriceDecimals(val);
          if (decimals > maxDecimals) {
            maxDecimals = decimals;
            if (maxDecimals >= 6) return 6;
          }
        }
      }
      return Math.min(Math.max(maxDecimals, DEFAULT_PRICE_PRECISION), 8);
    }

    function updateSymbolPrecisionFromRows(symbol, rows) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return;
      const precision = inferPricePrecisionFromRows(rows);
      const meta = ensureSymbolMetaEntry(sym);
      if (meta) {
        meta.precision = precision;
        SYMBOL_META.set(sym, meta);
      }
    }

    function countDecimals(value) {
      if (!Number.isFinite(value)) return 0;
      const s = String(value);
      if (!s.includes('.')) return 0;
      const trimmed = s.replace(/0+$/, '');
      const idx = trimmed.indexOf('.');
      return idx >= 0 ? (trimmed.length - idx - 1) : 0;
    }

    function formatCurrency(value) {
      if (!Number.isFinite(value)) return '$0.00';
      return `$${CURRENCY_FORMAT.format(value)}`;
    }

    function formatNumber(value, digits = 2) {
      if (!Number.isFinite(value)) return digits === 4 ? '0.0000' : '0.00';
      if (digits === 4) return NUMBER_FORMAT_4.format(value);
      return NUMBER_FORMAT.format(value);
    }

    function formatPercent(value) {
      if (!Number.isFinite(value)) return '0.00%';
      return `${PERCENT_FORMAT.format(value)}%`;
    }

    function formatDateTime(value) {
      if (!(value instanceof Date) || isNaN(value)) return '';
      const year = value.getFullYear();
      const month = pad2(value.getMonth() + 1);
      const day = pad2(value.getDate());
      const hour = pad2(value.getHours());
      const minute = pad2(value.getMinutes());
      return `${year}-${month}-${day} ${hour}:${minute}`;
    }

    // Numeric steppers for grid controls
    (function(){
      function decimals(stepStr){
        if (!stepStr) return 0;
        const s = String(stepStr);
        const idx = s.indexOf('.');
        return idx === -1 ? 0 : (s.length - idx - 1);
      }
      function roundTo(value, step){
        const d = decimals(step);
        return Number(value.toFixed(d));
      }
      function adjustNumberInput(id, deltaUnits){
        const el = document.getElementById(id);
        if (!el) return;
        const stepAttr = parseFloat(el.getAttribute('step') || '1');
        const step = Number.isFinite(stepAttr) && stepAttr > 0 ? stepAttr : 1;
        const minAttr = parseFloat(el.getAttribute('min'));
        const maxAttr = parseFloat(el.getAttribute('max'));
        const defAttr = parseFloat(el.getAttribute('data-default'));
        const curVal = parseFloat(el.value);
        const base = Number.isFinite(curVal) ? curVal : (Number.isFinite(defAttr) ? defAttr : 0);
        const next = base + (Number(deltaUnits) || 0) * step;
        const clamped = Math.min(Number.isFinite(maxAttr) ? maxAttr : Infinity, Math.max(Number.isFinite(minAttr) ? minAttr : -Infinity, next));
        const rounded = roundTo(clamped, step);
        el.value = String(rounded);
        el.dispatchEvent(new Event('change', { bubbles: true }));
        el.dispatchEvent(new Event('input', { bubbles: true }));
      }
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-num-target][data-num-step]');
        if (!btn) return;
        const id = btn.getAttribute('data-num-target');
        const delta = parseFloat(btn.getAttribute('data-num-step')) || 0;
        adjustNumberInput(id, delta);
      });
    })();

    const RETENTION_EXTRA_PCT = {
      none: 0,
      profit: 0,
      profit_plus_5: 0.05,
      profit_plus_10: 0.10
    };

    function computeSellExecution({ baseQty, desiredQty, sharesAvailable, mode, fractional }) {
      const normalizedMode = (mode || 'profit').toLowerCase();
      const safeDesired = Number.isFinite(desiredQty) && desiredQty > 0 ? desiredQty : baseQty;
      let desiredSell = Math.min(baseQty, safeDesired);
      if (!Number.isFinite(desiredSell) || desiredSell < 0) desiredSell = baseQty;
      const baseRetained = Math.max(0, baseQty - desiredSell);
      let targetRetained;
      switch (normalizedMode) {
        case 'none':
          targetRetained = 0;
          break;
        case 'profit':
          targetRetained = baseRetained;
          break;
        case 'profit_plus_5':
        case 'profit_plus_10':
          targetRetained = baseRetained + (RETENTION_EXTRA_PCT[normalizedMode] || 0) * baseQty;
          break;
        default:
          targetRetained = baseRetained;
          break;
      }
      targetRetained = Math.min(baseQty, Math.max(0, targetRetained));
      let targetSell = baseQty - targetRetained;
      let qty = Math.max(0, Math.min(targetSell, baseQty, Number.isFinite(sharesAvailable) ? sharesAvailable : baseQty));
      if (!fractional) {
        qty = Math.floor(qty);
        if (qty <= 0 && baseQty > 0 && (Number.isFinite(sharesAvailable) ? sharesAvailable : baseQty) > 0) {
          qty = Math.min(baseQty, Number.isFinite(sharesAvailable) ? sharesAvailable : baseQty, 1);
        }
      }
      const retained = Math.max(0, baseQty - qty);
      return { qty, retained };
    }

    function createGridSpacingHelpers({ spacingType, gridSize, gridOffset, firstPrice }) {
      const type = (spacingType || 'fixed').toLowerCase();
      if (type === 'percent') {
        const rawPercent = Number(gridSize);
        const percent = rawPercent / 100;
        if (!Number.isFinite(percent) || percent <= 0 || percent >= 1) {
          return { error: 'invalid_percent' };
        }
        const anchorOffset = Number(gridOffset);
        const anchorBase = Number.isFinite(anchorOffset) && anchorOffset > 0 ? anchorOffset : null;
        const anchor = Math.max(anchorBase != null ? anchorBase : Number(firstPrice) || 0, 1e-9);
        const ratio = 1 + percent;
        const logRatio = Math.log(ratio);
        const priceTolerance = 1e-6;
        const snap = (value) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          const idx = Math.round(Math.log(value / anchor) / logRatio);
          return anchor * Math.pow(ratio, idx);
        };
        const move = (value, steps = 1) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          return snap(value * Math.pow(ratio, steps));
        };
        const nextUp = (value) => move(value, 1);
        const nextDown = (value) => move(value, -1);
        const stepsBetween = (from, to) => {
          if (!Number.isFinite(from) || !Number.isFinite(to) || from <= 0 || to <= 0) return 0;
          return Math.log(to / from) / logRatio;
        };
        const key = (value) => {
          if (!Number.isFinite(value) || value <= 0) return 'nan';
          const idx = Math.round(Math.log(value / anchor) / logRatio * 1e6) / 1e6;
          return `p${idx}`;
        };
        const floor = (value) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          const idx = Math.floor(Math.log(value / anchor) / logRatio);
          return anchor * Math.pow(ratio, idx);
        };
        const ceil = (value) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          const idx = Math.ceil(Math.log(value / anchor) / logRatio);
          return anchor * Math.pow(ratio, idx);
        };
        return {
          type,
          gridSize: rawPercent,
          percent,
          anchor,
          ratio,
          logRatio,
          snap,
          move,
          nextUp,
          nextDown,
          stepsBetween,
          key,
          floor,
          ceil,
          priceTolerance
        };
      }
      const size = Number(gridSize);
      if (!Number.isFinite(size) || size <= 0) {
        return { error: 'invalid_fixed' };
      }
      const offset = Number(gridOffset) || 0;
      const decimals = Math.min(Math.max(countDecimals(size), 0), 4);
      const scale = Math.pow(10, Math.min(decimals + 2, 8));
      const round = (value) => Math.round(value * scale) / scale;
      const snap = (value) => {
        if (!Number.isFinite(value)) return NaN;
        const snapped = offset + Math.round((value - offset) / size) * size;
        return round(snapped);
      };
      const move = (value, steps = 1) => snap(value + steps * size);
      const nextUp = (value) => move(value, 1);
      const nextDown = (value) => move(value, -1);
      const stepsBetween = (from, to) => {
        if (!Number.isFinite(from) || !Number.isFinite(to)) return 0;
        return (to - from) / size;
      };
      const key = (value) => snap(value).toFixed(6);
      const floor = (value) => {
        if (!Number.isFinite(value)) return NaN;
        return snap(offset + Math.floor((value - offset) / size) * size);
      };
      const ceil = (value) => {
        if (!Number.isFinite(value)) return NaN;
        return snap(offset + Math.ceil((value - offset) / size) * size);
      };
      return {
        type: 'fixed',
        gridSize: size,
        snap,
        move,
        nextUp,
        nextDown,
        stepsBetween,
        key,
        floor,
        ceil,
        priceTolerance: 1e-9,
        decimals,
        scale,
        round
      };
    }

    function passesEntryFilter(price, row, filter) {
      const normalized = (filter || 'none').toLowerCase();
      if (normalized === 'none') return true;
      if (!row) return false;
      const candidates = [
        Number(price),
        Number(row.open),
        Number(row.high),
        Number(row.close)
      ].filter(Number.isFinite);
      if (!candidates.length) return false;
      const priceNum = Math.min(...candidates);
      const windowLength = SMA_FILTER_LOOKUP[normalized];
      if (!windowLength) return true;
      const prop = SMA_PROPERTY_BY_WINDOW[windowLength];
      const comparison = prop ? row[prop] : null;
      if (!Number.isFinite(comparison) || Math.abs(comparison) < 1e-9) return true;
      const tolerance = 1e-9 * Math.max(1, Math.abs(comparison));
      return priceNum >= (comparison - tolerance);
    }

    function getEntryFilterWindow(filter) {
      const key = (filter || '').toLowerCase();
      return SMA_FILTER_LOOKUP[key] || null;
    }

    function describeSmaAvailability(filter) {
      const window = getEntryFilterWindow(filter);
      if (!window) return null;
      if (!(SMA_METADATA instanceof Map) || !SMA_METADATA.size) return null;
      const meta = SMA_METADATA.get(window);
      if (!meta) return null;
      const remaining = Math.max(0, window - (meta.totalDays || 0));
      return {
        window,
        totalDays: meta.totalDays || 0,
        availableDays: meta.availableDays || 0,
        required: window,
        remaining
      };
    }

    function getGridParamsFromUI() {
      const gridSize = Number(document.getElementById('inpGridSize')?.value ?? GRID_DEFAULTS.gridSize);
      const gridOffset = Number(document.getElementById('inpGridOffset')?.value ?? 0);
      const tradeValue = Number(document.getElementById('inpTradeValue')?.value ?? GRID_DEFAULTS.tradeValue);
      const initialCash = Number(document.getElementById('inpInitialCash')?.value ?? GRID_DEFAULTS.initialCash);
      const fractionalShares = !!document.getElementById('inpFractionalShares')?.checked;
      const allowMargin = !!document.getElementById('inpAllowMargin')?.checked;
      const gridType = (document.getElementById('selGridType')?.value || 'pullback').toLowerCase();
      const gridSpacingType = (document.getElementById('selGridSpacing')?.value || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const retentionMode = (document.getElementById('selRetentionMode')?.value || 'profit').toLowerCase();
      const entryFilter = (document.getElementById('selEntryFilter')?.value || GRID_DEFAULTS.entryFilter).toLowerCase();
      return {
        gridSize: Number.isFinite(gridSize) ? gridSize : GRID_DEFAULTS.gridSize,
        gridOffset: Number.isFinite(gridOffset) ? gridOffset : 0,
        tradeValue: Number.isFinite(tradeValue) ? tradeValue : GRID_DEFAULTS.tradeValue,
        initialCash: Number.isFinite(initialCash) ? initialCash : GRID_DEFAULTS.initialCash,
        fractionalShares,
        allowMargin,
        gridType,
        gridSpacingType,
        retentionMode,
        entryFilter
      };
    }

    function renderGridSummary(summary) {
      const totalTradesEl = document.getElementById('summaryTotalTrades');
      const netProfitEl = document.getElementById('summaryNetProfit');
      const finalEquityEl = document.getElementById('summaryFinalEquity');
      const retainedEl = document.getElementById('summaryRetained');
      const cagrEl = document.getElementById('summaryCagr');
      const maxDdEl = document.getElementById('summaryMaxDD');
      const maxDdPctEl = document.getElementById('summaryMaxDDPct');
      const maxSharesEl = document.getElementById('summaryMaxShares');
      const minCashEl = document.getElementById('summaryMinCash');
      const cashEl = document.getElementById('summaryCash');
      const sharesEl = document.getElementById('summaryShares');
      if (!summary) {
        if (totalTradesEl) totalTradesEl.textContent = '0';
        if (netProfitEl) {
          netProfitEl.textContent = '$0.00';
          netProfitEl.classList.remove('text-emerald-600', 'text-red-600');
          netProfitEl.classList.add('text-slate-800');
        }
        if (finalEquityEl) finalEquityEl.textContent = '$0.00';
        if (retainedEl) retainedEl.textContent = '0';
        if (cagrEl) {
          cagrEl.textContent = '0.00%';
          cagrEl.classList.remove('text-emerald-600', 'text-red-600');
          cagrEl.classList.add('text-slate-800');
        }
        if (maxDdEl) {
          maxDdEl.textContent = '$0.00';
          maxDdEl.classList.remove('text-red-600');
          maxDdEl.classList.add('text-slate-800');
        }
        if (maxDdPctEl) {
          maxDdPctEl.textContent = '0.00%';
          maxDdPctEl.classList.remove('text-red-600');
          maxDdPctEl.classList.add('text-slate-800');
        }
        if (maxSharesEl) maxSharesEl.textContent = '0';
        if (minCashEl) minCashEl.textContent = '$0.00';
        if (cashEl) cashEl.textContent = '$0.00';
        if (sharesEl) sharesEl.textContent = '0';
        return;
      }
      if (totalTradesEl) totalTradesEl.textContent = String(summary.totalTrades ?? 0);
      if (netProfitEl) {
        const net = summary.netProfit ?? 0;
        netProfitEl.textContent = formatCurrency(net);
        netProfitEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (net > 1e-8) {
          netProfitEl.classList.add('text-emerald-600');
        } else if (net < -1e-8) {
          netProfitEl.classList.add('text-red-600');
        } else {
          netProfitEl.classList.add('text-slate-800');
        }
      }
      if (finalEquityEl) finalEquityEl.textContent = formatCurrency(summary.finalEquity ?? 0);
      if (retainedEl) retainedEl.textContent = formatNumber(summary.totalRetainedShares ?? 0, 4);
      if (cagrEl) {
        const cagr = summary.cagr ?? 0;
        const pct = cagr * 100;
        cagrEl.textContent = formatPercent(pct);
        cagrEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (cagr > 1e-6) {
          cagrEl.classList.add('text-emerald-600');
        } else if (cagr < -1e-6) {
          cagrEl.classList.add('text-red-600');
        } else {
          cagrEl.classList.add('text-slate-800');
        }
      }
      if (maxDdEl) {
        const maxDd = summary.maxDrawdown ?? 0;
        maxDdEl.textContent = formatCurrency(maxDd);
        maxDdEl.classList.remove('text-slate-800', 'text-red-600');
        if (maxDd < -1e-8) {
          maxDdEl.classList.add('text-red-600');
        } else {
          maxDdEl.classList.add('text-slate-800');
        }
      }
      if (maxDdPctEl) {
        const maxDdPct = summary.maxDrawdownPct ?? 0;
        const pctStr = `${PERCENT_FORMAT.format(maxDdPct)}%`;
        maxDdPctEl.textContent = pctStr;
        maxDdPctEl.classList.remove('text-slate-800', 'text-red-600');
        if (maxDdPct < -1e-8) {
          maxDdPctEl.classList.add('text-red-600');
        } else {
          maxDdPctEl.classList.add('text-slate-800');
        }
      }
      if (maxSharesEl) maxSharesEl.textContent = formatNumber(summary.maxSharesHeld ?? 0, 4);
      if (minCashEl) minCashEl.textContent = formatCurrency(summary.minCash ?? 0);
      if (cashEl) cashEl.textContent = formatCurrency(summary.cash ?? 0);
      if (sharesEl) sharesEl.textContent = formatNumber(summary.shares ?? 0, 4);
    }

    function getTradeSortValue(trade, key) {
      if (!trade) return 0;
      switch (key) {
        case 'buyTime':
          return trade.buyTime instanceof Date ? trade.buyTime.getTime() : new Date(trade.buyTime).getTime() || 0;
        case 'sellTime':
          return trade.sellTime instanceof Date ? trade.sellTime.getTime() : new Date(trade.sellTime).getTime() || 0;
        case 'buyPrice':
        case 'sellPrice':
        case 'buyQty':
        case 'sellQty':
        case 'qtyRetained':
        case 'cumQtyRetained':
        case 'daysHeld':
        case 'profit':
        case 'roiPct':
        case 'gridLevel':
          return Number(trade[key]) || 0;
        default:
          return 0;
      }
    }

    function sortTradesForDisplay(trades) {
      if (!Array.isArray(trades) || trades.length <= 1) return Array.isArray(trades) ? trades.slice() : [];
      const { key, dir } = TRADE_SORT_STATE;
      const direction = dir === 'desc' ? -1 : 1;
      return trades.slice().sort((a, b) => {
        const va = getTradeSortValue(a, key);
        const vb = getTradeSortValue(b, key);
        if (va === vb) return 0;
        return va > vb ? direction : -direction;
      });
    }

    function updateTradeSortIndicators() {
      const headers = document.querySelectorAll('th[data-sort-key]');
      headers.forEach((th) => {
        const key = th.getAttribute('data-sort-key');
        if (!key) return;
        if (key === TRADE_SORT_STATE.key) {
          th.setAttribute('data-sort', TRADE_SORT_STATE.dir);
        } else {
          th.setAttribute('data-sort', 'none');
        }
      });
    }

    function renderGridTrades(trades) {
      const tbody = document.getElementById('gridTradeRows');
      const emptyState = document.getElementById('gridTradesEmpty');
      const label = document.getElementById('tradeCountLabel');
      if (!tbody) return;
      tbody.innerHTML = '';
      if (!Array.isArray(trades) || !trades.length) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '0 trades';
        updateTradeSortIndicators();
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const displayTrades = sortTradesForDisplay(trades);
      const frag = document.createDocumentFragment();
      for (const trade of displayTrades) {
        const tr = document.createElement('tr');
        const rung = Number.isFinite(trade.gridLevel) ? Math.round(trade.gridLevel) : null;
        const rungLabel = rung == null ? '—' : (rung > 0 ? `+${rung}` : String(rung));
        tr.innerHTML = `
          <td class="px-3 py-2 whitespace-nowrap">${formatDateTime(trade.buyTime)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.buyPrice, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.buyQty, 4)}</td>
          <td class="px-3 py-2 text-right">${rungLabel}</td>
          <td class="px-3 py-2 whitespace-nowrap">${formatDateTime(trade.sellTime)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.sellPrice, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.sellQty, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.qtyRetained ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.cumQtyRetained ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.daysHeld ?? 0, 2)}</td>
          <td class="px-3 py-2 text-right ${trade.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(trade.profit)}</td>
          <td class="px-3 py-2 text-right ${trade.roiPct >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatPercent(trade.roiPct)}</td>
        `;
        frag.appendChild(tr);
      }
      tbody.appendChild(frag);
      if (label) label.textContent = `${trades.length} trade${trades.length === 1 ? '' : 's'}`;
      updateTradeSortIndicators();
    }

    function renderGridEquityChart(series) {
      const container = document.getElementById('gridEquityChart');
      const emptyState = document.getElementById('gridEquityEmpty');
      const label = document.getElementById('equitySummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!gridEquityChartInst) {
        gridEquityChartInst = echarts.init(container);
      }
      if (!Array.isArray(series) || !series.length) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        gridEquityChartInst.clear();
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const equityData = series.map(point => {
        const time = point.time instanceof Date ? point.time : new Date(point.time);
        return [time.getTime(), Number(point.equity) || 0];
      }).filter(item => Number.isFinite(item[0]) && Number.isFinite(item[1]));
      equityData.sort((a, b) => a[0] - b[0]);
      const cashData = series.map(point => {
        const time = point.time instanceof Date ? point.time : new Date(point.time);
        return [time.getTime(), Number(point.cash)];
      }).filter(item => Number.isFinite(item[0]) && Number.isFinite(item[1]));
      cashData.sort((a, b) => a[0] - b[0]);
      if (!equityData.length) {
        gridEquityChartInst.clear();
        if (label) label.textContent = '';
        if (emptyState) emptyState.classList.remove('hidden');
        return;
      }
      const first = equityData[0];
      const last = equityData[equityData.length - 1];
      if (label && first && last) {
        const start = new Date(first[0]);
        const end = new Date(last[0]);
        label.textContent = `${start.toISOString().slice(0, 10)} → ${end.toISOString().slice(0, 10)} (${equityData.length.toLocaleString()} points)`;
      }
      const gradient = (echarts.graphic && echarts.graphic.LinearGradient)
        ? new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: 'rgba(15, 118, 110, 0.25)' },
            { offset: 1, color: 'rgba(15, 118, 110, 0)' }
          ])
        : 'rgba(15, 118, 110, 0.1)';
      gridEquityChartInst.setOption({
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        legend: {
          data: ['Equity', 'Cash Balance'],
          textStyle: { color: '#475569' },
          selected: {
            Equity: true,
            'Cash Balance': true
          }
        },
        dataZoom: [
          {
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'filter'
          },
          {
            type: 'inside',
            yAxisIndex: 0,
            filterMode: 'weakFilter'
          }
        ],
        visualMap: undefined,
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'cross' },
          valueFormatter: (val) => formatCurrency(val)
        },
        xAxis: {
          type: 'time',
          boundaryGap: false,
          axisLabel: { color: '#64748b' }
        },
        yAxis: {
          type: 'value',
          scale: true,
          axisLabel: {
            formatter: (val) => formatCurrency(val).replace('$', ''),
            color: '#64748b'
          },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Equity',
            type: 'line',
            smooth: true,
            showSymbol: false,
            lineStyle: { color: '#0f766e', width: 2 },
            areaStyle: gradient ? { color: gradient } : undefined,
            data: equityData
          },
          {
            name: 'Cash Balance',
            type: 'line',
            smooth: true,
            showSymbol: false,
            lineStyle: { color: '#64748b', width: 1.5, type: 'dashed' },
            data: cashData
          }
        ]
      }, true);
    }

    function renderLadderChart(trades) {
      const container = document.getElementById('gridLadderChart');
      const emptyState = document.getElementById('gridLadderEmpty');
      const label = document.getElementById('ladderSummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!gridLadderChartInst) {
        gridLadderChartInst = echarts.init(container);
      }
      if (!Array.isArray(trades) || !trades.length) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        gridLadderChartInst.clear();
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const buyPoints = [];
      const sellPoints = [];
      trades.forEach((trade) => {
        if (trade?.buyTime) {
          const time = trade.buyTime instanceof Date ? trade.buyTime : new Date(trade.buyTime);
          if (time instanceof Date && !isNaN(time)) {
            buyPoints.push([
              time.getTime(),
              Number(trade.buyPrice) || 0,
              Number(trade.buyQty) || 0
            ]);
          }
        }
        if (trade?.sellTime) {
          const time = trade.sellTime instanceof Date ? trade.sellTime : new Date(trade.sellTime);
          if (time instanceof Date && !isNaN(time)) {
            sellPoints.push([
              time.getTime(),
              Number(trade.sellPrice) || 0,
              Number(trade.sellQty) || 0
            ]);
          }
        }
      });
      buyPoints.sort((a, b) => a[0] - b[0]);
      sellPoints.sort((a, b) => a[0] - b[0]);
      if (!buyPoints.length && !sellPoints.length) {
        gridLadderChartInst.clear();
        if (label) label.textContent = '';
        if (emptyState) emptyState.classList.remove('hidden');
        return;
      }
      if (label) {
        const totalPoints = buyPoints.length + sellPoints.length;
        label.textContent = `${totalPoints.toLocaleString()} fills (${buyPoints.length.toLocaleString()} buys · ${sellPoints.length.toLocaleString()} sells)`;
      }
      const formatter = (params) => {
        if (!params || !params.value) return '';
        const [ts, price, qty] = params.value;
        const date = new Date(ts);
        const timeStr = Number.isFinite(ts) ? formatDateTime(date) : '';
        return `
          <div class="text-xs">
            <div class="font-semibold">${params.seriesName}</div>
            <div>${timeStr}</div>
            <div>Price: ${formatNumber(price, 4)}</div>
            <div>Qty: ${formatNumber(qty, 4)}</div>
          </div>
        `;
      };
      gridLadderChartInst.setOption({
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        legend: {
          data: ['Buy fills', 'Sell fills'],
          textStyle: { color: '#475569' }
        },
        tooltip: {
          trigger: 'item',
          formatter
        },
        dataZoom: [
          {
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'filter'
          },
          {
            type: 'inside',
            yAxisIndex: 0,
            filterMode: 'weakFilter'
          }
        ],
        xAxis: {
          type: 'time',
          axisLabel: { color: '#64748b' }
        },
        yAxis: {
          type: 'value',
          scale: true,
          axisLabel: {
            formatter: (val) => formatNumber(val, 4),
            color: '#64748b'
          },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Buy fills',
            type: 'scatter',
            symbolSize: 4,
            itemStyle: { color: '#0f766e' },
            data: buyPoints
          },
          {
            name: 'Sell fills',
            type: 'scatter',
            symbolSize: 4,
            itemStyle: { color: '#dc2626' },
            data: sellPoints
          }
        ]
      }, true);
    }

    function highlightTickerButton(symbol) {
      const seg = document.getElementById('tickerSegment');
      if (!seg) return;
      const upper = (symbol || '').toUpperCase();
      seg.querySelectorAll('button[data-symbol]').forEach(btn => {
        const active = (btn.getAttribute('data-symbol') || '').toUpperCase() === upper;
        btn.classList.toggle('bg-emerald-600', active);
        btn.classList.toggle('text-white', active);
        btn.classList.toggle('hover:bg-emerald-600', active);
        btn.classList.toggle('bg-white', !active);
        btn.classList.toggle('hover:bg-emerald-50', !active);
        const nameSpan = btn.querySelector('[data-symbol-name]');
        if (nameSpan) {
          nameSpan.classList.toggle('text-emerald-100', active);
          nameSpan.classList.toggle('text-slate-500', !active);
        }
      });
    }

    function renderDataSummary() {
      const summaryEl = document.getElementById('dataSummary');
      if (!summaryEl) return;
      if (!currentTicker) {
        summaryEl.textContent = 'Select a symbol to load intraday data.';
        return;
      }
      if (!ROWS.length) {
        summaryEl.innerHTML = `<span class="font-semibold">${currentTicker}</span> selected. Choose another symbol or verify data files exist in the <code>data/</code> folder.`;
        return;
      }
      const firstDay = DAYS[0];
      const lastDay = DAYS[DAYS.length - 1];
      summaryEl.innerHTML = `
        <span class="font-semibold">${currentTicker}</span> loaded
        <span class="font-medium">${ROWS.length.toLocaleString()}</span> bars across
        <span class="font-medium">${DAYS.length.toLocaleString()}</span> trading day(s)
        (${firstDay || 'n/a'} → ${lastDay || 'n/a'}).
      `;
    }

    function setTicker(sym) {
      currentTicker = (sym || '').toUpperCase();
      const titleEl = document.getElementById('mainTitle');
      const meta = ensureSymbolMetaEntry(currentTicker);
      const friendlyName = meta && meta.name && meta.name.toUpperCase() !== currentTicker ? ` · ${meta.name}` : '';
      const fullTitle = currentTicker ? `${currentTicker}${friendlyName} - Buy-the-Dip Grid Backtest` : 'Buy-the-Dip Grid Backtest';
      if (titleEl) titleEl.textContent = fullTitle;
      document.title = fullTitle;
      highlightTickerButton(currentTicker);
      const loadingMsg = currentTicker ? `Loading data for ${currentTicker}…` : 'Load data and run the backtest to populate results.';
      resetGridOutputs(loadingMsg);
      setRunButtonEnabled(false);
      renderDataSummary();
    }

    function resetGridOutputs(message) {
      GRID_STATE = { trades: [], summary: null, equitySeries: [], ladderSnapshot: [] };
      renderGridSummary(null);
      renderGridTrades([]);
      setGridStatus(message || 'Load data and run the backtest to populate results.');
      renderGridEquityChart(null);
      renderLadderChart([]);
    }

    function normalizeAndIndex(rows) {
      if (!rows || !rows.length) {
        ROWS = [];
        DAY_GROUPS = new Map();
        DAYS = [];
        return;
      }
      const required = ['caldt', 'day', 'open', 'high', 'low', 'close'];
      const missing = required.filter(c => !(c in rows[0]));
      if (missing.length) throw new Error('Missing columns: ' + missing.join(', '));

      const cleanRows = rows.map(r => {
        const caldt = new Date(r.caldt);
        const dayKey = dateKeyFromStr(r.day);
        const open = Number(r.open), high = Number(r.high), low = Number(r.low), close = Number(r.close);
        if (!dayKey || isNaN(caldt)) return null;
        if ([open, high, low, close].some(v => !Number.isFinite(v))) return null;
        return { caldt, dayKey, open, high, low, close, sma10: null, sma20: null, sma50: null, sma100: null };
      }).filter(Boolean);
      cleanRows.sort((a, b) => a.caldt - b.caldt);

      ROWS = resampleIntradayRows(cleanRows, RESAMPLE_INTERVAL_MINUTES);

      DAY_GROUPS = new Map();
      for (const row of ROWS) {
        if (!DAY_GROUPS.has(row.dayKey)) DAY_GROUPS.set(row.dayKey, []);
        DAY_GROUPS.get(row.dayKey).push(row);
      }
      for (const [key, arr] of DAY_GROUPS.entries()) arr.sort((a, b) => a.caldt - b.caldt);
      DAYS = Array.from(DAY_GROUPS.keys()).sort();
      computeDailySmaMaps();
    }

    function resampleIntradayRows(rows, minutes) {
      if (!Array.isArray(rows) || !rows.length) return [];
      const interval = Number(minutes);
      if (!Number.isFinite(interval) || interval <= 1) {
        return [...rows];
      }
      const intervalMs = Math.max(1, Math.floor(interval)) * 60000;
      const aggregated = [];
      let current = null;

      const flush = () => {
        if (!current) return;
        const caldt = current.lastTimeMs != null ? new Date(current.lastTimeMs) : new Date(current.bucketStartMs);
        aggregated.push({
          caldt,
          dayKey: current.dayKey,
          open: current.open,
          high: current.high,
          low: current.low,
          close: current.close,
          sma10: null,
          sma20: null,
          sma50: null,
          sma100: null
        });
        current = null;
      };

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const timeMs = row.caldt.getTime();
        const bucketStartMs = Math.floor(timeMs / intervalMs) * intervalMs;
        if (!current || current.dayKey !== row.dayKey || current.bucketStartMs !== bucketStartMs) {
          flush();
          current = {
            dayKey: row.dayKey,
            bucketStartMs,
            open: row.open,
            high: row.high,
            low: row.low,
            close: row.close,
            lastTimeMs: timeMs
          };
          continue;
        }
        if (row.high > current.high) current.high = row.high;
        if (row.low < current.low) current.low = row.low;
        current.close = row.close;
        current.lastTimeMs = timeMs;
      }
      flush();
      aggregated.sort((a, b) => a.caldt - b.caldt);
      return aggregated;
    }

    function computeDailySmaMaps() {
      DAY_SMA_MAPS = new Map();
      SMA_METADATA = new Map();
      if (!Array.isArray(DAYS) || !DAYS.length) return;
      const windows = Array.isArray(DAILY_SMA_WINDOWS) && DAILY_SMA_WINDOWS.length ? DAILY_SMA_WINDOWS : [];
      if (!windows.length) return;
      windows.forEach(win => DAY_SMA_MAPS.set(win, new Map()));
      const dailyCloses = [];
      for (const dayKey of DAYS) {
        const rows = DAY_GROUPS.get(dayKey);
        if (!Array.isArray(rows) || !rows.length) continue;
        const lastRow = rows[rows.length - 1];
        if (!lastRow) continue;
        const close = Number(lastRow.close);
        if (!Number.isFinite(close)) continue;
        dailyCloses.push({ dayKey, close });
      }
      for (const window of windows) {
        const target = DAY_SMA_MAPS.get(window);
        if (!target) continue;
        let firstIdx = null;
        for (let i = 0; i < dailyCloses.length; i++) {
          if (i + 1 < window) continue;
          let sum = 0;
          for (let j = i - window + 1; j <= i; j++) {
            sum += dailyCloses[j].close;
          }
          const avg = sum / window;
          target.set(dailyCloses[i].dayKey, avg);
          if (firstIdx == null) firstIdx = i;
        }
        const totalDays = dailyCloses.length;
        const availableDays = firstIdx == null ? 0 : (totalDays - firstIdx);
        SMA_METADATA.set(window, {
          totalDays,
          availableDays,
          firstDay: firstIdx != null ? dailyCloses[firstIdx].dayKey : null,
          required: window
        });
      }
      for (const row of ROWS) {
        if (!row) continue;
        const dayKey = row.dayKey;
        for (const prop of SMA_PROPERTIES) {
          row[prop] = null;
        }
        for (const window of windows) {
          const map = DAY_SMA_MAPS.get(window);
          if (!map) continue;
          const value = map.get(dayKey);
          const prop = SMA_PROPERTY_BY_WINDOW[window];
          if (prop) row[prop] = Number.isFinite(value) ? value : null;
        }
      }
    }

    function collectOrdersInRange(map, minVal, maxVal, ascending) {
      const out = [];
      if (!map || !map.size) return out;
      const lower = Math.min(minVal, maxVal);
      const upper = Math.max(minVal, maxVal);
      for (const arr of map.values()) {
        if (!Array.isArray(arr) || !arr.length) continue;
        for (const order of arr) {
          if (!order || !Number.isFinite(order.level)) continue;
          const tolerance = 1e-9 * Math.max(1, Math.abs(order.level), Math.abs(lower), Math.abs(upper));
          if (order.level >= (lower - tolerance) && order.level <= (upper + tolerance)) {
            out.push(order);
          }
        }
      }
      out.sort((a, b) => ascending ? (a.level - b.level) : (b.level - a.level));
      return out;
    }

    function runPullbackGridSimulation(rows, params) {
      const trades = [];
      const equitySeries = [];
      const ladderHistory = [];
      const mode = (params?.gridType || 'pullback').toLowerCase();
      if (mode === 'progressive') {
        return runProgressiveGrid(rows, params);
      }

      const summary = {
        totalTrades: 0,
        netProfit: 0,
        finalEquity: 0,
        totalRetainedShares: 0,
        cash: Number(params?.initialCash) || 0,
        minCash: Number(params?.initialCash) || 0,
        shares: 0,
        maxDrawdown: 0,
        maxSharesHeld: 0,
        cagr: 0
      };
      if (!Array.isArray(rows) || !rows.length) {
        return { trades, summary, equitySeries, ladderHistory };
      }
      const rawGridSize = Number(params?.gridSize);
      const gridOffset = Number(params?.gridOffset) || 0;
      const gridSpacingType = (params?.gridSpacingType || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const tradeValue = Number(params?.tradeValue);
      const initialCash = Number(params?.initialCash);
      const fractional = !!params?.fractionalShares;
      const allowMargin = !!params?.allowMargin;
      const retentionMode = (params?.retentionMode || 'profit').toLowerCase();
      const entryFilter = (params?.entryFilter || 'none').toLowerCase();
      if (!Number.isFinite(rawGridSize) || rawGridSize <= 0 || !Number.isFinite(tradeValue) || tradeValue <= 0) {
        return { trades, summary, equitySeries, ladderHistory };
      }
      let firstPrice = [rows[0]?.open, rows[0]?.close, rows[0]?.high, rows[0]?.low].map(Number).find(Number.isFinite);
      if (!Number.isFinite(firstPrice) || firstPrice <= 0) {
        return { trades, summary, equitySeries, ladderHistory };
      }
      let minPrice = firstPrice;
      let maxPrice = firstPrice;
      for (const row of rows) {
        if (!row) continue;
        const low = Number(row.low);
        const high = Number(row.high);
        if (Number.isFinite(low)) minPrice = Math.min(minPrice, low);
        if (Number.isFinite(high)) maxPrice = Math.max(maxPrice, high);
      }
      if (!Number.isFinite(minPrice) || !Number.isFinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) {
        return { trades, summary, equitySeries, ladderHistory };
      }

      const spacing = createGridSpacingHelpers({
        spacingType: gridSpacingType,
        gridSize: rawGridSize,
        gridOffset,
        firstPrice
      });
      if (spacing.error) {
        console.warn('Grid spacing configuration invalid:', spacing.error);
        return { trades, summary, equitySeries, ladderHistory };
      }
      const snapLevel = spacing.snap;
      const keyFor = spacing.key;
      const nextUpLevel = spacing.nextUp;
      const nextDownLevel = spacing.nextDown;
      const stepsBetween = spacing.stepsBetween;
      const priceTolerance = spacing.priceTolerance ?? 1e-9;
      const usePercentSpacing = spacing.type === 'percent';
      const baseLevel = snapLevel(firstPrice);
      const computeRungIndex = (level) => {
        if (!Number.isFinite(level) || !Number.isFinite(baseLevel)) return 0;
        const diff = stepsBetween(baseLevel, level);
        if (!Number.isFinite(diff)) return 0;
        return Math.round(diff);
      };

      const activeBuys = new Map();
      const activeSells = new Map();
      const queuedBuyActivations = [];
      let orderSeq = 1;
      let highestSeededBuyLevel = Number.NEGATIVE_INFINITY;

      const removeOrder = (map, order) => {
        if (!order || !Number.isFinite(order.level)) return;
        const key = keyFor(order.level);
        const arr = map.get(key);
        if (!arr) return;
        const idx = arr.indexOf(order);
        if (idx >= 0) arr.splice(idx, 1);
        if (!arr.length) map.delete(key);
      };

      const addBuyOrder = (level) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price) || price <= 0) return null;
        const key = keyFor(price);
        const existing = activeBuys.get(key);
        if (existing && existing.length) return existing[0];
        const order = { id: orderSeq++, level: price, rungIndex: computeRungIndex(price) };
        activeBuys.set(key, [order]);
        if (!Number.isFinite(highestSeededBuyLevel) || price > highestSeededBuyLevel) {
          highestSeededBuyLevel = price;
        }
        return order;
      };

      const addSellOrder = (level, buyInfo) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price) || price <= 0) return null;
        const key = keyFor(price);
        if (!activeSells.has(key)) activeSells.set(key, []);
        const order = {
          id: orderSeq++,
          level: price,
          buyPrice: Number(buyInfo?.price),
          buyQty: Number(buyInfo?.qty),
          buyTime: buyInfo?.time instanceof Date ? new Date(buyInfo.time.getTime()) : new Date(),
          buyRung: Number.isFinite(buyInfo?.rungIndex) ? buyInfo.rungIndex : computeRungIndex(price)
        };
        activeSells.get(key).push(order);
        return order;
      };

      if (!usePercentSpacing) {
        const gridMin = spacing.floor(minPrice);
        const gridMax = spacing.ceil(maxPrice);
        if (Number.isFinite(gridMin) && Number.isFinite(gridMax)) {
          for (let level = gridMin; Number.isFinite(level) && level <= gridMax + priceTolerance * Math.max(1, level); ) {
            if (level < firstPrice - priceTolerance * Math.max(1, level)) {
              addBuyOrder(level);
            }
            const nextLevel = nextUpLevel(level);
            if (!Number.isFinite(nextLevel) || Math.abs(nextLevel - level) <= priceTolerance * Math.max(1, nextLevel)) break;
            level = nextLevel;
          }
        }
      } else {
        let level = nextDownLevel(snapLevel(firstPrice));
        let safety = 0;
        while (Number.isFinite(level) && level > 0 && level >= minPrice - priceTolerance * Math.max(1, level) && safety < 2000) {
          addBuyOrder(level);
          const nextLevel = nextDownLevel(level);
          if (!Number.isFinite(nextLevel) || Math.abs(nextLevel - level) <= priceTolerance * Math.max(1, level)) break;
          level = nextLevel;
          safety += 1;
        }
      }
      if (!Number.isFinite(highestSeededBuyLevel) || highestSeededBuyLevel === Number.NEGATIVE_INFINITY) {
        const seedLevel = nextDownLevel(firstPrice);
        if (Number.isFinite(seedLevel) && seedLevel > 0) {
          const order = addBuyOrder(seedLevel);
          if (order) highestSeededBuyLevel = order.level;
        }
      }

      let cash = Number.isFinite(initialCash) ? initialCash : GRID_DEFAULTS.initialCash;
      let minCashBalance = cash;
      const initialEquity = cash;
      const firstEquityTime = rows[0]?.caldt instanceof Date ? new Date(rows[0].caldt.getTime()) : null;
      let lastEquityTime = firstEquityTime;
      let shares = 0;
      let realizedProfit = 0;
      let cumulativeRetained = 0;
      let prevPrice = firstPrice;
      const EPS = 1e-9;
      let peakEquity = cash + shares * firstPrice;
      let maxDrawdown = 0;
      let maxDrawdownPct = 0;
      let maxSharesHeld = shares;

      const hasActiveBuy = (level) => {
        const price = snapLevel(level);
        const key = keyFor(price);
        const arr = activeBuys.get(key);
        return Array.isArray(arr) && arr.length > 0;
      };

      const hasQueuedBuyActivation = (level) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price)) return false;
        return queuedBuyActivations.some(entry => {
          const diff = Math.abs(entry.buyLevel - price);
          return diff <= priceTolerance * Math.max(1, entry.buyLevel);
        });
      };

      const queueDelayedBuy = (sellPrice) => {
        const buyPrice = snapLevel(sellPrice);
        if (!Number.isFinite(buyPrice) || buyPrice <= 0) return;
        if (hasActiveBuy(buyPrice) || hasQueuedBuyActivation(buyPrice)) return;
        const triggerLevel = nextUpLevel(buyPrice);
        if (!Number.isFinite(triggerLevel) || triggerLevel <= 0) return;
        if (Math.abs(triggerLevel - buyPrice) <= priceTolerance * Math.max(1, triggerLevel)) return;
        queuedBuyActivations.push({ buyLevel: buyPrice, trigger: triggerLevel });
      };

      const ensureRunupBuys = (maxPrice) => {
        if (!Number.isFinite(maxPrice)) return;
        if (!Number.isFinite(highestSeededBuyLevel)) return;
        let safety = 0;
        while (stepsBetween(highestSeededBuyLevel, Math.max(maxPrice, highestSeededBuyLevel)) >= 2 - 1e-9 && safety < 1000) {
          const nextLevel = nextUpLevel(highestSeededBuyLevel);
          if (!Number.isFinite(nextLevel) || nextLevel <= 0) break;
          if (!hasActiveBuy(nextLevel) && !hasQueuedBuyActivation(nextLevel)) {
            addBuyOrder(nextLevel);
          }
          if (Math.abs(nextLevel - highestSeededBuyLevel) <= priceTolerance * Math.max(1, nextLevel)) break;
          highestSeededBuyLevel = nextLevel;
          safety += 1;
        }
      };

      const activateQueuedBuys = (maxPrice) => {
        if (!Number.isFinite(maxPrice) || !queuedBuyActivations.length) return;
        for (let i = queuedBuyActivations.length - 1; i >= 0; i--) {
          const entry = queuedBuyActivations[i];
          if (!entry) continue;
          const tolerance = priceTolerance * Math.max(1, entry.trigger);
          if (maxPrice >= entry.trigger - tolerance) {
            addBuyOrder(entry.buyLevel);
            queuedBuyActivations.splice(i, 1);
          }
        }
      };

      const executeBuy = (order, timestamp, contextRow) => {
        if (!order) return false;
        const price = order.level;
        if (!passesEntryFilter(price, contextRow, entryFilter)) {
          return false;
        }
        const qtyRaw = tradeValue / price;
        let qty = fractional ? qtyRaw : Math.floor(qtyRaw);
        if (!Number.isFinite(qty) || qty <= 0) {
          removeOrder(activeBuys, order);
          return false;
        }
        if (!allowMargin) {
          const affordable = fractional ? (cash / price) : Math.floor(cash / price);
          qty = Math.min(qty, affordable);
          if (!Number.isFinite(qty) || qty <= 0) {
            removeOrder(activeBuys, order);
            return false;
          }
        }
        const cost = qty * price;
        if (!allowMargin && cost > cash + EPS) {
          return false;
        }
        cash -= cost;
        if (cash < minCashBalance) minCashBalance = cash;
        shares += qty;
        if (shares > maxSharesHeld) maxSharesHeld = shares;
        removeOrder(activeBuys, order);
        const sellLevel = nextUpLevel(price);
        if (Number.isFinite(sellLevel) && sellLevel > 0) {
          addSellOrder(sellLevel, { price, qty, time: timestamp, rungIndex: Number.isFinite(order?.rungIndex) ? order.rungIndex : computeRungIndex(price) });
        }
        return true;
      };

      const executeSell = (order, timestamp) => {
        if (!order) return false;
        const price = order.level;
        const desiredRaw = tradeValue / price;
        let desired = fractional ? desiredRaw : Math.floor(desiredRaw);
        const exec = computeSellExecution({
          baseQty: order.buyQty,
          desiredQty: desired,
          sharesAvailable: shares,
          mode: retentionMode,
          fractional
        });
        let qty = exec.qty;
        if (!Number.isFinite(qty) || qty <= 0) {
          removeOrder(activeSells, order);
          return false;
        }
        const revenue = qty * price;
        const costBasis = qty * order.buyPrice;
        cash += revenue;
        shares -= qty;
        removeOrder(activeSells, order);
        const profit = revenue - costBasis;
        realizedProfit += profit;
        const qtyRetained = Math.max(0, exec.retained);
        cumulativeRetained += qtyRetained;
        const sellTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const buyTime = order.buyTime instanceof Date ? new Date(order.buyTime.getTime()) : new Date();
        const msHeld = sellTime.getTime() - buyTime.getTime();
        const daysHeld = Number.isFinite(msHeld) ? Math.max(0, msHeld / 86400000) : 0;
        trades.push({
          buyTime,
          buyPrice: order.buyPrice,
          buyQty: order.buyQty,
          gridLevel: Number.isFinite(order.buyRung) ? order.buyRung : computeRungIndex(order.buyPrice),
          sellTime,
          sellPrice: price,
          sellQty: qty,
          qtyRetained,
          cumQtyRetained: cumulativeRetained,
          daysHeld,
          profit,
          roiPct: costBasis > 0 ? (profit / costBasis) * 100 : 0
        });
        const buyLevel = nextDownLevel(price);
        if (Number.isFinite(buyLevel) && buyLevel > 0) {
          addBuyOrder(buyLevel);
        }
        queueDelayedBuy(price);
        return true;
      };

      const processMove = (start, end, timestamp, contextRow) => {
        if (!Number.isFinite(start) || !Number.isFinite(end)) return;
        const scale = Math.max(1, Math.abs(start), Math.abs(end));
        const threshold = priceTolerance * scale;
        if (end > start + threshold) {
          const sells = collectOrdersInRange(activeSells, start, end, true);
          for (const order of sells) executeSell(order, timestamp);
        } else if (end < start - threshold) {
          const buys = collectOrdersInRange(activeBuys, end, start, false);
          for (const order of buys) executeBuy(order, timestamp, contextRow);
        }
        const maxVal = Math.max(start, end);
        ensureRunupBuys(maxVal);
        activateQueuedBuys(maxVal);
        if (timestamp instanceof Date) {
          ladderHistory.push({
            time: new Date(timestamp.getTime()),
            buys: activeBuys.size,
            sells: activeSells.size,
            queued: queuedBuyActivations.length
          });
        }
      };

      const buildPath = (fromPrice, row) => {
        const path = [];
        let start = Number(fromPrice);
        if (!Number.isFinite(start)) start = Number(row.open) || Number(row.close) || 0;
        path.push(start);
        const addPoint = (value) => {
          const num = Number(value);
          if (!Number.isFinite(num)) return;
          if (Math.abs(num - path[path.length - 1]) < priceTolerance * Math.max(1, num)) return;
          path.push(num);
        };
        const open = Number(row.open);
        const high = Number(row.high);
        const low = Number(row.low);
        const close = Number(row.close);
        if (Number.isFinite(open)) addPoint(open);
        const upBar = Number.isFinite(close) && Number.isFinite(open) ? (close >= open) : true;
        if (upBar) {
          if (Number.isFinite(high)) addPoint(high);
          if (Number.isFinite(low)) addPoint(low);
        } else {
          if (Number.isFinite(low)) addPoint(low);
          if (Number.isFinite(high)) addPoint(high);
        }
        if (Number.isFinite(close)) addPoint(close);
        return path;
      };

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const path = buildPath(prevPrice, row);
        for (let i = 1; i < path.length; i++) {
          const from = path[i - 1];
          const to = path[i];
          processMove(from, to, row.caldt, row);
        }
        prevPrice = path[path.length - 1];
        const equity = cash + shares * prevPrice;
        const openBuyOrders = Array.from(activeBuys.values()).reduce((acc, arr) => acc + (Array.isArray(arr) ? arr.length : 0), 0);
        if (equity > peakEquity) peakEquity = equity;
        const drawdown = equity - peakEquity;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
        const equityPct = peakEquity > 0 ? (equity - peakEquity) / peakEquity : 0;
        if (equityPct < maxDrawdownPct) maxDrawdownPct = equityPct;
        lastEquityTime = new Date(row.caldt.getTime());
        equitySeries.push({
          time: new Date(row.caldt.getTime()),
          equity,
          cash: cash,
          cashDeployed: openBuyOrders * tradeValue,
          initialCash
        });
      }

      const finalEquity = cash + shares * prevPrice;
      const millis = firstEquityTime && lastEquityTime ? (lastEquityTime.getTime() - firstEquityTime.getTime()) : 0;
      const years = millis > 0 ? (millis / (365.25 * 24 * 60 * 60 * 1000)) : 0;
      const cagr = (years > 0 && initialEquity > 0 && finalEquity > 0)
        ? Math.pow(finalEquity / initialEquity, 1 / years) - 1
        : 0;
      summary.totalTrades = trades.length;
      summary.netProfit = realizedProfit;
      summary.finalEquity = finalEquity;
      summary.totalRetainedShares = shares;
      summary.cash = cash;
      summary.minCash = minCashBalance;
      summary.shares = shares;
      summary.maxDrawdown = maxDrawdown;
      summary.maxDrawdownPct = maxDrawdownPct * 100;
      summary.maxSharesHeld = maxSharesHeld;
      summary.cagr = cagr;
      return { trades, summary, equitySeries, ladderHistory };
    }

    function runProgressiveGrid(rows, params) {
      const trades = [];
      const equitySeries = [];
      const ladderHistory = [];
      const summary = {
        totalTrades: 0,
        netProfit: 0,
        finalEquity: 0,
        totalRetainedShares: 0,
        cash: Number(params?.initialCash) || 0,
        minCash: Number(params?.initialCash) || 0,
        shares: 0,
        maxDrawdown: 0,
        maxSharesHeld: 0,
        cagr: 0
      };
      if (!Array.isArray(rows) || !rows.length) {
        return { trades, summary, equitySeries, ladderHistory };
      }
      const rawGridSize = Number(params?.gridSize);
      const gridOffset = Number(params?.gridOffset) || 0;
      const gridSpacingType = (params?.gridSpacingType || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const tradeValue = Number(params?.tradeValue);
      const initialCash = Number(params?.initialCash);
      const fractional = !!params?.fractionalShares;
      const allowMargin = !!params?.allowMargin;
      const retentionMode = (params?.retentionMode || 'profit').toLowerCase();
      const entryFilter = (params?.entryFilter || 'none').toLowerCase();
      if (!Number.isFinite(rawGridSize) || rawGridSize <= 0 || !Number.isFinite(tradeValue) || tradeValue <= 0) {
        return { trades, summary, equitySeries, ladderHistory };
      }
      let firstPrice = [rows[0]?.open, rows[0]?.close, rows[0]?.high, rows[0]?.low].map(Number).find(Number.isFinite);
      if (!Number.isFinite(firstPrice) || firstPrice <= 0) {
        return { trades, summary, equitySeries, ladderHistory };
      }

      let minPrice = firstPrice;
      let maxPrice = firstPrice;
      for (const row of rows) {
        if (!row) continue;
        const low = Number(row.low);
        const high = Number(row.high);
        if (Number.isFinite(low)) minPrice = Math.min(minPrice, low);
        if (Number.isFinite(high)) maxPrice = Math.max(maxPrice, high);
      }
      if (!Number.isFinite(minPrice) || !Number.isFinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) {
        return { trades, summary, equitySeries, ladderHistory };
      }

      const spacing = createGridSpacingHelpers({
        spacingType: gridSpacingType,
        gridSize: rawGridSize,
        gridOffset,
        firstPrice
      });
      if (spacing.error) {
        console.warn('Grid spacing configuration invalid:', spacing.error);
        return { trades, summary, equitySeries, ladderHistory };
      }
      const snapLevel = spacing.snap;
      const keyFor = spacing.key;
      const nextUpLevel = spacing.nextUp;
      const nextDownLevel = spacing.nextDown;
      const stepsBetween = spacing.stepsBetween;
      const priceTolerance = spacing.priceTolerance ?? 1e-9;
      const usePercentSpacing = spacing.type === 'percent';
      const EPS = 1e-9;
      const baseLevel = snapLevel(firstPrice);
      const computeRungIndex = (level) => {
        if (!Number.isFinite(level) || !Number.isFinite(baseLevel)) return 0;
        const diff = stepsBetween(baseLevel, level);
        if (!Number.isFinite(diff)) return 0;
        return Math.round(diff);
      };

      const minGridLevel = spacing.floor(minPrice);

      let cash = Number.isFinite(initialCash) ? initialCash : GRID_DEFAULTS.initialCash;
      let minCashBalance = cash;
      const initialEquity = cash;
      const firstEquityTime = rows[0]?.caldt instanceof Date ? new Date(rows[0].caldt.getTime()) : null;
      let lastEquityTime = firstEquityTime;
      let shares = 0;
      let realizedProfit = 0;
      let cumulativeRetained = 0;
      let prevPrice = firstPrice;
      let peakEquity = cash + shares * firstPrice;
      let maxDrawdown = 0;
      let maxDrawdownPct = 0;
      let maxSharesHeld = shares;

      const pendingBuys = new Map(); // key -> { key, level, groupId, direction }
      const pendingSells = new Set(); // entries with level, qty, buyPrice, buyTime
      let sellSeq = 1;
      let buyGroupSeq = 1;

      const queueBuy = (price, groupId = 0, direction = 'neutral') => {
        const level = snapLevel(price);
        if (!Number.isFinite(level) || level <= 0) return null;
        const key = keyFor(level);
        if (pendingBuys.has(key)) {
          const existing = pendingBuys.get(key);
          if (groupId > 0) existing.groupId = groupId;
          if (direction) existing.direction = direction;
          return existing;
        }
        const entry = { key, level, groupId: groupId > 0 ? groupId : 0, direction, rungIndex: computeRungIndex(level) };
        pendingBuys.set(key, entry);
        return entry;
      };

      const queueSell = (price, qty, buyPrice, buyTime, rungIndex) => {
        const level = snapLevel(price);
        if (!Number.isFinite(level) || level <= 0) return null;
        const entry = {
          id: sellSeq++,
          level,
          qty,
          buyPrice,
          buyTime: buyTime instanceof Date ? new Date(buyTime.getTime()) : new Date(),
          buyRung: Number.isFinite(rungIndex) ? rungIndex : computeRungIndex(buyPrice)
        };
        pendingSells.add(entry);
        return entry;
      };

      const ensureDownCoverage = (fromLevel) => {
        let level = snapLevel(fromLevel);
        if (!Number.isFinite(level)) return;
        let safety = 0;
        while (Number.isFinite(level) && level >= minGridLevel - priceTolerance * Math.max(1, level) && safety < 2000) {
          queueBuy(level, 0, 'down');
          const nextLevel = nextDownLevel(level);
          if (!Number.isFinite(nextLevel) || Math.abs(nextLevel - level) <= priceTolerance * Math.max(1, level)) break;
          level = nextLevel;
          safety += 1;
        }
      };

      const executeBuy = (entry, timestamp, contextRow) => {
        if (!entry) return false;
        const price = entry.level;
        if (!passesEntryFilter(price, contextRow, entryFilter)) {
          return false;
        }
        const qtyRaw = tradeValue / price;
        let qty = fractional ? qtyRaw : Math.floor(qtyRaw);
        if (!Number.isFinite(qty) || qty <= 0) return false;
        if (!allowMargin) {
          const affordable = fractional ? (cash / price) : Math.floor(cash / price);
          qty = Math.min(qty, affordable);
          if (!Number.isFinite(qty) || qty <= 0) return false;
        }
        const cost = qty * price;
        if (!allowMargin && cost > cash + EPS) return false;
        pendingBuys.delete(entry.key);
        if (entry.groupId > 0 && entry.direction === 'down') {
          const keysToRemove = [];
          for (const [otherKey, otherEntry] of pendingBuys.entries()) {
            if (otherEntry.groupId === entry.groupId) keysToRemove.push(otherKey);
          }
          for (const key of keysToRemove) pendingBuys.delete(key);
        }
        cash -= cost;
        if (cash < minCashBalance) minCashBalance = cash;
        shares += qty;
        if (shares > maxSharesHeld) maxSharesHeld = shares;
        const buyTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const sellLevel = nextUpLevel(price);
        if (Number.isFinite(sellLevel) && sellLevel > 0) {
          queueSell(sellLevel, qty, price, buyTime, Number.isFinite(entry?.rungIndex) ? entry.rungIndex : computeRungIndex(price));
        }
        if (entry.direction === 'down') {
          const downLevel = nextDownLevel(price);
          if (Number.isFinite(downLevel) && downLevel > 0) {
            queueBuy(downLevel, buyGroupSeq++, 'down');
          }
        } else if (entry.direction === 'up') {
          const desired = nextDownLevel(price);
          if (Number.isFinite(desired) && desired > 0) {
            const key = keyFor(desired);
            if (!pendingBuys.has(key)) {
              queueBuy(desired, buyGroupSeq++, 'down');
            }
          }
        }
        const coverageOrigin = nextDownLevel(price);
        if (Number.isFinite(coverageOrigin)) {
          ensureDownCoverage(coverageOrigin);
        }
        return true;
      };

      const executeSell = (entry, timestamp) => {
        if (!entry) return false;
        pendingSells.delete(entry);
        const price = entry.level;
        const desiredRaw = tradeValue / price;
        let desired = fractional ? desiredRaw : Math.floor(desiredRaw);
        const execution = computeSellExecution({
          baseQty: entry.qty,
          desiredQty: desired,
          sharesAvailable: shares,
          mode: retentionMode,
          fractional
        });
        let qty = execution.qty;
        if (qty <= 0) return false;
        const revenue = qty * price;
        const costBasis = qty * entry.buyPrice;
        cash += revenue;
        shares -= qty;
        const profit = revenue - costBasis;
        realizedProfit += profit;
        const qtyRetained = execution.retained;
        cumulativeRetained += qtyRetained;
        const sellTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const buyTime = entry.buyTime instanceof Date ? new Date(entry.buyTime.getTime()) : new Date();
        const msHeld = sellTime.getTime() - buyTime.getTime();
        const daysHeld = Number.isFinite(msHeld) ? Math.max(0, msHeld / 86400000) : 0;
        trades.push({
          buyTime,
          buyPrice: entry.buyPrice,
          buyQty: entry.qty,
          gridLevel: Number.isFinite(entry.buyRung) ? entry.buyRung : computeRungIndex(entry.buyPrice),
          sellTime,
          sellPrice: price,
          sellQty: qty,
          qtyRetained,
          cumQtyRetained: cumulativeRetained,
          daysHeld,
          profit,
          roiPct: costBasis > 0 ? (profit / costBasis) * 100 : 0
        });
        const groupId = buyGroupSeq++;
        const upLevel = nextUpLevel(price);
        if (Number.isFinite(upLevel) && upLevel > 0) queueBuy(upLevel, groupId, 'up');
        const downLevel = nextDownLevel(price);
        if (Number.isFinite(downLevel) && downLevel > 0) queueBuy(downLevel, groupId, 'down');
        if (Number.isFinite(downLevel)) ensureDownCoverage(downLevel);
        return true;
      };

      const getNextSellAbove = (cursor, target) => {
        let best = null;
        for (const entry of pendingSells) {
          const lvl = entry.level;
          const lowerTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(cursor));
          const upperTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(target));
          if (lvl > cursor + lowerTol && lvl <= target + upperTol) {
            if (!best || lvl < best.level) best = entry;
          }
        }
        return best;
      };

      const getNextBuyAbove = (cursor, target) => {
        let best = null;
        for (const entry of pendingBuys.values()) {
          const lvl = entry.level;
          const lowerTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(cursor));
          const upperTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(target));
          if (lvl > cursor + lowerTol && lvl <= target + upperTol) {
            if (!best || lvl < best.level) best = entry;
          }
        }
        return best;
      };

      const getNextBuyBelow = (target, cursor) => {
        let best = null;
        for (const entry of pendingBuys.values()) {
          const lvl = entry.level;
          const upperTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(cursor));
          const lowerTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(target));
          if (lvl < cursor - upperTol && lvl >= target - lowerTol) {
            if (!best || lvl > best.level) best = entry;
          }
        }
        return best;
      };

      const processMove = (start, end, timestamp, contextRow) => {
        const eventTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const scale = Math.max(1, Math.abs(start), Math.abs(end));
        const threshold = priceTolerance * scale;
        if (end > start + threshold) {
          let cursor = start;
          const target = end;
          let guard = 0;
          while (guard < 2000) {
            guard += 1;
            const nextSell = getNextSellAbove(cursor, target);
            const nextBuy = getNextBuyAbove(cursor, target);
            let nextEntry = null;
            let type = null;
            if (nextSell && nextBuy) {
              const compareTol = priceTolerance * Math.max(1, Math.abs(nextSell.level), Math.abs(nextBuy.level));
              if (nextSell.level <= nextBuy.level + compareTol) {
                nextEntry = nextSell;
                type = 'sell';
              } else {
                nextEntry = nextBuy;
                type = 'buy';
              }
            } else if (nextSell) {
              nextEntry = nextSell;
              type = 'sell';
            } else if (nextBuy) {
              nextEntry = nextBuy;
              type = 'buy';
            } else {
              break;
            }
            cursor = nextEntry.level;
            if (type === 'sell') {
              if (!executeSell(nextEntry, eventTime)) break;
            } else {
              if (!executeBuy(nextEntry, eventTime, contextRow)) break;
            }
          }
        } else if (end < start - threshold) {
          let cursor = start;
          const target = end;
          let guard = 0;
          while (guard < 2000) {
            guard += 1;
            const nextBuy = getNextBuyBelow(target, cursor);
            if (!nextBuy) break;
            cursor = nextBuy.level;
            if (!executeBuy(nextBuy, eventTime, contextRow)) break;
          }
        }
      };

      const buildPath = (fromPrice, row) => {
        const path = [];
        let start = Number(fromPrice);
        if (!Number.isFinite(start)) start = Number(row.open) || Number(row.close) || 0;
        path.push(start);
        const addPoint = (value) => {
          const num = Number(value);
          if (!Number.isFinite(num)) return;
          if (Math.abs(num - path[path.length - 1]) < priceTolerance * Math.max(1, num)) return;
          path.push(num);
        };
        const open = Number(row.open);
        const high = Number(row.high);
        const low = Number(row.low);
        const close = Number(row.close);
        if (Number.isFinite(open)) addPoint(open);
        const upBar = Number.isFinite(close) && Number.isFinite(open) ? (close >= open) : true;
        if (upBar) {
          if (Number.isFinite(high)) addPoint(high);
          if (Number.isFinite(low)) addPoint(low);
        } else {
          if (Number.isFinite(low)) addPoint(low);
          if (Number.isFinite(high)) addPoint(high);
        }
        if (Number.isFinite(close)) addPoint(close);
        return path;
      };

      const firstRow = Array.isArray(rows) && rows.length ? rows[0] : null;
      const initialTime = firstRow?.caldt instanceof Date ? new Date(firstRow.caldt.getTime()) : new Date();
      const initialBuy = queueBuy(firstPrice, buyGroupSeq++, 'down');
      if (initialBuy) executeBuy(initialBuy, initialTime, firstRow);
      const initialCoverageLevel = nextDownLevel(firstPrice);
      if (Number.isFinite(initialCoverageLevel)) {
        ensureDownCoverage(initialCoverageLevel);
      }

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const path = buildPath(prevPrice, row);
        for (let i = 1; i < path.length; i++) {
          const from = path[i - 1];
          const to = path[i];
          processMove(from, to, row.caldt, row);
        }
        prevPrice = path[path.length - 1];
        const equity = cash + shares * prevPrice;
        const openBuyOrders = pendingBuys.size;
        if (equity > peakEquity) peakEquity = equity;
        const drawdown = equity - peakEquity;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
        const drawdownPct = peakEquity > 0 ? drawdown / peakEquity : 0;
        if (drawdownPct < maxDrawdownPct) maxDrawdownPct = drawdownPct;
        lastEquityTime = new Date(row.caldt.getTime());
        ladderHistory.push({
          time: new Date(row.caldt.getTime()),
          buys: pendingBuys.size,
          sells: pendingSells.size,
          queued: 0
        });
        equitySeries.push({
          time: new Date(row.caldt.getTime()),
          equity,
          cash: cash,
          cashDeployed: openBuyOrders * tradeValue,
          initialCash
        });
      }

      const finalEquity = cash + shares * prevPrice;
      const millis = firstEquityTime && lastEquityTime ? (lastEquityTime.getTime() - firstEquityTime.getTime()) : 0;
      const years = millis > 0 ? (millis / (365.25 * 24 * 60 * 60 * 1000)) : 0;
      const cagr = (years > 0 && initialEquity > 0 && finalEquity > 0)
        ? Math.pow(finalEquity / initialEquity, 1 / years) - 1
        : 0;
      summary.totalTrades = trades.length;
      summary.netProfit = realizedProfit;
      summary.finalEquity = finalEquity;
      summary.totalRetainedShares = shares;
      summary.cash = cash;
      summary.minCash = minCashBalance;
      summary.shares = shares;
      summary.maxDrawdown = maxDrawdown;
      summary.maxDrawdownPct = maxDrawdownPct * 100;
      summary.maxSharesHeld = maxSharesHeld;
      summary.cagr = cagr;
      return { trades, summary, equitySeries, ladderHistory };
    }

    function runGridBacktest() {
      if (!Array.isArray(ROWS) || !ROWS.length) {
        setGridStatus('Load symbol data before running the backtest.');
        return;
      }
      const params = getGridParamsFromUI();
      const entryFilter = params?.entryFilter || 'none';
      const window = getEntryFilterWindow(entryFilter);
      if (window) {
        const info = describeSmaAvailability(entryFilter);
        const available = info?.availableDays || 0;
        if (available <= 0) {
          const totalDays = info?.totalDays ?? DAYS.length;
          setGridStatus(`Entry filter (${window}-day SMA) needs ${window} completed days. Dataset has ${totalDays.toLocaleString()} day${totalDays === 1 ? '' : 's'} — insufficient for this filter.`);
          renderGridSummary(null);
          renderGridTrades([]);
          renderGridEquityChart(null);
          renderLadderChart([]);
          return;
        }
      }
      setGridStatus('Running backtest…');
      try {
        const result = runPullbackGridSimulation(ROWS, params);
        GRID_STATE = result;
        renderGridSummary(result.summary);
        renderGridTrades(result.trades);
        renderGridEquityChart(result.equitySeries);
        renderLadderChart(result.trades);
        if (result.trades.length) {
          const profitLabel = formatCurrency(result.summary?.netProfit ?? 0);
          setGridStatus(`Backtest completed with ${result.trades.length} trade${result.trades.length === 1 ? '' : 's'}. Net profit ${profitLabel}.`);
        } else {
          setGridStatus('No completed trades for the selected parameters.');
        }
      } catch (err) {
        console.error('Buy-the-dip grid backtest error', err);
        setGridStatus('Failed to run backtest. See console for details.');
        renderLadderChart([]);
      }
    }

    function initGridControls() {
      const btn = document.getElementById('btnRunGridBacktest');
      if (btn) {
        btn.addEventListener('click', () => runGridBacktest());
      }
      const inputs = [
        document.getElementById('selGridType'),
        document.getElementById('selGridSpacing'),
        document.getElementById('selEntryFilter'),
        document.getElementById('selRetentionMode'),
        document.getElementById('inpGridSize'),
        document.getElementById('inpGridOffset'),
        document.getElementById('inpTradeValue'),
        document.getElementById('inpInitialCash'),
        document.getElementById('inpFractionalShares'),
        document.getElementById('inpAllowMargin')
      ];
      inputs.forEach(el => {
        if (!el) return;
        const handler = () => {
          if (el.id === 'selGridSpacing') updateGridSizeLabel();
          if (!Array.isArray(ROWS) || !ROWS.length) return;
          runGridBacktest();
        };
        const eventName = el.tagName === 'SELECT' || el.type === 'checkbox' ? 'change' : 'input';
        el.addEventListener(eventName, handler);
      });
      updateGridSizeLabel();
      resetGridOutputs('Load data and run the backtest to populate results.');
      setRunButtonEnabled(false);
      document.querySelectorAll('th[data-sort-key] button').forEach((btn) => {
        btn.addEventListener('click', () => {
          const th = btn.closest('th[data-sort-key]');
          if (!th) return;
          const key = th.getAttribute('data-sort-key');
          if (!key) return;
          if (TRADE_SORT_STATE.key === key) {
            TRADE_SORT_STATE.dir = TRADE_SORT_STATE.dir === 'asc' ? 'desc' : 'asc';
          } else {
            TRADE_SORT_STATE.key = key;
            TRADE_SORT_STATE.dir = 'asc';
          }
          renderGridTrades(GRID_STATE.trades || []);
        });
      });
      updateTradeSortIndicators();
    }


    async function loadSymbolData(sym) {
      const baseSymbol = (sym || '').trim();
      if (!baseSymbol) return false;
      setStatus(`Loading data for ${baseSymbol}…`);
      setGridStatus(`Loading data for ${baseSymbol}…`);
      setRunButtonEnabled(false);
      const candidates = Array.from(new Set([
        baseSymbol,
        baseSymbol.toUpperCase(),
        baseSymbol.toLowerCase()
      ])).filter(Boolean);
      let lastError = null;
      for (const candidate of candidates) {
        const path = `data/${candidate}_1m.csv`;
        try {
          const res = await fetch(path, { cache: 'no-cache' });
          if (!res.ok) {
            lastError = `HTTP ${res.status} loading ${path}`;
            continue;
          }
          const text = await res.text();
          const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
          if (parsed.errors && parsed.errors.length) {
            console.warn('CSV parse warnings:', parsed.errors.slice(0, 3));
          }
          normalizeAndIndex(parsed.data);
          if (!ROWS.length) {
            lastError = 'No valid rows in dataset.';
            continue;
          }
          updateSymbolPrecisionFromRows(baseSymbol, parsed.data);
          setStatus(`Loaded ${ROWS.length.toLocaleString()} 10-minute bars across ${DAYS.length.toLocaleString()} day(s).`);
          renderGridSummary(null);
          renderGridTrades([]);
          renderGridEquityChart(null);
          renderLadderChart([]);
          renderDataSummary();
          setGridStatus(`Loaded ${ROWS.length.toLocaleString()} 10-minute bars across ${DAYS.length.toLocaleString()} day(s). Running backtest…`);
          setRunButtonEnabled(true);
          runGridBacktest();
          return true;
        } catch (err) {
          lastError = err && err.message ? err.message : String(err);
        }
      }
      console.error(`Failed to load ${baseSymbol}: ${lastError || 'not found'}`);
      setStatus(`Error loading ${baseSymbol}: ${lastError || 'File not found.'}`);
      setGridStatus(`Error loading ${baseSymbol}: ${lastError || 'File not found.'}`);
      ROWS = [];
      DAY_GROUPS = new Map();
      DAYS = [];
      renderGridSummary(null);
      renderGridTrades([]);
      renderGridEquityChart(null);
      renderLadderChart([]);
      setRunButtonEnabled(false);
      renderDataSummary();
      return false;
    }

    function normalizeSymbolEntries(entries) {
      const map = new Map();
      const ordered = [];
      if (!Array.isArray(entries)) return { list: ordered, map };
      for (const entry of entries) {
        let symbol = '';
        let name = '';
        let multiplier = null;
        if (typeof entry === 'string') {
          symbol = entry;
          name = entry;
        } else if (entry && typeof entry === 'object') {
          symbol = entry.symbol;
          name = entry.name || entry.symbol || '';
          multiplier = entry.multiplier;
        } else {
          continue;
        }
        symbol = (symbol || '').toUpperCase().trim();
        if (!symbol || map.has(symbol)) continue;
        const existing = SYMBOL_META.get(symbol) || null;
        const parsedMultiplier = Number(multiplier);
        const finalMultiplier = Number.isFinite(parsedMultiplier) && parsedMultiplier > 0
          ? parsedMultiplier
          : (existing && Number.isFinite(existing.multiplier) ? existing.multiplier : 1);
        const providedPrecision = entry && typeof entry === 'object' && Number.isInteger(entry.precision) && entry.precision >= 0
          ? Math.min(entry.precision, 8)
          : null;
        const meta = {
          symbol,
          name: (typeof name === 'string' && name.trim()) ? name.trim() : (existing && existing.name ? existing.name : symbol),
          multiplier: finalMultiplier,
          precision: providedPrecision != null
            ? providedPrecision
            : (existing && Number.isInteger(existing.precision) ? existing.precision : null)
        };
        map.set(symbol, meta);
        ordered.push(meta);
      }
      return { list: ordered, map };
    }

    async function populateTickerSegment() {
      const container = document.getElementById('tickerSegment');
      if (!container) return;
      container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';
      const render = (entries) => {
        const normalized = normalizeSymbolEntries(entries);
        SYMBOL_META = normalized.map instanceof Map ? normalized.map : new Map();
        const list = Array.isArray(normalized.list) ? normalized.list : [];
        container.innerHTML = '';
        if (!list.length) {
          container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">No symbols available.</span>';
          highlightTickerButton(currentTicker);
          return;
        }
        list.forEach((meta) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'w-full h-full px-3 py-2 text-left bg-white hover:bg-emerald-50 transition flex flex-col justify-center gap-0.5 leading-tight';
          btn.setAttribute('data-symbol', meta.symbol);
          btn.setAttribute('title', meta.name);
          btn.dataset.multiplier = String(meta.multiplier);
          btn.innerHTML = `
            <span class="text-sm font-semibold">${meta.symbol}</span>
            <span class="text-xs text-slate-500" data-symbol-name>${meta.name}</span>
          `;
          container.appendChild(btn);
        });
        highlightTickerButton(currentTicker);
        if (!currentTicker && list[0]) {
          setTicker(list[0].symbol);
          loadSymbolData(list[0].symbol);
        }
      };
      try {
        const res = await fetch('data/index.json', { cache: 'no-cache' });
        if (res.ok) {
          const list = await res.json();
          if (Array.isArray(list) && list.length) { render(list); return; }
        }
      } catch (err) {
        console.warn('Failed to load index.json', err);
      }
      try {
        const res = await fetch('data/', { cache: 'no-cache' });
        if (res.ok) {
          const text = await res.text();
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let files = [];
          if (ct.includes('text/html')) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            files = Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href')).filter(Boolean);
          } else {
            files = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          }
          const regex = /^([A-Za-z0-9-]+)_1m\.csv$/i;
          const syms = [];
          for (const f of files) {
            const name = (f || '').split('/').pop();
            const m = name.match(regex);
            if (m) syms.push({ symbol: m[1].toUpperCase(), name: m[1].toUpperCase(), multiplier: undefined });
          }
          if (syms.length) { render(syms); return; }
        }
      } catch (err) {
        console.warn('Failed to enumerate data directory', err);
      }
      render(['TQQQ', 'TSLA', 'PLTR', 'UVXY']);
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#tickerSegment button[data-symbol]');
      if (!btn) return;
      const symbol = btn.getAttribute('data-symbol');
      if (!symbol) return;
      setTicker(symbol);
      loadSymbolData(symbol);
    });

    document.addEventListener('DOMContentLoaded', () => {
      initGridControls();
      populateTickerSegment();
    });

    window.addEventListener('resize', () => {
      if (gridEquityChartInst) {
        try { gridEquityChartInst.resize(); } catch {}
      }
    });
  })();
</script>
</body>
</html>
