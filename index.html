<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ORB Monthly Performance Tables</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Tailframes components (Tailwind-based) -->
  <script src="https://cdn.tailframes.com/releases/latest/tailframes.min.js" defer></script>
  <!-- Plotly for interactive charts -->
  <script src="https://cdn.plot.ly/plotly-2.31.1.min.js"></script>
  <style>
    .num-pos { color: #065f46; } /* emerald-800 */
    .num-neg { color: #9f1239; } /* rose-800 */
    .sticky-th { position: sticky; top: 0; background: white; z-index: 1; }
    .shadow-soft { box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
    .grid-auto { grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }
  /* 1px gold border for active tile (no extra shadow to avoid clipping) */
  .outline-gold { border-color: #c28e0e !important; }
  /* Active R column highlight in monthly table */
  .col-active-header { background-color: #fff3bf; } /* soft gold */
  .col-active-cell { background-color: #fff8dc; } /* lighter gold */
  /* Prevent iOS tap highlight/focus from washing out selected segment buttons */
  #tickerSegment button, #directionSegment button, #daysSegment button, #weekdaySegment button {
    -webkit-tap-highlight-color: transparent;
  }
  #tickerSegment button:focus, #directionSegment button:focus, #daysSegment button:focus, #weekdaySegment button:focus {
    outline: none;
    box-shadow: none;
  }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <div class="max-w-7xl mx-auto p-6">
    <header class="mb-6">
      <!-- Updated: add id for dynamic title prefixing -->
      <h1 id="mainTitle" class="text-2xl md:text-3xl font-semibold">ORB Monthly Performance</h1>
      <p class="text-slate-600 mt-1">This app displays <span class="font-semibold">monthly sums</span> of daily P&amp;L (R units) for each <code>orb_m</code> × <code>target_R</code> combination. Orb_m is the number of minutes after 9:30 NY time. target_R is the desired target return in R units. stop_R is fixed at 2R.</p>
    </header>

    <!-- NEW: Symbol segmented control -->
    <section id="symbolPicker" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 mb-6">
      <div class="flex items-center gap-2">
        <span class="text-sm text-slate-600">Symbol:</span>
        <div class="flex-1 min-w-0 overflow-x-auto">
          <div id="tickerSegment" class="inline-flex min-w-max rounded-xl border border-slate-200 overflow-hidden whitespace-nowrap">
            <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
          </div>
        </div>
      </div>
      <!-- NEW: Direction segmented control + Risk per trade input -->
      <div class="mt-3 flex items-center gap-2">
        <span class="text-sm text-slate-600">Direction:</span>
        <div id="directionSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden" data-selected="BOTH">
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200" data-direction="BOTH">BOTH</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200" data-direction="LONG">LONG</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100" data-direction="SHORT">SHORT</button>
        </div>
        <div class="flex items-center gap-2 ml-auto">
          <label for="riskInput" class="text-sm text-slate-600 whitespace-nowrap">Risk per trade:</label>
          <div class="relative inline-block">
            <input id="riskInput" type="number" min="0" max="100" step="0.1" value="2" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-7 py-2 text-sm w-24" />
            <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">%</span>
          </div>
        </div>
      </div>
    </section>

    <!-- Preload palette classes for Tailwind JIT -->
    <div class="hidden bg-emerald-50 bg-emerald-100 bg-emerald-200 bg-emerald-300 bg-emerald-400 bg-rose-50 bg-rose-100 bg-rose-200 bg-rose-300 bg-rose-400"></div>

    <!-- Controls (collapsible) -->
    <section id="controlsSection" class="relative bg-white rounded-2xl shadow-soft p-4 md:p-6 space-y-4 mb-6">
      <!-- Toggle (top-right) -->
      <button id="controlsToggle" aria-expanded="false" aria-label="Expand upload controls" class="absolute right-4 top-4 inline-flex items-center gap-2 rounded-full px-2 py-1 text-sm bg-slate-100 hover:bg-slate-200">
        <svg id="controlsChevron" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 transition-transform" viewBox="0 0 20 20" fill="currentColor" aria-hidden="false"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
      </button>

      <div class="flex flex-col md:flex-row md:items-center gap-3">
        <label class="block text-sm font-medium">Upload CSV</label>
        <input id="fileInput" type="file" accept=".csv,text/csv" class="block w-full md:w-auto text-sm file:mr-4 file:py-2 file:px-4 file:rounded-xl file:border-0 file:text-sm file:font-semibold file:bg-slate-800 file:text-white hover:file:bg-slate-900" />
      </div>

      <!-- Collapsible body: hidden by default; contains the rest of the controls -->
      <div id="controlsBody" class="hidden">
        <div class="grid grid-cols-1 gap-4">
          <div>
            <label for="csvText" class="block text-sm font-medium mb-1">Paste CSV here</label>
            <textarea id="csvText" rows="12" class="w-full font-mono text-xs md:text-sm p-3 rounded-xl border border-slate-200 focus:outline-none focus:ring-2 focus:ring-slate-300" placeholder="Paste your CSV…"></textarea>
          </div>
        </div>

        <div class="flex flex-col md:flex-row md:items-center gap-3">
          <div class="flex items-center gap-2">
            <label class="text-sm">Aggregation:</label>
            <div class="relative inline-block">
              <select id="aggSelect" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 pr-9 text-sm">
                <option value="sum" selected>Monthly sum of daily R</option>
              </select>
              <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <label class="text-sm">Missing values:</label>
            <div class="relative inline-block">
              <select id="naSelect" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 pr-9 text-sm">
                <option value="skip" selected>Skip</option>
                <option value="zero">Treat as 0</option>
              </select>
              <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
          </div>
          <button id="processBtn" class="w-full md:w-auto inline-flex items-center justify-center rounded-xl px-4 py-2 text-sm font-semibold bg-emerald-600 text-white hover:bg-emerald-700">Process CSV</button>
          <button id="clearBtn" class="w-full md:w-auto inline-flex items-center justify-center rounded-xl px-4 py-2 text-sm font-semibold bg-slate-200 text-slate-800 hover:bg-slate-300">Clear</button>
        </div>

        <details class="text-sm text-slate-600 mt-2">
          <summary class="cursor-pointer select-none">Expected CSV layout</summary>
          <pre class="mt-2 p-3 bg-slate-100 rounded-xl overflow-x-auto text-xs">orb_m,5,5,5,5,5,5,10,10,10,10,...
 target_R,1,2,3,4,5,6,1,2,3,4,...
 Date Range,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 2024-07-15,0.9990,1.9980,2.9970,-1.9980,...
 2024-07-12,0.9981,1.9962,2.9943,3.9924,...
 ...</pre>
        </details>
      </div>
    </section>

    <!-- Output -->
    <section id="output" class="space-y-6"></section>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const csvText = document.getElementById('csvText');
    const processBtn = document.getElementById('processBtn');
    const clearBtn = document.getElementById('clearBtn');
    const output = document.getElementById('output');

    // NEW: track selected ticker and helper to update titles
    let currentTicker = '';
  // NEW: track selected direction (UI only for now; wiring next)
  let currentDirection = 'BOTH';
  // NEW: global selection state for summary cards (orb_m × target_R combos)
  // Keys are in the form `m{orb}_r{R}`
  const selectedCombos = new Set();
  function comboKey(orb, r, dir, sym){
    const base = `m${Number(orb)}_r${Number(r)}`;
    const d = (dir || '').toUpperCase();
    const s = String(sym||'').toUpperCase();
    let out = base;
    if (d) out += `_d${d}`;
    if (s) out += `_s${s}`;
    return out;
  }
  function parseComboKey(key){
    const s = String(key||'');
    let m = s.match(/^m(\d+(?:\.\d+)?)_r(\d+(?:\.\d+)?)(?:_d([A-Z]+))?(?:_s([A-Z0-9-]+))?$/);
    if (!m) return null;
    return { orb: Number(m[1]), r: Number(m[2]), dir: m[3] || undefined, sym: m[4] || undefined };
  }
  function hasSelectionForOrbR(orb, r){
    for (const k of selectedCombos) {
      const pr = parseComboKey(k);
      if (pr && Number(pr.orb) === Number(orb) && Number(pr.r) === Number(r)) return true;
    }
    return false;
  }
  function hasSelectionFor(orb, r, dir, sym){
    const d = String(dir||'').toUpperCase();
    const s = String(sym||'').toUpperCase();
    for (const k of selectedCombos) {
      const pr = parseComboKey(k);
      if (!pr) continue;
      if (Number(pr.orb) !== Number(orb) || Number(pr.r) !== Number(r)) continue;
      if (d && String(pr.dir||'').toUpperCase() !== d) continue;
      if (s && String(pr.sym||'').toUpperCase() !== s) continue;
      return true;
    }
    return false;
  }
  // NEW: per-combo direction overrides (BOTH/LONG/SHORT); defaults to currentDirection when first selected
  const comboDirectionOverrides = new Map(); // key -> 'BOTH'|'LONG'|'SHORT'
  // NEW: per-combo allocation overrides (percentage of starting equity 0..100)
  const comboAllocationOverrides = new Map(); // key -> number (%) 
  // NEW: cache models per direction for current ticker
  let currentModel = null; // last rendered model for current view
  // Per-symbol + direction caches
  const modelsBySymDir = new Map(); // key: `${SYM}|${DIR}` -> model
  const combosBySymDir = new Map(); // key: `${SYM}|${DIR}` -> combosByOrb Map
  const symDirKey = (sym, dir) => `${String(sym||'').toUpperCase()}|${String(dir||'BOTH').toUpperCase()}`;
  function setModelCache(sym, dir, model){
    modelsBySymDir.set(symDirKey(sym, dir), model);
    combosBySymDir.set(symDirKey(sym, dir), combosByOrbFromModel(model));
  }
  function getModelCache(sym, dir){ return modelsBySymDir.get(symDirKey(sym, dir)); }
  function getCombosByOrbCache(sym, dir){ return combosBySymDir.get(symDirKey(sym, dir)); }
  function combosByOrbFromModel(model){
    const orbMap = new Map();
    for (const { orb_m, target_R, key } of model.combos) {
      if (!orbMap.has(orb_m)) orbMap.set(orb_m, []);
      orbMap.get(orb_m).push({ target_R, key });
    }
    for (const [orb, arr] of orbMap) arr.sort((a,b) => a.target_R - b.target_R);
    return orbMap;
  }
    function setTickerFromFilename(name) {
      const m = name && name.match(/^([A-Za-z][A-Za-z0-9-]*)_backtest_results\.csv$/i);
      const t = m ? m[1] : (name ? (name.split('_')[0] || '') : '');
      currentTicker = (t || '').toUpperCase();
      const full = `${currentTicker ? currentTicker + ' - ' : ''}ORB Monthly Performance Tables`;
      const titleEl = document.getElementById('mainTitle');
      if (titleEl) titleEl.textContent = full;
      document.title = full;
    }

    // NEW: helper to process CSV string and render
    function processCsvAndRender(text, opts) {
      const trimmed = (text || '').trim();
      if (!trimmed) return;
  const doReset = !(opts && opts.resetSelection === false);
  if (doReset) {
    // Reset multi-selection on explicit request (e.g., new ticker or manual CSV)
    selectedCombos.clear();
    comboDirectionOverrides.clear();
    comboAllocationOverrides.clear();
  }
      const parsed = parseCSV(trimmed);
      const model = toModel(parsed);
  currentModel = model;
  // Cache under currentDirection for cross-direction combined calculations
  setModelCache(currentTicker, currentDirection, model);
  const { byOrb, monthsSorted, combosByOrb } = aggregateMonthly(model, {
        naMode: document.getElementById('naSelect').value
      });
  // Ensure the active sym+dir is cached after processing
  try { setModelCache(currentTicker, currentDirection, model); } catch {}
      renderTables(model, combosByOrb, byOrb, monthsSorted, currentTicker);
    }

    // --- Upload handler ---
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        csvText.value = text.trim();
        // NEW: extract and apply ticker from filename
        setTickerFromFilename(file.name);
      } catch (err) {
        alert('Could not read file: ' + err.message);
      }
    });

    // --- Process ---
  processBtn.addEventListener('click', () => {
      try {
    processCsvAndRender(csvText.value, { resetSelection: true });
      } catch (err) {
        console.error(err);
        alert('Error: ' + err.message);
      }
    });

    // --- Clear ---
    clearBtn.addEventListener('click', () => {
      csvText.value = '';
      fileInput.value = '';
      output.innerHTML = '';
      // NEW: reset ticker and titles
      currentTicker = '';
      const defaultTitle = 'ORB Monthly Performance Tables';
      const titleEl = document.getElementById('mainTitle');
      if (titleEl) titleEl.textContent = defaultTitle;
      document.title = defaultTitle;
      csvText.focus();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });

    // Helper: build data URL based on symbol and direction
    function buildDataUrl(sym, dir) {
      const suffix = dir === 'LONG' ? '_LONG' : dir === 'SHORT' ? '_SHORT' : '';
      const file = `${sym}${suffix}_backtest_results.csv`;
      return { file, url: new URL(`data/${file}`, window.location.href).toString() };
    }

    // Helper: load and render for a given symbol + direction; clears output if missing
    async function loadAndRender(sym, dir, opts) {
      const { file, url } = buildDataUrl(sym, dir);
      try {
        const res = await fetch(url, { cache: 'no-cache' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const prevSym = currentTicker;
        currentTicker = sym;
        setTickerFromFilename(file);
        csvText.value = text.trim();
  const resetSelection = (opts && Object.prototype.hasOwnProperty.call(opts, 'resetSelection'))
          ? !!opts.resetSelection
          : (sym !== prevSym); // reset only when ticker changes by default
  processCsvAndRender(text, { resetSelection });
  // Cache this symbol+direction model
  try { setModelCache(sym, dir, currentModel); } catch {}
  // Preload other directions in the background for combined equity with per-row directions
  try { preloadOtherDirections(sym, dir); } catch {}
        return true;
      } catch (err) {
        console.warn(`Data not found for ${sym} ${dir}: ${file}`, err);
        // Don't clear current UI; just keep the previous models and selections intact
        // Update title to show selected symbol even if data missing
        currentTicker = sym;
        setTickerFromFilename(`${sym}_backtest_results.csv`);
        return false;
      }
    }

    // NEW: Preload models for the other directions (BOTH/LONG/SHORT) without re-rendering
    async function preloadOtherDirections(sym, loadedDir){
      const dirs = ['BOTH','LONG','SHORT'].filter(d => d !== loadedDir);
      await Promise.all(dirs.map(async d => {
        if (getModelCache(sym, d)) return; // already cached for this symbol
        const { url } = buildDataUrl(sym, d);
        try {
          const res = await fetch(url, { cache: 'no-cache' });
          if (!res.ok) return;
          const text = await res.text();
          const parsed = parseCSV(text.trim());
          const mdl = toModel(parsed);
          setModelCache(sym, d, mdl);
        } catch { /* ignore */ }
      }));
    }

    // Ensure a specific symbol+direction model is cached (no UI re-render)
    async function ensureModelFor(sym, dir){
      const s = String(sym||'').toUpperCase();
      const d = String(dir||'BOTH').toUpperCase();
      if (getModelCache(s, d)) return true;
      const { url } = buildDataUrl(s, d);
      try {
        const res = await fetch(url, { cache: 'no-cache' });
        if (!res.ok) return false;
        const text = await res.text();
        const parsed = parseCSV(text.trim());
        const mdl = toModel(parsed);
        setModelCache(s, d, mdl);
        return true;
      } catch {
        return false;
      }
    }

    // Expose direction segment and a setter to reset from outside
    const directionSegment = document.getElementById('directionSegment');
    const riskInput = document.getElementById('riskInput');
    // Assume stop_R is fixed at 2R; interpret input as max risk per trade at stop-out.
    // Therefore, 1R percent = (risk_per_trade_percent) / stop_R.
    function getRiskPct(){
      const stopR = 2; // fixed stop at 2R
      const v = parseFloat(riskInput ? riskInput.value : '2');
      const riskPerTrade = (!Number.isFinite(v) || v < 0) ? 2 : v; // percent
      return (riskPerTrade / 100) / stopR; // e.g., 2% / 2R = 1% per R
    }
    function setActiveDirectionByValue(val) {
      if (!directionSegment) return;
      const btn = directionSegment.querySelector(`button[data-direction="${val}"]`);
      directionSegment.querySelectorAll('button').forEach(b => {
        b.classList.remove('bg-slate-800','text-white','focus:outline-none');
        // Ensure non-active buttons look like segments
        if (!b.classList.contains('bg-white')) b.classList.add('bg-white');
        if (!b.classList.contains('hover:bg-slate-100')) b.classList.add('hover:bg-slate-100');
      });
      if (btn) {
        btn.classList.add('bg-slate-800','text-white','focus:outline-none');
        btn.classList.remove('bg-white','hover:bg-slate-100');
        directionSegment.setAttribute('data-selected', val);
        currentDirection = val;
      }
    }

    // NEW: Ticker segmented control logic – load based on currentDirection; reset to BOTH on select
    const tickerSegment = document.getElementById('tickerSegment');
    if (tickerSegment) {
      const setActiveTicker = (btn) => {
        tickerSegment.querySelectorAll('button').forEach(b => {
          b.classList.remove('bg-slate-800','text-white','focus:outline-none');
          // restore default look for non-active
          if (!b.classList.contains('bg-white')) b.classList.add('bg-white');
          if (!b.classList.contains('hover:bg-slate-100')) b.classList.add('hover:bg-slate-100');
        });
        if (btn) {
          btn.classList.add('bg-slate-800','text-white','focus:outline-none');
          btn.classList.remove('bg-white','hover:bg-slate-100');
        }
      };

      tickerSegment.addEventListener('click', async (e) => {
        const btn = e.target.closest('button[data-symbol]');
        if (!btn) return;
        const sym = String(btn.getAttribute('data-symbol') || '').toUpperCase();
        if (!sym) return;
        setActiveTicker(btn);
        // Reset direction to BOTH by default when symbol changes
        setActiveDirectionByValue('BOTH');
  // Load BOTH for the newly selected symbol, keep existing selections
  await loadAndRender(sym, 'BOTH', { resetSelection: false });
      });
    }

    // NEW: Direction segmented control logic (loads matching CSV if ticker selected)
    (function(){
      if (!directionSegment) return;
      // init -> BOTH
      setActiveDirectionByValue('BOTH');
      directionSegment.addEventListener('click', async (e) => {
        const btn = e.target.closest('button[data-direction]');
        if (!btn) return;
        const dir = String(btn.getAttribute('data-direction') || 'BOTH').toUpperCase();
        setActiveDirectionByValue(dir);
        if (!currentTicker) return; // nothing to load yet
        // Capture current equity selections (if present) before re-render
        const prevOrbEl = document.getElementById('eqOrbSelect');
        const prevREl = document.getElementById('eqRSelect');
        const prevOrb = prevOrbEl ? prevOrbEl.value : null;
        const prevR = prevREl ? prevREl.value : null;
  // Keep current selections when switching direction (we support mixed directions)
  await loadAndRender(currentTicker, dir, { resetSelection: false });
        // Restore selections if still available in the new dataset
        const orbEl = document.getElementById('eqOrbSelect');
        const rEl = document.getElementById('eqRSelect');
        if (orbEl && prevOrb && Array.from(orbEl.options).some(o => o.value === String(prevOrb))) {
          orbEl.value = String(prevOrb);
          // trigger populate of R options via existing handler
          orbEl.dispatchEvent(new Event('change', { bubbles: true }));
          const rElNow = document.getElementById('eqRSelect');
          if (rElNow && prevR && Array.from(rElNow.options).some(o => o.value === String(prevR))) {
            rElNow.value = String(prevR);
            rElNow.dispatchEvent(new Event('change', { bubbles: true }));
          }
        }
      });
    })();

    // Risk input: re-draw when changed
    if (riskInput) {
      const clamp = (v) => Math.min(100, Math.max(0, v));
      riskInput.addEventListener('change', (e) => {
        const num = parseFloat(riskInput.value);
        if (!Number.isFinite(num)) { riskInput.value = '2'; }
        else { riskInput.value = String(clamp(num)); }
        // If equity section exists, trigger its draw by dispatching a change on selects or call handler
        const eqOrb = document.getElementById('eqOrbSelect');
        if (eqOrb) {
          // Bubble a synthetic event to let listeners update
          eqOrb.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });
      riskInput.addEventListener('input', () => {
        // live update the assumption blurb and chart without losing selection
        const eqR = document.getElementById('eqRSelect');
        if (eqR) {
          eqR.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });
    }

    function parseCSV(text) {
      const rows = [];
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      for (const line of lines) rows.push(line.split(',').map(c => c.trim()))
      if (rows.length < 4) throw new Error('CSV must include orb_m row, target_R row, a label row, and data rows.');
      return rows;
    }

    // --- Model ---
    function toModel(rows) {
      const orbHeader = rows[0];
      const trgHeader = rows[1];
      if (!/^orb_m$/i.test(orbHeader[0])) throw new Error('First row must start with "orb_m"');
      if (!/^target_R$/i.test(trgHeader[0])) throw new Error('Second row must start with "target_R"');

      const orbVals = orbHeader.slice(1).map(v => parseFloat(v));
      const trgVals = trgHeader.slice(1).map(v => parseFloat(v));
      if (orbVals.length !== trgVals.length) throw new Error('orb_m and target_R columns must align.');

      let startIdx = 2;
      if (/date/i.test(rows[2][0])) startIdx = 3;

      const combos = orbVals.map((m, i) => ({ orb_m: m, target_R: trgVals[i], key: `m${m}_r${trgVals[i]}` }));

      const data = [];
      for (let i = startIdx; i < rows.length; i++) {
        const r = rows[i];
        const dateStr = r[0];
        const d = new Date(dateStr);
        if (isNaN(d)) throw new Error(`Bad date on row ${i+1}: ${dateStr}`);
        const y = d.getFullYear();
        const m = d.getMonth() + 1; // 1-12
        const record = { date: d, year: y, month: m, yyyymm: `${y}-${String(m).padStart(2,'0')}` };
        for (let c = 0; c < combos.length; c++) {
          const raw = r[c+1];
          const val = raw === undefined || raw === '' ? null : Number(raw);
          record[combos[c].key] = Number.isFinite(val) ? val : null;
        }
        data.push(record);
      }
      return { combos, data };
    }

    // --- Monthly aggregation ---
    function aggregateMonthly(model, opts) {
      const { combos, data } = model;
      const naMode = opts && opts.naMode || 'skip';
      const months = Array.from(new Set(data.map(d => d.yyyymm))).sort();
      const byOrb = new Map();

      const orbMap = new Map();
      for (const { orb_m, target_R, key } of combos) {
        if (!orbMap.has(orb_m)) orbMap.set(orb_m, []);
        orbMap.get(orb_m).push({ target_R, key });
      }
      for (const [orb, arr] of orbMap) arr.sort((a,b) => a.target_R - b.target_R);

      for (const [orb, arr] of orbMap) {
        const rowsOut = [];
        for (const m of months) {
          const monthRows = data.filter(d => d.yyyymm === m);
          const vals = new Map();
          for (const { target_R, key } of arr) {
            let sum = 0;
            let used = 0;
            for (const d of monthRows) {
              const v = d[key];
              if (v === null || !Number.isFinite(v)) {
                if (naMode === 'zero') { sum += 0; used++; }
                continue;
              }
              sum += v; used++;
            }
            vals.set(target_R, used === 0 ? null : sum);
          }
          rowsOut.push({ month: m, vals });
        }
        byOrb.set(orb, { targets: arr.map(o => o.target_R), rows: rowsOut });
      }
      return { byOrb, monthsSorted: months, combosByOrb: orbMap };
    }

    // --- Render ---
    function renderTables(model, combosByOrb, byOrb, monthsSorted, ticker) {
      output.innerHTML = '';

      // NEW: prefix for headings and main title
      const prefix = ticker ? `${ticker} - ` : '';
      const mainTitleEl = document.getElementById('mainTitle');
      if (mainTitleEl) {
        const full = `${prefix}ORB Monthly Performance Tables`;
        mainTitleEl.textContent = full;
        document.title = full;
      }

      // SUMMARY
      const summaryEl = document.createElement('div');
      summaryEl.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6';
      summaryEl.innerHTML = `
        <div class="mb-2">
          <h2 class="text-lg font-semibold">${prefix}Totals (sum of daily R) by combo</h2>
          <p class="text-xs text-slate-500 mt-1">Click cards to select multiple strategies; click again to remove. Selected strategies will appear below with a combined equity curve.</p>
        </div>
        <div class="flex items-center gap-4 flex-wrap mb-3">
          <div class="flex items-center gap-2">
            <span class="text-sm text-slate-600">Days:</span>
            <div id="daysSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden">
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"ALL\">All</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"5\">5</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"10\">10</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"20\">20</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"30\">30</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"60\">60</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"90\">90</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100\" data-days=\"120\">120</button>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <label class="text-sm text-slate-600">Month(s):</label>
            <div class="relative inline-block">
              <button id="sumMonthMultiBtn" type="button" class="inline-flex items-center justify-between gap-2 bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm min-w-[160px]">
                <span id="sumMonthMultiLabel" class="truncate">All months</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </button>
              <div id="sumMonthMultiMenu" class="absolute z-30 mt-1 w-64 bg-white border border-slate-200 rounded-xl shadow-soft p-2 hidden">
                <div class="sticky top-0 bg-white z-10 px-2 pb-2 border-b border-slate-200 flex items-center justify-between gap-2">
                  <button id="sumMonthSelectAll" type="button" class="text-xs font-medium text-emerald-700 hover:text-emerald-900 hover:underline">Select all</button>
                  <button id="sumMonthClearAll" type="button" class="text-xs text-slate-600 hover:text-slate-800 hover:underline">Clear</button>
                </div>
                <div id="sumMonthMultiList" class="max-h-64 overflow-auto"></div>
              </div>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <span class="text-sm text-slate-600">Weekdays:</span>
            <div id="weekdaySegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden">
              <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-r border-slate-200" data-dow="1">Mon</button>
              <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-r border-slate-200" data-dow="2">Tue</button>
              <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-r border-slate-200" data-dow="3">Wed</button>
              <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-r border-slate-200" data-dow="4">Thu</button>
              <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white" data-dow="5">Fri</button>
            </div>
          </div>
        </div>
        <!-- keep 6 columns but allow horizontal scrolling if necessary; make cards more compact -->
  <div id="summaryCards" class="overflow-x-auto px-[1px] py-[1px]"><div class="grid grid-cols-6 gap-2 min-w-max" id="summaryCardsGrid"></div></div>
      `;
      output.appendChild(summaryEl);

  const seg = summaryEl.querySelector('#daysSegment');
      // We render into inner grid container to allow horizontal scroll on small portrait screens
      const cardsContainer = summaryEl.querySelector('#summaryCardsGrid');

      const setActive = (btn) => {
        seg.querySelectorAll('button').forEach(b => b.classList.remove('bg-slate-800','text-white'));
        if (btn) { btn.classList.add('bg-slate-800','text-white'); seg.setAttribute('data-selected', btn.getAttribute('data-days')); }
      };

  // Weekday selection state (1..5 selected by default)
      const weekdaySegment = summaryEl.querySelector('#weekdaySegment');
      const selectedDOW = new Set([1,2,3,4,5]);

      const toggleWeekdayBtn = (btn, on) => {
        btn.classList.toggle('bg-slate-800', on);
        btn.classList.toggle('text-white', on);
      };

      // Month multi-select state (default: all months = no filter)
      const sumMonthBtn = summaryEl.querySelector('#sumMonthMultiBtn');
      const sumMonthLabel = summaryEl.querySelector('#sumMonthMultiLabel');
      const sumMonthMenu = summaryEl.querySelector('#sumMonthMultiMenu');
      const sumMonthList = summaryEl.querySelector('#sumMonthMultiList');
      let selectedMonths = new Set(); // empty means no filter (all)

      function sumFmtMonthShort(ym){
        const [y, m] = ym.split('-');
        const names = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        return `${names[Number(m)-1]} ${y}`;
      }
      function sumUpdateMonthBtnLabel(){
        if (!selectedMonths || selectedMonths.size === 0 || selectedMonths.size === monthsSorted.length) {
          sumMonthLabel.textContent = 'All months';
          return;
        }
        const shown = Array.from(selectedMonths).sort().map(sumFmtMonthShort);
        if (shown.length === 1) { sumMonthLabel.textContent = shown[0]; return; }
        if (shown.length <= 3) { sumMonthLabel.textContent = shown.join(', '); return; }
        sumMonthLabel.textContent = `${shown.length} months`;
      }

      // Populate list
      if (sumMonthList) {
        monthsSorted.slice().sort().forEach(m => {
          const id = `sum_m_${m.replace('-','_')}`;
          const row = document.createElement('label');
          row.className = 'flex items-center gap-2 px-2 py-1.5 rounded-lg hover:bg-slate-50 cursor-pointer';
          row.innerHTML = `
            <input type="checkbox" class="h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-500" value="${m}" id="${id}" />
            <span class="text-sm text-slate-700">${fmtMonthDisplay(m)}</span>
          `;
          sumMonthList.appendChild(row);
        });
      }

      // Toggle dropdown
      if (sumMonthBtn && sumMonthMenu) {
        sumMonthBtn.addEventListener('click', (e) => { e.stopPropagation(); sumMonthMenu.classList.toggle('hidden'); });
        document.addEventListener('click', (e) => { const within = summaryEl.contains(e.target); if (!within) sumMonthMenu.classList.add('hidden'); });
      }

      // Select all / Clear
      const sumMonthSelectAll = summaryEl.querySelector('#sumMonthSelectAll');
      const sumMonthClearAll = summaryEl.querySelector('#sumMonthClearAll');
      if (sumMonthSelectAll) sumMonthSelectAll.addEventListener('click', (e) => {
        e.preventDefault(); e.stopPropagation();
        selectedMonths = new Set(monthsSorted);
        // check all boxes
        sumMonthList.querySelectorAll('input[type="checkbox"]').forEach(i => i.checked = true);
        sumUpdateMonthBtnLabel();
        rebuildSummaryCards();
  summaryEl.dispatchEvent(new CustomEvent('filters-changed', { bubbles: false }));
      });
      if (sumMonthClearAll) sumMonthClearAll.addEventListener('click', (e) => {
        e.preventDefault(); e.stopPropagation();
        selectedMonths = new Set();
        sumMonthList.querySelectorAll('input[type="checkbox"]').forEach(i => i.checked = false);
        sumUpdateMonthBtnLabel();
        rebuildSummaryCards();
  summaryEl.dispatchEvent(new CustomEvent('filters-changed', { bubbles: false }));
      });

      // Change handler for list
      if (sumMonthList) {
        sumMonthList.addEventListener('change', () => {
          const checked = Array.from(sumMonthList.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value);
          if (checked.length === monthsSorted.length) {
            selectedMonths = new Set(monthsSorted);
          } else {
            selectedMonths = new Set(checked);
          }
          sumUpdateMonthBtnLabel();
          rebuildSummaryCards();
          summaryEl.dispatchEvent(new CustomEvent('filters-changed', { bubbles: false }));
        });
      }

      sumUpdateMonthBtnLabel();

      const rebuildSummaryCards = () => {
        const daysSel = seg.getAttribute('data-selected') || 'ALL';
        const naMode = document.getElementById('naSelect').value;
        const totals = computeTotalsByDays(model, combosByOrb, daysSel, naMode, selectedDOW, selectedMonths); // Map orb -> Map(r -> total|null)

        // Build flat list for rendering & highlighting
        const summaryCards = [];
        const orbs = Array.from(combosByOrb.keys()).sort((a,b) => a - b);
        for (const orb of orbs) {
          const rmap = totals.get(orb) || new Map();
          const rs = (combosByOrb.get(orb) || []).map(o => o.target_R).sort((a,b)=>a-b);
          for (const r of rs) {
            const total = rmap.has(r) ? rmap.get(r) : null;
            summaryCards.push({ orb, r, total });
          }
        }

        // Top/bottom 5 highlights
        const valid = summaryCards.filter(c => c.total !== null);
        const top = [...valid].sort((a,b) => b.total - a.total).slice(0,5);
        const bottom = [...valid].sort((a,b) => a.total - b.total).slice(0,5);
        const hl = new Map();
        top.forEach((c,i)=> hl.set(`${c.orb}|${c.r}`, topShade(i)));
        bottom.forEach((c,i)=> { if (!hl.has(`${c.orb}|${c.r}`)) hl.set(`${c.orb}|${c.r}`, bottomShade(i)); });

        // Determine current equity selection to highlight active card
        const orbSelEl = document.getElementById('eqOrbSelect');
        const rSelEl = document.getElementById('eqRSelect');
        const activeOrb = orbSelEl ? Number(orbSelEl.value) : null;
        const activeR = rSelEl ? Number(rSelEl.value) : null;

        cardsContainer.innerHTML = summaryCards.map(c => {
          const cls = c.total === null ? 'text-slate-400' : (c.total >= 0 ? 'num-pos' : 'num-neg');
          const val = c.total === null ? '—' : fmt(c.total);
          const bg = hl.get(`${c.orb}|${c.r}`) || '';
          const isActive = (activeOrb === c.orb && activeR === c.r);
          const activeCls = isActive ? 'outline-gold' : '';
          const isSelectedThisView = hasSelectionFor(c.orb, c.r, currentDirection, currentTicker);
          const selectedCls = isSelectedThisView ? 'ring-2 ring-emerald-500' : '';
          // Keep 6 columns but reduce text size and padding to fit portrait mobile
          return `<button type="button" class="relative rounded-2xl border border-slate-200 p-2 sm:p-3 ${bg} ${activeCls} ${selectedCls} min-w-[120px] text-left hover:bg-slate-50 focus:outline-none cursor-pointer" data-orb="${c.orb}" data-r="${c.r}">
            <div class="text-[11px] sm:text-xs text-slate-500 truncate">orb_m ${c.orb} · R ${c.r}</div>
            <div class="text-lg sm:text-2xl font-semibold ${cls}">${val}</div>
            ${isSelectedThisView ? '<span class="absolute top-1 right-1 inline-flex items-center justify-center h-5 w-5 rounded-full bg-emerald-600 text-white text-[10px]">✓</span>' : ''}
          </button>`;
        }).join('');
      };

  // Expose a refresher to allow other sections to update card highlights after selection changes
  summaryEl.refreshCards = rebuildSummaryCards;

      // Expose current filter state for sibling sections (e.g., Equity curve)
      function getCurrentFilters() {
        const daysSel = seg.getAttribute('data-selected') || 'ALL';
        return {
          daysSel,
          selectedDOW: new Set(Array.from(selectedDOW || [])),
          selectedMonths: new Set(Array.from(selectedMonths || [])),
        };
      }
      // Attach to summary element
      summaryEl.getCurrentFilters = getCurrentFilters;

  // Make monthly section reference available before selection handler so we can refresh it on card click
  let monthlySection; // assigned later when building the monthly detail table

      // init to ALL
      const initBtn = seg.querySelector('button[data-days="ALL"]');
      setActive(initBtn);
      rebuildSummaryCards();

      seg.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-days]');
        if (!btn) return;
        setActive(btn);
        rebuildSummaryCards();
  // Notify listeners that filters changed
  summaryEl.dispatchEvent(new CustomEvent('filters-changed', { bubbles: false }));
      });

      // Weekday multi-select
      if (weekdaySegment) {
        weekdaySegment.addEventListener('click', (e) => {
          const b = e.target.closest('button[data-dow]');
          if (!b) return;
          const v = parseInt(b.getAttribute('data-dow'), 10);
          if (selectedDOW.has(v)) { selectedDOW.delete(v); toggleWeekdayBtn(b, false); }
          else { selectedDOW.add(v); toggleWeekdayBtn(b, true); }
          rebuildSummaryCards();
          summaryEl.dispatchEvent(new CustomEvent('filters-changed', { bubbles: false }));
        });
      }

  // Click a summary tile to toggle selection and update the equity curve selectors
      cardsContainer.addEventListener('click', (e) => {
        const card = e.target.closest('button[data-orb][data-r]');
        if (!card) return;
        const orb = String(card.getAttribute('data-orb'));
        const r = String(card.getAttribute('data-r'));
  const defaultDir = currentDirection || 'BOTH';
  const defaultSym = currentTicker || '';
  const key = comboKey(orb, r, defaultDir, defaultSym);
    // Toggle selection WITHOUT auto rebalancing; allow allocations >100
        const wasSelected = selectedCombos.has(key);
        if (wasSelected) {
          selectedCombos.delete(key);
          comboDirectionOverrides.delete(key);
          comboAllocationOverrides.delete(key);
        } else {
          selectedCombos.add(key);
          if (!comboDirectionOverrides.has(key)) comboDirectionOverrides.set(key, defaultDir);
          // Allocation default policy: every newly added strategy starts at 100% (can exceed 100 total for leverage)
          if (!comboAllocationOverrides.has(key)) {
            comboAllocationOverrides.set(key, 100);
          }
        }
    // Rebuild cards to reflect selection state
    rebuildSummaryCards();
    // Update selected section, if present
    if (typeof summaryEl.refreshSelected === 'function') summaryEl.refreshSelected();
  // Notify equity section
  try { summaryEl.dispatchEvent(new CustomEvent('selection-changed', { bubbles: false })); } catch {}
        const orbSel = document.getElementById('eqOrbSelect');
        const rSel = document.getElementById('eqRSelect');
        if (!orbSel || !rSel) return;
        // Set orb and trigger change to repopulate R options
        if (Array.from(orbSel.options).some(o => o.value === orb)) {
          orbSel.value = orb;
          orbSel.dispatchEvent(new Event('change', { bubbles: true }));
        }
        // Set target_R if available after repopulation
        if (Array.from(rSel.options).some(o => o.value === r)) {
          rSel.value = r;
          rSel.dispatchEvent(new Event('change', { bubbles: true }));
        }
        // Also force monthly detail table to switch to this orb immediately
        if (monthlySection && typeof renderMonthlyDetail === 'function') {
          try { renderMonthlyDetail(Number(orb)); } catch {}
        }
      });

  // --- NEW: Equity curve section (below Totals summary) ---
  renderEquitySection(model, combosByOrb, summaryEl);

  // --- NEW: Selected strategies with combined equity ---
  const selectedUI = renderSelectedSection(model, combosByOrb, summaryEl);
  // Expose refresher so card clicks and other events can trigger redraw
  summaryEl.refreshSelected = selectedUI && selectedUI.refresh ? selectedUI.refresh : () => {};

  // Monthly total returns section removed as requested

  // Single monthly detail table for the currently selected orb_m
  monthlySection = document.createElement('section');
  monthlySection.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6';
  output.appendChild(monthlySection);

      function renderMonthlyDetail(orb) {
        const table = byOrb.get(Number(orb));
        if (!table) { monthlySection.innerHTML = ''; return; }
        const eqRSel = document.getElementById('eqRSelect');
        let activeR = undefined;
        if (eqRSel && eqRSel.value !== '') {
          const v = Number(eqRSel.value);
          if (Number.isFinite(v) && table.targets.includes(v)) activeR = v;
        }
        const headerHTML = `<div class="flex items-center justify-between mb-4">
            <div>
              <h2 class="text-xl font-semibold">orb_m = ${orb}</h2>
              <p class="text-sm text-slate-600">Monthly sum of daily R by target_R</p>
            </div>
            <button class="inline-flex items-center rounded-xl px-3 py-2 text-sm font-medium bg-slate-100 hover:bg-slate-200" data-download="${orb}">Download CSV</button>
          </div>`;
        const tableHTML = `<div class="overflow-auto rounded-xl border border-slate-200">${buildTableHTML(table, monthsSorted, activeR)}</div>`;
        monthlySection.innerHTML = headerHTML + tableHTML;
        const btn = monthlySection.querySelector('button[data-download]');
        if (btn) {
          btn.addEventListener('click', () => {
            const o = Number(btn.getAttribute('data-download'));
            const tbl = byOrb.get(o);
            const csv = tableToCSV(tbl, monthsSorted, o);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `monthly_orb_${o}.csv`;
            a.click();
            URL.revokeObjectURL(url);
          });
        }
      }

      // Initial render for the active orb (from equity selector or the first orb)
      const eqOrbSelForMonthly = document.getElementById('eqOrbSelect');
      let initialOrb;
      if (eqOrbSelForMonthly && eqOrbSelForMonthly.value !== '') {
        const v = Number(eqOrbSelForMonthly.value);
        initialOrb = Number.isFinite(v) ? v : undefined;
      }
      if (!Number.isFinite(initialOrb)) {
        const firstOrb = Array.from(byOrb.keys()).sort((a,b)=>a-b)[0];
        initialOrb = firstOrb;
      }
      renderMonthlyDetail(initialOrb);

      // Update when equity orb or R selection changes
      if (eqOrbSelForMonthly) {
        eqOrbSelForMonthly.addEventListener('change', () => renderMonthlyDetail(Number(eqOrbSelForMonthly.value)));
      }
      const eqRSelForMonthly = document.getElementById('eqRSelect');
      if (eqRSelForMonthly) {
        eqRSelForMonthly.addEventListener('change', () => {
          const currentOrb = (eqOrbSelForMonthly ? Number(eqOrbSelForMonthly.value) : initialOrb);
          renderMonthlyDetail(currentOrb);
        });
      }

  // --- NEW: Last X days section at the very end (linked to Totals filters) ---
  renderLastDaysSection(model, combosByOrb, ticker, summaryEl);
    }

    // Compute totals by last N days from the raw daily data
    function computeTotalsByDays(model, combosByOrb, daysSel, naMode, selectedDOW, selectedMonths) {
      const times = Array.from(new Set(model.data.map(d => d.date.getTime()))).sort((a,b) => a - b);
      const allowedTimes = (daysSel === 'ALL') ? times : times.slice(-Math.max(0, parseInt(daysSel,10)));
      const allowed = new Set(allowedTimes);
      // Prepare weekday filter: if selectedDOW is provided, it's an active filter even if empty
      const hasDowFilter = selectedDOW instanceof Set;
      const selectedNone = hasDowFilter && selectedDOW.size === 0;
      const isAllowedDow = (dateObj) => {
        if (!hasDowFilter) return true;
        if (selectedNone) return false; // no weekdays allowed
        const jsDay = dateObj.getDay(); // 0 Sun .. 6 Sat
        const mapped = jsDay === 0 ? 7 : jsDay; // 1..7, with Sun=7
        if (mapped === 6 || mapped === 7) return false; // exclude weekends just in case
        return selectedDOW.has(mapped);
      };
      // Prepare month filter
      const hasMonthFilter = selectedMonths instanceof Set && selectedMonths.size > 0;
      const result = new Map(); // orb -> Map(target_R -> total|null)

      for (const [orb, arr] of combosByOrb.entries()) {
        const rmap = new Map();
        for (const { target_R, key } of arr) {
          let sum = 0; let used = 0;
          for (const row of model.data) {
            const t = row.date.getTime();
            if (!allowed.has(t)) continue;
            if (!isAllowedDow(row.date)) continue;
            if (hasMonthFilter && !selectedMonths.has(row.yyyymm)) continue;
            const v = row[key];
            if (v === null || !Number.isFinite(v)) {
              if (naMode === 'zero') { sum += 0; used++; }
              continue;
            }
            sum += v; used++;
          }
          // If no rows used, return 0 only when user explicitly selected no weekdays; otherwise null
          rmap.set(target_R, used === 0 ? (selectedNone ? 0 : null) : sum);
        }
        result.set(orb, rmap);
      }
      return result;
    }

    // --- NEW: Equity curve rendering using Plotly ---
  function renderEquitySection(model, combosByOrb, mountAfterEl) {
      // Build container under the summary section
  const section = document.createElement('section');
  section.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6 mt-4 overflow-hidden';
      section.innerHTML = `
        <div class="flex items-center justify-between gap-3 flex-wrap mb-3">
          <h2 class="text-lg font-semibold">Combined equity curve (daily compounding)</h2>
          <div class="hidden items-center gap-3">
            <label class="text-sm text-slate-600">orb_m:</label>
            <div class="relative inline-block">
              <select id="eqOrbSelect" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 pr-9 text-sm"></select>
              <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
            <label class="text-sm text-slate-600">target_R:</label>
            <div class="relative inline-block">
              <select id="eqRSelect" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 pr-9 text-sm"></select>
              <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
          </div>
        </div>
        <div id="equityAssumption" class="text-xs text-slate-500 mb-2">Assumes starting balance of $100,000 and uses selected strategies (Direction and Allocation) with 1R = 1% when Risk=2% and stop=2R.</div>
        <div id="equityChart" class="w-full min-h-[320px]"></div>
        <div class="mt-6">
          <h3 class="text-base font-semibold mb-2">Combined win/loss streaks (by day)</h3>
          <div id="streakChart" class="w-full min-h-[260px]"></div>
        </div>
      `;
  // Insert right after the provided element (summary section)
  mountAfterEl.parentNode.insertBefore(section, mountAfterEl.nextSibling);

      // Compute combined equity from current selection (allocations + per-row direction)
      function computeCombinedEquity(){
        const sel = Array.from(selectedCombos).map(parseComboKey).filter(Boolean);
        const chartEl = section.querySelector('#equityChart');
        if (!sel.length) {
          return { x: [], y: [] };
        }
        // Build merged date map across involved directions
        const dateMap = new Map(); // iso -> array of {mdl,row}
        const mdlSet = new Set();
        for (const { orb, r, dir: preDir, sym: preSym } of sel) {
          const d = comboDirectionOverrides.get(comboKey(orb, r, preDir, preSym)) || preDir || currentDirection || 'BOTH';
          const s = (preSym || currentTicker || '').toUpperCase();
          const mdl = getModelCache(s, d) || model;
          if (!mdl || mdlSet.has(mdl)) continue;
          mdlSet.add(mdl);
          const rowsSorted = [...mdl.data].sort((a,b)=> a.date - b.date);
          for (const r of rowsSorted) {
            const iso = r.date.toISOString().slice(0,10);
            if (!dateMap.has(iso)) dateMap.set(iso, []);
            dateMap.get(iso).push({ row: r, mdl });
          }
        }
        const allDates = Array.from(dateMap.keys()).sort();
        const naMode = document.getElementById('naSelect').value;
        const rToPct = getRiskPct();
        const getFilters = (mountAfterEl && typeof mountAfterEl.getCurrentFilters === 'function') ? mountAfterEl.getCurrentFilters : null;
        const { daysSel, selectedDOW, selectedMonths } = getFilters ? getFilters() : { daysSel: 'ALL', selectedDOW: new Set([1,2,3,4,5]), selectedMonths: new Set() };
        const allowedDates = (daysSel === 'ALL') ? allDates : allDates.slice(-Math.max(0, parseInt(daysSel,10)));
        const allowed = new Set(allowedDates);
        const hasDowFilter = selectedDOW instanceof Set;
        const selectedNone = hasDowFilter && selectedDOW.size === 0;
        const isAllowedDow = (isoStr) => {
          if (!hasDowFilter) return true;
          if (selectedNone) return false;
          const d = new Date(isoStr);
          const jsDay = d.getDay();
          const mapped = jsDay === 0 ? 7 : jsDay;
          if (mapped === 6 || mapped === 7) return false;
          return selectedDOW.has(mapped);
        };
        const hasMonthFilter = selectedMonths instanceof Set && selectedMonths.size > 0;
        const x = [];
        const y = [];
        const start = 100000;
        const subs = sel.map(({orb,r,dir: preDir, sym: preSym}) => {
          const k = comboKey(orb, r, preDir, preSym);
          const dir = comboDirectionOverrides.get(k) || preDir || currentDirection || 'BOTH';
          const sym = (preSym || currentTicker || '').toUpperCase();
          const mdl = getModelCache(sym, dir) || model;
          const allocPct = (comboAllocationOverrides.get(k) ?? 0) / 100;
          return { orb, r, k, dir, mdl, allocPct, equity: start * allocPct };
        });
        const idleAlloc = Math.max(0, 1 - subs.reduce((a,s) => a + s.allocPct, 0));
        let cash = start * idleAlloc;
        for (const iso of allDates) {
          if (!allowed.has(iso)) continue;
          if (!isAllowedDow(iso)) continue;
          const yyyymm = iso.slice(0,7);
          if (hasMonthFilter && !selectedMonths.has(yyyymm)) continue;
          const perDayRows = dateMap.get(iso) || [];
          let anyUsed = false;
          for (const s of subs) {
            if (s.allocPct <= 0) continue;
            const rowEntry = perDayRows.find(rr => rr.mdl === s.mdl);
            const row = rowEntry ? rowEntry.row : null;
            if (!row) continue;
            let v = row[`m${s.orb}_r${s.r}`];
            if (v === null || !Number.isFinite(v)) {
              if (naMode === 'zero') { v = 0; } else { continue; }
            }
            const pct = v * rToPct;
            s.equity = s.equity * (1 + pct);
            anyUsed = true;
          }
          if (!anyUsed) continue;
          const totalEq = cash + subs.reduce((acc, s) => acc + s.equity, 0);
          x.push(iso);
          y.push(totalEq);
        }
        return { x, y };
      }

      function fmtPct(p){
        if (p === null || p === undefined || !Number.isFinite(p)) return '—';
        return (p * 100).toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 }) + '%';
      }

      function computeStatsFromSeries(x, y){
        if (!y || y.length < 2) return { cagr: null, maxDD: null, winPct: null, winsCount: 0, lossesCount: 0 };
        const startVal = y[0];
        const endVal = y[y.length - 1];
        const parse = (s) => new Date(s.replace(/\//g,'-'));
        const startDate = parse(x[0]);
        const endDate = parse(x[x.length - 1]);
        const years = (endDate - startDate) / (365.25 * 24 * 3600 * 1000);
        const cagr = (years > 0 && startVal > 0) ? Math.pow(endVal / startVal, 1 / years) - 1 : null;
        // Max Drawdown
        let peak = -Infinity; let maxDD = 0; // negative number like -0.25 for -25%
        for (const v of y) {
          if (v > peak) peak = v;
          const dd = (v / peak) - 1;
          if (dd < maxDD) maxDD = dd;
        }
        // Win percentage: wins / (wins + losses), ignore 0 and NaN
        let wins = 0, losses = 0;
        for (let i = 1; i < y.length; i++) {
          const prev = y[i-1];
          const curr = y[i];
          if (!Number.isFinite(prev) || !Number.isFinite(curr) || prev === 0) continue;
          const r = curr / prev - 1;
          if (!Number.isFinite(r) || r === 0) continue;
          if (r > 0) wins++; else if (r < 0) losses++;
        }
        const total = wins + losses;
        const winPct = total > 0 ? (wins / total) : null;
        return { cagr, maxDD, winPct, winsCount: wins, lossesCount: losses };
      }

      // Compute combined win/loss streaks from equity series returns
      function computeCombinedStreakSeries(xDates, yEq){
        const x = [];
        const y = [];
        const colors = [];
        const texts = [];
        if (!yEq || yEq.length < 2) return { x, y, colors, texts };
        let streak = 0; // signed
        let runSign = 0;
        let runBest = 0;
        let runBestIdx = -1;
        const flushRun = () => {
          if (runSign !== 0 && runBest > 0 && runBestIdx >= 0) {
            const iso = xDates[runBestIdx];
            x.push(iso);
            const val = runSign > 0 ? runBest : -runBest;
            y.push(val);
            if (val > 0) { colors.push('#10b981'); texts.push(`Win streak: ${val}`); }
            else { colors.push('#f43f5e'); texts.push(`Loss streak: ${Math.abs(val)}`); }
          }
          runSign = 0; runBest = 0; runBestIdx = -1; streak = 0;
        };
        for (let i = 1; i < yEq.length; i++) {
          const prev = yEq[i-1];
          const curr = yEq[i];
          if (!Number.isFinite(prev) || !Number.isFinite(curr) || prev <= 0) { flushRun(); continue; }
          const r = curr / prev - 1;
          let sgn = 0;
          if (r > 0) sgn = 1; else if (r < 0) sgn = -1; else sgn = 0;
          if (sgn === 0) { flushRun(); continue; }
          if (runSign === 0 || sgn !== runSign) {
            flushRun();
            runSign = sgn;
            streak = 1;
            runBest = 1;
            runBestIdx = i;
          } else {
            streak += 1;
            if (streak >= runBest) { runBest = streak; runBestIdx = i; }
          }
        }
        flushRun();
        return { x, y, colors, texts };
      }

  function draw(){
        const { x, y } = computeCombinedEquity();
  const { cagr, maxDD, winPct, winsCount, lossesCount } = computeStatsFromSeries(x, y);
  const annText = `CAGR ${fmtPct(cagr)}<br>MaxDD ${fmtPct(maxDD)}<br>Win% ${fmtPct(winPct)}<br>Win/Loss: ${winsCount}/${lossesCount}`;
        const blurb = section.querySelector('#equityAssumption');
  if (blurb) blurb.textContent = `Assumes starting balance of $100,000 and treats daily R value as percentage return (1R = ${(getRiskPct()*100).toFixed(1)}%). Allocation total may exceed 100% (leveraged notional).`;
        const layout = {
          height: 340,
          margin: { l: 50, r: 20, t: 10, b: 40 },
          xaxis: { title: 'Date', type: 'date', tickformat: '%Y-%m', ticklabelmode: 'period', nticks: 8, automargin: true },
          yaxis: { title: 'Equity ($)', hoverformat: ',.2f' },
          hovermode: 'x unified',
          template: 'plotly_white',
          annotations: [{
            xref: 'paper', yref: 'paper', x: 1, y: 0.06, xanchor: 'right', yanchor: 'bottom', showarrow: false,
            text: annText,
            align: 'right',
            font: { color: '#334155', size: 12 },
            bgcolor: 'rgba(148,163,184,0.12)', // slate-400 at low alpha
            bordercolor: '#cbd5e1', borderwidth: 1, borderpad: 4
          }]
        };
        const data = [{
          x, y,
          type: 'scatter', mode: 'lines',
          line: { color: '#059669', width: 2 },
          hovertemplate: '%{x|%Y-%m-%d}<br>$%{y:,.2f}<extra></extra>'
        }];
  Plotly.react(section.querySelector('#equityChart'), data, layout, { responsive: true, displaylogo: false });

        // Draw streak chart
  const { x: sx, y: sy, colors: sc, texts: st } = computeCombinedStreakSeries(x, y);
        const sLayout = {
          height: 280,
          margin: { l: 50, r: 20, t: 10, b: 40 },
          xaxis: { title: 'Date', type: 'date', tickformat: '%Y-%m', ticklabelmode: 'period', nticks: 8, automargin: true },
          yaxis: { title: 'Streak (days)', zeroline: true, dtick: 1 },
          template: 'plotly_white'
        };
        const sData = [{
          x: sx,
          y: sy,
          type: 'bar',
          marker: { color: sc },
          text: st,
          hovertemplate: '%{x|%Y-%m-%d}<br>%{text}<extra></extra>'
        }];
        Plotly.react(section.querySelector('#streakChart'), sData, sLayout, { responsive: true, displaylogo: false });
      }

      // Initial draw
      draw();

      // Redraw when Totals filters change
      if (mountAfterEl) {
        mountAfterEl.addEventListener('filters-changed', draw);
        // Redraw on selection changes
        mountAfterEl.addEventListener('selection-changed', draw);
      }
      // Redraw when risk percent changes
      const riskEl = document.getElementById('riskInput');
      if (riskEl) riskEl.addEventListener('input', draw);
    }

    // --- NEW: Selected strategies table + Combined equity curve ---
  function renderSelectedSection(model, combosByOrb, mountAfterEl){
      const section = document.createElement('section');
      section.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6 mt-4 overflow-hidden';
      section.innerHTML = `
        <div class="flex items-center justify-between gap-3 flex-wrap mb-3">
          <h2 class="text-lg font-semibold">Selected strategies</h2>
          <div class="flex items-center gap-3 text-sm">
            <span id="selCount" class="text-slate-600">0 selected</span>
            <span id="allocTotal" class="text-slate-600">Alloc: 0%</span>
            <button id="selExportBtn" type="button" class="inline-flex items-center rounded-xl px-3 py-1.5 text-sm font-medium bg-emerald-600 text-white hover:bg-emerald-700">Export</button>
            <button id="selClearBtn" type="button" class="inline-flex items-center rounded-xl px-3 py-1.5 text-sm font-medium bg-slate-100 hover:bg-slate-200">Clear</button>
          </div>
        </div>
    <div class="overflow-auto rounded-xl border border-slate-200 mb-4">
          <table class="min-w-full text-sm">
            <thead class="bg-slate-50"><tr>
              <th class="sticky-th text-left font-semibold px-3 py-2 border-b border-slate-200">Symbol</th>
              <th class="sticky-th text-left font-semibold px-3 py-2 border-b border-slate-200">orb_m</th>
              <th class="sticky-th text-left font-semibold px-3 py-2 border-b border-slate-200">target_R</th>
      <th class="sticky-th text-left font-semibold px-3 py-2 border-b border-slate-200">Direction</th>
              <th class="sticky-th text-left font-semibold px-3 py-2 border-b border-slate-200">Allocation</th>
              <th class="sticky-th text-right font-semibold px-3 py-2 border-b border-slate-200">Total (R)</th>
              <th class="sticky-th text-right font-semibold px-3 py-2 border-b border-slate-200">Actions</th>
            </tr></thead>
            <tbody id="selTBody"></tbody>
          </table>
  </div>
  <div class="mb-2 text-xs text-slate-500">Combined equity (above) uses the selected strategies, their Directions, and Allocations. Adjust rows here to update the chart.</div>
      `;
      // Insert after mountAfterEl (summary)
      mountAfterEl.parentNode.insertBefore(section, mountAfterEl.nextSibling);

    const tbody = section.querySelector('#selTBody');
    const countEl = section.querySelector('#selCount');
  const clearBtn = section.querySelector('#selClearBtn');
  const exportBtn = section.querySelector('#selExportBtn');
  const allocTotalEl = section.querySelector('#allocTotal');
      const emitSelectionChanged = () => { try { mountAfterEl && mountAfterEl.dispatchEvent(new CustomEvent('selection-changed', { bubbles: false })); } catch {} };

      function getValidSelection(){
        // Allow selections from any direction; defer availability to per-row direction/model
        const res = [];
        selectedCombos.forEach(k => { const pr = parseComboKey(k); if (pr) res.push(pr); });
        return res;
      }

      function drawTable(){
        const sel = getValidSelection();
        if (countEl) countEl.textContent = `${sel.length} selected`;
        const naMode = document.getElementById('naSelect').value;
        // Read filters from Totals
        const getFilters = (mountAfterEl && typeof mountAfterEl.getCurrentFilters === 'function') ? mountAfterEl.getCurrentFilters : null;
        const { daysSel, selectedDOW, selectedMonths } = getFilters ? getFilters() : { daysSel: 'ALL', selectedDOW: new Set([1,2,3,4,5]), selectedMonths: new Set() };
        // Ensure any new selection gets a default allocation (100 if only one total selection, else 0). No normalization.
        const missing = sel.filter(({orb,r,dir,sym}) => !comboAllocationOverrides.has(comboKey(orb,r,dir,sym)));
        if (missing.length) {
          missing.forEach(({orb,r,dir,sym}) => {
            comboAllocationOverrides.set(comboKey(orb,r,dir,sym), 100);
          });
        }
        // Compute totals per selection respecting per-row direction
        const rows = sel.map(({orb, r, dir: preDir, sym: preSym}) => {
          const k0 = comboKey(orb, r, preDir, preSym);
          const dir = comboDirectionOverrides.get(k0) || preDir || currentDirection || 'BOTH';
          const sym = (preSym || currentTicker || '').toUpperCase();
          const mdl = getModelCache(sym, dir) || model;
          const cByOrb = getCombosByOrbCache(sym, dir) || combosByOrb;
          const totals = computeTotalsByDays(mdl, cByOrb, daysSel, naMode, selectedDOW, selectedMonths);
          const rmap = totals.get(Number(orb)) || new Map();
          const total = rmap.has(Number(r)) ? rmap.get(Number(r)) : null;
          const alloc = comboAllocationOverrides.get(k0) ?? 0;
          return { sym, orb, r, total, dir, alloc, key: k0 };
        }).sort((a,b) => (b.total ?? -Infinity) - (a.total ?? -Infinity));

        // Update allocation total display
        const totalAlloc = rows.reduce((acc, row) => acc + (Number(row.alloc)||0), 0);
        if (allocTotalEl) allocTotalEl.textContent = `Alloc: ${Math.round(totalAlloc)}%`;

        tbody.innerHTML = rows.map(row => {
          const k = row.key;
          const val = row.total === null ? '—' : fmt(row.total);
          const cls = row.total === null ? '' : (row.total >= 0 ? 'num-pos' : 'num-neg');
          return `<tr class="odd:bg-white even:bg-slate-50/50">
            <td class="px-3 py-2">${row.sym || ''}</td>
            <td class="px-3 py-2">${row.orb}</td>
            <td class="px-3 py-2">${row.r}</td>
            <td class="px-3 py-2">
              <div class="relative inline-block">
                <select data-k="${k}" class="sel-dir appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-lg px-2 py-1 text-xs pr-7">
                  <option value="BOTH" ${row.dir==='BOTH'?'selected':''}>BOTH</option>
                  <option value="LONG" ${row.dir==='LONG'?'selected':''}>LONG</option>
                  <option value="SHORT" ${row.dir==='SHORT'?'selected':''}>SHORT</option>
                </select>
                <span class="pointer-events-none absolute right-1.5 top-1/2 -translate-y-1/2 text-slate-500">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
                </span>
              </div>
            </td>
            <td class="px-3 py-2">
              <div class="relative inline-flex items-center gap-1">
                <input type="number" min="0" max="100" step="0.1" data-k="${k}" class="sel-alloc appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-lg px-2 py-1 text-xs w-20 text-right" value="${Number(row.alloc).toFixed(1)}" />
                <span class="text-xs text-slate-500">%</span>
              </div>
            </td>
            <td class="px-3 py-2 text-right ${cls}">${val}</td>
            <td class="px-3 py-2 text-right">
              <button type="button" data-k="${k}" class="inline-flex items-center rounded-lg px-2 py-1 text-xs bg-rose-50 text-rose-700 border border-rose-200 hover:bg-rose-100">Remove</button>
            </td>
          </tr>`;
        }).join('');

        // Wire remove buttons
  tbody.querySelectorAll('button[data-k]').forEach(btn => {
          btn.addEventListener('click', () => {
            const k = btn.getAttribute('data-k');
            if (selectedCombos.has(k)) selectedCombos.delete(k);
            drawTable();
            // Also refresh cards highlight
            if (mountAfterEl && typeof mountAfterEl.refreshCards === 'function') {
              try { mountAfterEl.refreshCards(); } catch {}
            }
            emitSelectionChanged();
          });
        });

        // Wire direction change handlers
    tbody.querySelectorAll('select.sel-dir[data-k]').forEach(selEl => {
          selEl.addEventListener('change', async () => {
            const k = selEl.getAttribute('data-k');
            const dir = selEl.value || 'BOTH';
            comboDirectionOverrides.set(k, dir);
            // If the key encoded old dir, update selection key to track new direction
            const parsed = parseComboKey(k);
            if (parsed) {
              const newKey = comboKey(parsed.orb, parsed.r, dir, parsed.sym);
              if (newKey !== k) {
                if (selectedCombos.has(k)) selectedCombos.delete(k);
                selectedCombos.add(newKey);
                // migrate allocation override if present
                if (comboAllocationOverrides.has(k)) {
                  comboAllocationOverrides.set(newKey, comboAllocationOverrides.get(k));
                  comboAllocationOverrides.delete(k);
                }
                comboDirectionOverrides.delete(k);
                comboDirectionOverrides.set(newKey, dir);
              }
            }
      // Ensure the required model is loaded/cached for this row's symbol+direction
      const rowSym = (parsed && parsed.sym) ? parsed.sym : currentTicker;
      try { await ensureModelFor(rowSym, dir); } catch {}
      // Refresh totals and notify equity to update
      drawTable();
      emitSelectionChanged();
          });
        });

        // Wire allocation change handlers
        tbody.querySelectorAll('input.sel-alloc[data-k]').forEach(inp => {
          const clamp = (v) => Math.max(0, Math.min(100, v));
          inp.addEventListener('change', () => {
            const k = inp.getAttribute('data-k');
            const v = parseFloat(inp.value);
            const num = Number.isFinite(v) ? clamp(v) : 0;
            comboAllocationOverrides.set(k, num);
            inp.value = num.toFixed(1);
            drawTable();
            emitSelectionChanged();
          });
          inp.addEventListener('input', () => {
            // live update totals display
            const k = inp.getAttribute('data-k');
            const v = parseFloat(inp.value);
            const num = Number.isFinite(v) ? clamp(v) : 0;
            comboAllocationOverrides.set(k, num);
            if (allocTotalEl) {
              const sel2 = getValidSelection();
              const sum = sel2.reduce((acc, {orb,r,dir,sym}) => acc + (comboAllocationOverrides.get(comboKey(orb,r,dir,sym))||0), 0);
              allocTotalEl.textContent = `Alloc: ${Math.round(sum)}%`;
            }
            emitSelectionChanged();
          });
        });
      }
      function refresh(){ drawTable(); emitSelectionChanged(); }

      // Wire clear button
      if (clearBtn) clearBtn.addEventListener('click', () => {
        selectedCombos.clear();
        comboDirectionOverrides.clear();
        comboAllocationOverrides.clear();
        refresh();
        if (mountAfterEl && typeof mountAfterEl.refreshCards === 'function') {
          try { mountAfterEl.refreshCards(); } catch {}
        }
        emitSelectionChanged();
      });

      // Export CSV: Date,Strategy,Return (ascending date)
      if (exportBtn) exportBtn.addEventListener('click', async () => {
        const rowsOut = [];
        // Collect per-selection data
        for (const key of selectedCombos) {
          const parsed = parseComboKey(key);
            if (!parsed) continue;
          const { orb, r, dir, sym } = parsed;
          const symU = (sym || currentTicker || '').toUpperCase();
          const dUse = dir || 'BOTH';
          // Ensure model cached
          await ensureModelFor(symU, dUse);
          const mdl = getModelCache(symU, dUse);
          if (!mdl) continue;
          const stratLabel = `${symU}_${orb}_${r}_${dUse}`;
          // Ascending dates
          const dataAsc = [...mdl.data].sort((a,b)=> a.date - b.date);
          const colKey = `m${orb}_r${r}`;
          for (const rec of dataAsc) {
            const v = rec[colKey];
            if (v === null || !Number.isFinite(v)) continue; // skip NAs
            const iso = rec.date.toISOString().slice(0,10);
            rowsOut.push({ date: iso, strat: stratLabel, ret: v });
          }
        }
        if (!rowsOut.length) {
          alert('No data to export.');
          return;
        }
        // Sort by date ascending then strategy
        rowsOut.sort((a,b)=> a.date.localeCompare(b.date) || a.strat.localeCompare(b.strat));
        const header = 'Date,Strategy,Return';
        const lines = rowsOut.map(r => `${r.date},${r.strat},${r.ret}`);
        const csv = [header, ...lines].join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'selected_strategies.csv';
        a.click();
        URL.revokeObjectURL(url);
      });

      // Redraw on Totals filter changes and risk changes
  if (mountAfterEl) mountAfterEl.addEventListener('filters-changed', refresh);
      const riskEl = document.getElementById('riskInput');
  if (riskEl) riskEl.addEventListener('input', refresh);

      // Initial draw
      refresh();
      return { refresh };
    }

    function cardHTML(c) {
      const cls = c.total === null ? 'text-slate-400' : (c.total >= 0 ? 'num-pos' : 'num-neg');
      const val = c.total === null ? '—' : fmt(c.total);
      return `<div class="rounded-2xl border border-slate-200 p-4 ${c._bg ? c._bg : ''}">
        <div class="text-xs text-slate-500">orb_m ${c.orb} · R ${c.r}</div>
        <div class="text-2xl font-semibold ${cls}">${val}</div>
      </div>`;
    }

    function buildTableHTML(tbl, months, activeR) {
      const cols = tbl.targets;

      // --- Column-wise extremes for independent scaling per target_R ---
      const colMaxPos = new Map(); // R -> max positive monthly value
      const colMaxNegAbs = new Map(); // R -> max absolute negative monthly value
      for (const r of cols) {
        let maxPos = 0;
        let maxNegAbs = 0;
        for (const m of months) {
          const v = tbl.rows.find(x => x.month === m)?.vals.get(r) ?? null;
          if (v === null || !Number.isFinite(v)) continue;
          if (v > 0 && v > maxPos) maxPos = v;
          if (v < 0 && Math.abs(v) > maxNegAbs) maxNegAbs = Math.abs(v);
        }
        colMaxPos.set(r, maxPos);
        colMaxNegAbs.set(r, maxNegAbs);
      }

      const shadeGreen = (ratio) => {
        if (ratio > 0.8) return 'bg-emerald-400';
        if (ratio > 0.6) return 'bg-emerald-300';
        if (ratio > 0.4) return 'bg-emerald-200';
        if (ratio > 0.2) return 'bg-emerald-100';
        return 'bg-emerald-50';
      };
      const shadeRed = (ratio) => {
        // Increase minimum shade to >= 150 by flooring at rose-200
        if (ratio > 0.8) return 'bg-rose-400';
        if (ratio > 0.5) return 'bg-rose-300';
        return 'bg-rose-200';
      };

      let html = '<table class="min-w-full text-sm">';
      html += '<thead class="bg-slate-50"><tr>';
      html += '<th class="sticky-th text-left font-semibold px-3 py-2 border-b border-slate-200">Month</th>';
      for (const r of cols) {
        const hCls = (activeR !== undefined && Number(activeR) === Number(r)) ? ' col-active-header' : '';
        html += `<th class="sticky-th text-right font-semibold px-3 py-2 border-b border-slate-200${hCls}">R ${r}</th>`;
      }
      html += '</tr></thead><tbody>';

      for (const m of months) {
        html += '<tr class="odd:bg-white even:bg-slate-50/50">';
        html += `<td class="px-3 py-2 whitespace-nowrap">${m}</td>`;
        for (const r of cols) {
          const v = tbl.rows.find(x => x.month === m)?.vals.get(r) ?? null;
          const maxPos = colMaxPos.get(r) || 0;
          const maxNegAbs = colMaxNegAbs.get(r) || 0;

          let bgCls = '';
          let textCls = '';
          if (v !== null && Number.isFinite(v)) {
            if (v > 0 && maxPos > 0) {
              const ratio = Math.max(0, Math.min(1, v / maxPos));
              bgCls = shadeGreen(ratio);
              textCls = ratio > 0.8 ? 'text-white' : 'num-pos';
            } else if (v < 0 && maxNegAbs > 0) {
              const ratio = Math.max(0, Math.min(1, Math.abs(v) / maxNegAbs));
              bgCls = shadeRed(ratio);
              textCls = ratio > 0.8 ? 'text-white' : 'num-neg';
            } else if (v === 0) {
              textCls = 'text-slate-600';
            }
          } else {
            textCls = 'text-slate-400';
          }

          const aCls = (activeR !== undefined && Number(activeR) === Number(r)) ? ' col-active-cell' : '';
          html += `<td class="px-3 py-2 text-right ${textCls} ${bgCls}${aCls}">${v === null ? '—' : fmt(v)}</td>`;
        }
        html += '</tr>';
      }

      // Totals row
      html += '<tr class="bg-slate-100 font-semibold">';
      html += '<td class="px-3 py-2">Total</td>';
      for (const r of cols) {
        let total = 0; let has = false;
        for (const row of tbl.rows) { const v = row.vals.get(r); if (v !== null && Number.isFinite(v)) { total += v; has = true; } }
        const aCls = (activeR !== undefined && Number(activeR) === Number(r)) ? ' col-active-cell' : '';
        html += `<td class="px-3 py-2 text-right ${has ? (total>=0?'num-pos':'num-neg') : ''}${aCls}">${has ? fmt(total) : '—'}</td>`;
      }
      html += '</tr>';

      // Wins row: count of winning and losing months per target_R (ignore zeros/nulls)
      html += '<tr class="bg-slate-50">';
      html += '<td class="px-3 py-2">Wins</td>';
      for (const r of cols) {
        let wins = 0; let losses = 0;
        for (const row of tbl.rows) {
          const v = row.vals.get(r);
          if (v === null || !Number.isFinite(v)) continue;
          if (v > 0) wins++; else if (v < 0) losses++;
        }
        const denom = wins + losses;
        const pct = denom > 0 ? Math.round((wins / denom) * 100) : null;
        const aCls = (activeR !== undefined && Number(activeR) === Number(r)) ? ' col-active-cell' : '';
        const text = denom > 0 ? `${wins}/${losses} (${pct}%)` : '—';
        html += `<td class="px-3 py-2 text-right${aCls}">${text}</td>`;
      }
      html += '</tr>';

      html += '</tbody></table>';
      return html;
    }

    function tableToCSV(tbl, months, orb) {
      const header = ['month', ...tbl.targets.map(r => `orb_${orb}_R_${r}`)];
      const rows = [header.join(',')];
      for (const m of months) {
        const vals = tbl.targets.map(r => {
          const v = tbl.rows.find(x => x.month === m)?.vals.get(r) ?? null;
          return v === null ? '' : v;
        });
        rows.push([m, ...vals].join(','));
      }
      const totals = tbl.targets.map(r => {
        let t = 0; let has = false;
        for (const row of tbl.rows) { const v = row.vals.get(r); if (v !== null && Number.isFinite(v)) { t += v; has = true; } }
        return has ? t : '';
      });
      rows.push(['TOTAL', ...totals].join(','));
      return rows.join('\n'); // fixed newline delimiter
    }

    function fmtMonthDisplay(ym) {
      // ym in 'YYYY-MM' -> 'MM/YYYY'
      if (!ym) return '';
      const [y, m] = ym.split('-');
      return `${m}/${y}`;
    }

    // highlight shade helpers
    function topShade(rank){ const shades=['bg-emerald-400','bg-emerald-300','bg-emerald-200','bg-emerald-100','bg-emerald-50']; return shades[Math.min(rank, shades.length-1)] || ''; }
    function bottomShade(rank){ const shades=['bg-rose-400','bg-rose-300','bg-rose-200','bg-rose-100','bg-rose-50']; return shades[Math.min(rank, shades.length-1)] || ''; }
    

  // --- NEW: Last 20 days section (helper) ---
  function renderLastDaysSection(model, combosByOrb, ticker, filterSourceEl) {
      const prefix = ticker ? `${ticker} - ` : '';
      const section = document.createElement('section');
      section.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6';
      section.innerHTML = `
        <div class="mb-4">
          <h2 class="text-lg font-semibold">${prefix}Last 20 days — daily R by combo</h2>
          <p class="text-sm text-slate-600">Most recent first. Each column is an <code>orb_m</code> × <code>target_R</code> combo.</p>
          <div class="mt-2 flex items-center gap-3">
            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
              <input id="lastDaysShowDataToggle" type="checkbox" class="sr-only peer" />
              <span aria-hidden="true" class="relative inline-flex h-5 w-9 rounded-full bg-slate-200 transition-colors peer-checked:bg-emerald-500 after:content-[''] after:absolute after:left-0.5 after:top-0.5 after:h-4 after:w-4 after:rounded-full after:bg-white after:shadow after:ring-1 after:ring-slate-300 after:transition-transform after:transform peer-checked:after:translate-x-4"></span>
              <span class="text-sm text-slate-700">Show Data</span>
            </label>
          </div>
        </div>
        <div class="overflow-auto rounded-xl border border-slate-200">
          <div id="lastDaysTable"></div>
        </div>
      `;
      output.appendChild(section);

      // Wire up Show Data toggle: only render the last-days table when toggled on
      (function(){
  const showToggle = section.querySelector('#lastDaysShowDataToggle');
        const lastDaysTableEl = section.querySelector('#lastDaysTable');
        const lastDaysTableWrap = lastDaysTableEl ? lastDaysTableEl.parentNode : null;
        if (!showToggle || !lastDaysTableWrap) return;

        const setShow = (on) => {
          if (showToggle) showToggle.checked = !!on;
          lastDaysTableWrap.classList.toggle('hidden', !on);
          if (on && typeof drawLastDays === 'function') {
            try { drawLastDays(); } catch (e) { /* ignore */ }
          }
        };

  // initialize (toggle starts off)
  setShow(false);

  showToggle.addEventListener('change', () => setShow(showToggle.checked));
      })();

      // Create ordered list of all combos (orb asc, R asc)
      const combos = [];
      const orbs = Array.from(combosByOrb.keys()).sort((a,b)=>a-b);
      for (const orb of orbs) {
        const arr = (combosByOrb.get(orb) || []).slice().sort((a,b)=>a.target_R - b.target_R);
        for (const { target_R, key } of arr) {
          combos.push({ orb_m: orb, target_R, key });
        }
      }

  // Optimization: by default, do not compute full filtered set; only after user changes filters
  let filtersActivated = false;

      function drawLastDays(){
        // determine active selection
        const eqOrbSel = document.getElementById('eqOrbSelect');
        const eqRSel = document.getElementById('eqRSelect');
        const activeOrb = eqOrbSel ? Number(eqOrbSel.value) : NaN;
        const activeR = eqRSel ? Number(eqRSel.value) : NaN;

        const naMode = document.getElementById('naSelect').value;
        let rows = [];
        let selectedDOW; // defined when filters are activated
        const hd = section.querySelector('h2.text-lg.font-semibold');

        if (!filtersActivated) {
          // Default: just show the most recent 20 trading days
          rows = [...model.data].sort((a,b)=> b.date - a.date).slice(0, 20);
          if (hd) { hd.textContent = `${prefix}Last 20 days — daily R by combo`; }
        } else {
          // Read Totals filters and compute filtered rows
          const getFilters = (filterSourceEl && typeof filterSourceEl.getCurrentFilters === 'function') ? filterSourceEl.getCurrentFilters : null;
          const { daysSel, selectedDOW: sdow, selectedMonths } = getFilters ? getFilters() : { daysSel: 'ALL', selectedDOW: new Set([1,2,3,4,5]), selectedMonths: new Set() };
          selectedDOW = sdow;
          const rowsAsc = [...model.data].sort((a,b)=> a.date - b.date);
          const timesAsc = Array.from(new Set(rowsAsc.map(d => d.date.getTime()))).sort((a,b)=>a-b);
          const allowedTimes = (daysSel === 'ALL') ? timesAsc : timesAsc.slice(-Math.max(0, parseInt(daysSel,10)));
          const allowed = new Set(allowedTimes);
          // Weekday filter
          const hasDowFilter = selectedDOW instanceof Set;
          const selectedNone = hasDowFilter && selectedDOW.size === 0;
          const isAllowedDow = (dateObj) => {
            if (!hasDowFilter) return true;
            if (selectedNone) return false;
            const jsDay = dateObj.getDay(); // 0..6
            const mapped = jsDay === 0 ? 7 : jsDay; // 1..7
            if (mapped === 6 || mapped === 7) return false; // exclude weekends
            return selectedDOW.has(mapped);
          };
          // Month filter
          const hasMonthFilter = selectedMonths instanceof Set && selectedMonths.size > 0;
          rows = rowsAsc.filter(r => {
            const t = r.date.getTime();
            if (!allowed.has(t)) return false;
            if (!isAllowedDow(r.date)) return false;
            if (hasMonthFilter && !selectedMonths.has(r.yyyymm)) return false;
            return true;
          }).sort((a,b)=> b.date - a.date);
          // Update heading to reflect Days filter
          if (hd) {
            const daysText = daysSel === 'ALL' ? 'All applicable days' : `Last ${daysSel} days`;
            hd.textContent = `${prefix}${daysText} — daily R by combo`;
          }
        }

        // Build table HTML
        let html = '<table class="min-w-full text-xs md:text-sm">';
        html += '<thead class="bg-slate-50"><tr>';
        html += '<th class="sticky-th text-left font-semibold px-3 py-2 border-b border-slate-200">Date</th>';
        for (const c of combos) {
          const isActiveCol = Number(c.orb_m) === activeOrb && Number(c.target_R) === activeR;
          const hCls = isActiveCol ? ' col-active-header' : '';
          html += `<th class="sticky-th text-right font-semibold px-3 py-2 border-b border-slate-200${hCls}">m ${c.orb_m} · R ${c.target_R}</th>`;
        }
        html += '</tr></thead><tbody>';

        for (const r of rows) {
          html += '<tr class="odd:bg-white even:bg-slate-50/50">';
          html += `<td class="px-3 py-2 whitespace-nowrap">${fmtDate(r.date)}</td>`;
          for (const c of combos) {
            let v = r[c.key];
            if ((v === null || !Number.isFinite(v)) && naMode === 'zero') v = 0;

            let cls = 'text-slate-400';
            let disp = '—';
            if (v !== null && Number.isFinite(v)) {
              disp = fmt(v);
              if (v > 0) cls = 'num-pos';
              else if (v < 0) cls = 'num-neg';
              else cls = 'text-slate-600';
            }
            // Highlight only positives with green background; no red backgrounds for negatives
            let bg = '';
            if (v !== null && Number.isFinite(v)) {
              if (v > 0) {
                if (v >= 2) bg = 'bg-emerald-500';
                else if (v >= 1) bg = 'bg-emerald-400';
                else bg = 'bg-emerald-300/70'; // simulate ~250 intensity
                if (bg === 'bg-emerald-500' || bg === 'bg-emerald-400') cls = 'text-white';
              } else if (v < 0) {
                // no background for negatives; keep red text only
                bg = '';
              }
            }
            // Do not highlight entire active column for body cells; only header and totals have yellow tint
            html += `<td class="px-3 py-2 text-right ${cls} ${bg}">${disp}</td>`;
          }
          html += '</tr>';
        }

        // Totals row across displayed days
        html += '<tr class="bg-slate-100 font-semibold">';
        html += '<td class="px-3 py-2">Total</td>';
        for (const c of combos) {
          let total = 0; let used = false;
          for (const r of rows) {
            let v = r[c.key];
            if (v === null || !Number.isFinite(v)) {
              if (naMode === 'zero') { v = 0; used = true; } else { continue; }
            } else {
              used = true;
            }
            total += v;
          }
          let cls = '';
          let disp = '—';
          const isActiveCol = Number(c.orb_m) === activeOrb && Number(c.target_R) === activeR;
          const aCls = isActiveCol ? ' col-active-cell' : '';
          if (used) {
            if (total > 0) cls = 'num-pos';
            else if (total < 0) cls = 'num-neg';
            else cls = 'text-slate-600';
            disp = fmt(total);
          } else {
            // If user has zero weekdays selected, show 0 to mirror Totals behavior (only when filters are active)
            if (filtersActivated && selectedDOW instanceof Set && selectedDOW.size === 0) {
              cls = 'text-slate-600';
              disp = fmt(0);
            }
          }
          html += `<td class="px-3 py-2 text-right ${cls}${aCls}">${disp}</td>`;
        }
        html += '</tr>';

        // Wins row across displayed days: wins/losses (win%) per combo; ignore zeros and NaNs
        html += '<tr class="bg-slate-50">';
        html += '<td class="px-3 py-2">Wins</td>';
        for (const c of combos) {
          let wins = 0; let losses = 0;
          for (const r of rows) {
            const v = r[c.key];
            if (v === null || !Number.isFinite(v)) continue;
            if (v > 0) wins++;
            else if (v < 0) losses++;
          }
          const denom = wins + losses;
          const pct = denom > 0 ? Math.round((wins / denom) * 100) : null;
          const text = denom > 0 ? `${wins}/${losses} (${pct}%)` : '—';
          html += `<td class="px-3 py-2 text-right">${text}</td>`;
        }
        html += '</tr>';

        html += '</tbody></table>';
        section.querySelector('#lastDaysTable').innerHTML = html;
      }

      drawLastDays();

  // redraw highlight on equity selection changes
      const eqOrbSel2 = document.getElementById('eqOrbSelect');
      const eqRSel2 = document.getElementById('eqRSelect');
      if (eqOrbSel2) eqOrbSel2.addEventListener('change', drawLastDays);
      if (eqRSel2) eqRSel2.addEventListener('change', drawLastDays);
  if (filterSourceEl) filterSourceEl.addEventListener('filters-changed', () => { filtersActivated = true; drawLastDays(); });
    }
    // --- /NEW ---

    function fmt(n) {
      const abs = Math.abs(n);
      const decimals = abs < 1 ? 4 : 2;
      return n.toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
    }

    // --- NEW: date formatter used by the last-20-days table ---
    function fmtDate(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }
    // --- /NEW ---

    // --- NEW: Controls section toggle ---
    (function() {
      const toggleBtn = document.getElementById('controlsToggle');
      const bodyEl = document.getElementById('controlsBody');
      if (!toggleBtn || !bodyEl) return;

      toggleBtn.addEventListener('click', () => {
        const expanded = toggleBtn.getAttribute('aria-expanded') === 'true';
        toggleBtn.setAttribute('aria-expanded', !expanded);
        bodyEl.classList.toggle('hidden', expanded);
        // Update button text based on state
        toggleBtn.innerHTML = expanded ? 'Expand' : 'Collapse';
        // Focus first input in the body when expanding
        if (!expanded) {
          const firstInput = bodyEl.querySelector('input,textarea,select');
          if (firstInput) firstInput.focus();
        }
      });
    })();
  </script>
  <script>
    // Controls expand/collapse wiring (chevron only; no visible text)
    (function(){
      const toggle = document.getElementById('controlsToggle');
      const body = document.getElementById('controlsBody');
      const chevron = document.getElementById('controlsChevron');
      if (!toggle || !body || !chevron) return;
      const setCollapsed = (collapsed) => {
        if (collapsed) {
          body.classList.add('hidden');
          toggle.setAttribute('aria-expanded', 'false');
          toggle.setAttribute('aria-label', 'Expand upload controls');
          chevron.classList.remove('rotate-180');
        } else {
          body.classList.remove('hidden');
          toggle.setAttribute('aria-expanded', 'true');
          toggle.setAttribute('aria-label', 'Collapse upload controls');
          chevron.classList.add('rotate-180');
        }
      };
      // start collapsed
      setCollapsed(true);
      toggle.addEventListener('click', (e) => { e.preventDefault(); const collapsed = body.classList.contains('hidden'); setCollapsed(collapsed); });
    })();
  </script>
  <script>
      // Populate the ticker segmented control by listing files in ./data/
      async function populateTickerSegment(){
        const container = document.getElementById('tickerSegment');
        if (!container) return;
        const defaultSymbols = ['TQQQ','TSLA','PLTR','UVXY'];
        container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';

        // Helper to render an array of plain symbols into the segment
        function renderSymbols(symbols){
          container.innerHTML = '';
          symbols.forEach((s, i) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            const cls = 'px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100' + (i < symbols.length - 1 ? ' border-r border-slate-200' : '');
            btn.className = cls;
            btn.setAttribute('data-symbol', s);
            btn.textContent = s;
            container.appendChild(btn);
          });
        }

        // 1) Try a simple manifest at data/index.json containing ["SYM","SYM2",...]
        try {
          const mres = await fetch('data/index.json', { cache: 'no-cache' });
          if (mres.ok) {
            const list = await mres.json();
            if (Array.isArray(list) && list.length) {
              const syms = list.map(s => String(s).toUpperCase());
              renderSymbols(syms);
              return;
            }
          }
        } catch (e) {
          // ignore and fall back to directory listing
        }

        // 2) Fallback: try to parse a directory index (works only on some servers)
        try {
          const res = await fetch('data/', { cache: 'no-cache' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const text = await res.text();
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let files = [];
          if (ct.includes('text/html')) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            files = Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href')).filter(Boolean);
          } else {
            files = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          }
          const regex = /^([A-Za-z0-9-]+)_backtest_results\.csv$/i;
          const syms = [];
          for (const f of files) {
            const name = (f || '').split('/').pop();
            const m = name.match(regex);
            if (m) syms.push(m[1].toUpperCase());
          }
          const uniq = Array.from(new Set(syms));
          const toRender = uniq.length ? uniq : defaultSymbols;
          renderSymbols(toRender);
          return;
        } catch (err) {
          // fall through to defaults
        }

        // 3) Default fallback
        renderSymbols(defaultSymbols);
      }
       // run now (page script is at bottom so element exists)
      populateTickerSegment().catch(()=>{});
    </script>
</body>
</html>
