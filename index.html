<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ORB Monthly Performance Tables</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Plotly for interactive charts -->
  <script src="https://cdn.plot.ly/plotly-2.31.1.min.js"></script>
  <style>
    .num-pos { color: #065f46; } /* emerald-800 */
    .num-neg { color: #9f1239; } /* rose-800 */
    .sticky-th { position: sticky; top: 0; background: white; z-index: 1; }
    .shadow-soft { box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
    .grid-auto { grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <div class="max-w-7xl mx-auto p-6">
    <header class="mb-6">
      <!-- Updated: add id for dynamic title prefixing -->
      <h1 id="mainTitle" class="text-2xl md:text-3xl font-semibold">ORB Monthly Performance</h1>
      <p class="text-slate-600 mt-1">This app displays <span class="font-semibold">monthly sums</span> of daily P&amp;L (R units) for each <code>orb_m</code> × <code>target_R</code> combination. Orb_m is the number of minutes after 9:30 NY time. target_R is the desired target return in R units. stop_R is fixed at 2R.</p>
    </header>

    <!-- NEW: Symbol segmented control -->
    <section id="symbolPicker" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 mb-6">
      <div class="flex items-center gap-2">
        <span class="text-sm text-slate-600">Symbol:</span>
        <div id="tickerSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden">
          <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
        </div>
      </div>
      <!-- NEW: Direction segmented control -->
      <div class="mt-3 flex items-center gap-2">
        <span class="text-sm text-slate-600">Direction:</span>
        <div id="directionSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden" data-selected="BOTH">
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200" data-direction="BOTH">BOTH</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200" data-direction="LONG">LONG</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100" data-direction="SHORT">SHORT</button>
        </div>
      </div>
    </section>

    <!-- Preload palette classes for Tailwind JIT -->
    <div class="hidden bg-emerald-50 bg-emerald-100 bg-emerald-200 bg-emerald-300 bg-emerald-400 bg-rose-50 bg-rose-100 bg-rose-200 bg-rose-300 bg-rose-400"></div>

    <!-- Controls (collapsible) -->
    <section id="controlsSection" class="relative bg-white rounded-2xl shadow-soft p-4 md:p-6 space-y-4 mb-6">
      <!-- Toggle (top-right) -->
      <button id="controlsToggle" aria-expanded="false" aria-label="Expand upload controls" class="absolute right-4 top-4 inline-flex items-center gap-2 rounded-full px-2 py-1 text-sm bg-slate-100 hover:bg-slate-200">
        <svg id="controlsChevron" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 transition-transform" viewBox="0 0 20 20" fill="currentColor" aria-hidden="false"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
      </button>

      <div class="flex flex-col md:flex-row md:items-center gap-3">
        <label class="block text-sm font-medium">Upload CSV</label>
        <input id="fileInput" type="file" accept=".csv,text/csv" class="block w-full md:w-auto text-sm file:mr-4 file:py-2 file:px-4 file:rounded-xl file:border-0 file:text-sm file:font-semibold file:bg-slate-800 file:text-white hover:file:bg-slate-900" />
      </div>

      <!-- Collapsible body: hidden by default; contains the rest of the controls -->
      <div id="controlsBody" class="hidden">
        <div class="grid grid-cols-1 gap-4">
          <div>
            <label for="csvText" class="block text-sm font-medium mb-1">Paste CSV here</label>
            <textarea id="csvText" rows="12" class="w-full font-mono text-xs md:text-sm p-3 rounded-xl border border-slate-200 focus:outline-none focus:ring-2 focus:ring-slate-300" placeholder="Paste your CSV…"></textarea>
          </div>
        </div>

        <div class="flex flex-col md:flex-row md:items-center gap-3">
          <div class="flex items-center gap-2">
            <label class="text-sm">Aggregation:</label>
            <div class="relative inline-block">
              <select id="aggSelect" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 pr-9 text-sm">
                <option value="sum" selected>Monthly sum of daily R</option>
              </select>
              <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <label class="text-sm">Missing values:</label>
            <div class="relative inline-block">
              <select id="naSelect" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 pr-9 text-sm">
                <option value="skip" selected>Skip</option>
                <option value="zero">Treat as 0</option>
              </select>
              <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
          </div>
          <button id="processBtn" class="w-full md:w-auto inline-flex items-center justify-center rounded-xl px-4 py-2 text-sm font-semibold bg-emerald-600 text-white hover:bg-emerald-700">Process CSV</button>
          <button id="clearBtn" class="w-full md:w-auto inline-flex items-center justify-center rounded-xl px-4 py-2 text-sm font-semibold bg-slate-200 text-slate-800 hover:bg-slate-300">Clear</button>
        </div>

        <details class="text-sm text-slate-600 mt-2">
          <summary class="cursor-pointer select-none">Expected CSV layout</summary>
          <pre class="mt-2 p-3 bg-slate-100 rounded-xl overflow-x-auto text-xs">orb_m,5,5,5,5,5,5,10,10,10,10,...
 target_R,1,2,3,4,5,6,1,2,3,4,...
 Date Range,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 2024-07-15,0.9990,1.9980,2.9970,-1.9980,...
 2024-07-12,0.9981,1.9962,2.9943,3.9924,...
 ...</pre>
        </details>
      </div>
    </section>

    <!-- Output -->
    <section id="output" class="space-y-6"></section>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const csvText = document.getElementById('csvText');
    const processBtn = document.getElementById('processBtn');
    const clearBtn = document.getElementById('clearBtn');
    const output = document.getElementById('output');

    // NEW: track selected ticker and helper to update titles
    let currentTicker = '';
  // NEW: track selected direction (UI only for now; wiring next)
  let currentDirection = 'BOTH';
    function setTickerFromFilename(name) {
      const m = name && name.match(/^([A-Za-z][A-Za-z0-9-]*)_backtest_results\.csv$/i);
      const t = m ? m[1] : (name ? (name.split('_')[0] || '') : '');
      currentTicker = (t || '').toUpperCase();
      const full = `${currentTicker ? currentTicker + ' - ' : ''}ORB Monthly Performance Tables`;
      const titleEl = document.getElementById('mainTitle');
      if (titleEl) titleEl.textContent = full;
      document.title = full;
    }

    // NEW: helper to process CSV string and render
    function processCsvAndRender(text) {
      const trimmed = (text || '').trim();
      if (!trimmed) return;
      const parsed = parseCSV(trimmed);
      const model = toModel(parsed);
      const { byOrb, monthsSorted, combosByOrb } = aggregateMonthly(model, {
        naMode: document.getElementById('naSelect').value
      });
      renderTables(model, combosByOrb, byOrb, monthsSorted, currentTicker);
    }

    // --- Upload handler ---
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        csvText.value = text.trim();
        // NEW: extract and apply ticker from filename
        setTickerFromFilename(file.name);
      } catch (err) {
        alert('Could not read file: ' + err.message);
      }
    });

    // --- Process ---
    processBtn.addEventListener('click', () => {
      try {
        processCsvAndRender(csvText.value);
      } catch (err) {
        console.error(err);
        alert('Error: ' + err.message);
      }
    });

    // --- Clear ---
    clearBtn.addEventListener('click', () => {
      csvText.value = '';
      fileInput.value = '';
      output.innerHTML = '';
      // NEW: reset ticker and titles
      currentTicker = '';
      const defaultTitle = 'ORB Monthly Performance Tables';
      const titleEl = document.getElementById('mainTitle');
      if (titleEl) titleEl.textContent = defaultTitle;
      document.title = defaultTitle;
      csvText.focus();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });

    // Helper: build data URL based on symbol and direction
    function buildDataUrl(sym, dir) {
      const suffix = dir === 'LONG' ? '_LONG' : dir === 'SHORT' ? '_SHORT' : '';
      const file = `${sym}${suffix}_backtest_results.csv`;
      return { file, url: new URL(`data/${file}`, window.location.href).toString() };
    }

    // Helper: load and render for a given symbol + direction; clears output if missing
    async function loadAndRender(sym, dir) {
      const { file, url } = buildDataUrl(sym, dir);
      try {
        const res = await fetch(url, { cache: 'no-cache' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        currentTicker = sym;
        setTickerFromFilename(file);
        csvText.value = text.trim();
        processCsvAndRender(text);
        return true;
      } catch (err) {
        console.warn(`Data not found for ${sym} ${dir}: ${file}`, err);
        // Clear UI/output but keep currentTicker selection
        csvText.value = '';
        output.innerHTML = '';
        // Update title to show selected symbol even if data missing
        currentTicker = sym;
        setTickerFromFilename(`${sym}_backtest_results.csv`);
        return false;
      }
    }

    // Expose direction segment and a setter to reset from outside
    const directionSegment = document.getElementById('directionSegment');
    function setActiveDirectionByValue(val) {
      if (!directionSegment) return;
      const btn = directionSegment.querySelector(`button[data-direction="${val}"]`);
      directionSegment.querySelectorAll('button').forEach(b => b.classList.remove('bg-slate-800','text-white'));
      if (btn) {
        btn.classList.add('bg-slate-800','text-white');
        directionSegment.setAttribute('data-selected', val);
        currentDirection = val;
      }
    }

    // NEW: Ticker segmented control logic – load based on currentDirection; reset to BOTH on select
    const tickerSegment = document.getElementById('tickerSegment');
    if (tickerSegment) {
      const setActiveTicker = (btn) => {
        tickerSegment.querySelectorAll('button').forEach(b => b.classList.remove('bg-slate-800','text-white'));
        if (btn) btn.classList.add('bg-slate-800','text-white');
      };

      tickerSegment.addEventListener('click', async (e) => {
        const btn = e.target.closest('button[data-symbol]');
        if (!btn) return;
        const sym = String(btn.getAttribute('data-symbol') || '').toUpperCase();
        if (!sym) return;
        setActiveTicker(btn);
        // Reset direction to BOTH by default when symbol changes
        setActiveDirectionByValue('BOTH');
        // Load BOTH for the newly selected symbol
        await loadAndRender(sym, 'BOTH');
      });
    }

    // NEW: Direction segmented control logic (loads matching CSV if ticker selected)
    (function(){
      if (!directionSegment) return;
      // init -> BOTH
      setActiveDirectionByValue('BOTH');
      directionSegment.addEventListener('click', async (e) => {
        const btn = e.target.closest('button[data-direction]');
        if (!btn) return;
        const dir = String(btn.getAttribute('data-direction') || 'BOTH').toUpperCase();
        setActiveDirectionByValue(dir);
        if (!currentTicker) return; // nothing to load yet
        await loadAndRender(currentTicker, dir);
      });
    })();

    function parseCSV(text) {
      const rows = [];
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      for (const line of lines) rows.push(line.split(',').map(c => c.trim()))
      if (rows.length < 4) throw new Error('CSV must include orb_m row, target_R row, a label row, and data rows.');
      return rows;
    }

    // --- Model ---
    function toModel(rows) {
      const orbHeader = rows[0];
      const trgHeader = rows[1];
      if (!/^orb_m$/i.test(orbHeader[0])) throw new Error('First row must start with "orb_m"');
      if (!/^target_R$/i.test(trgHeader[0])) throw new Error('Second row must start with "target_R"');

      const orbVals = orbHeader.slice(1).map(v => parseFloat(v));
      const trgVals = trgHeader.slice(1).map(v => parseFloat(v));
      if (orbVals.length !== trgVals.length) throw new Error('orb_m and target_R columns must align.');

      let startIdx = 2;
      if (/date/i.test(rows[2][0])) startIdx = 3;

      const combos = orbVals.map((m, i) => ({ orb_m: m, target_R: trgVals[i], key: `m${m}_r${trgVals[i]}` }));

      const data = [];
      for (let i = startIdx; i < rows.length; i++) {
        const r = rows[i];
        const dateStr = r[0];
        const d = new Date(dateStr);
        if (isNaN(d)) throw new Error(`Bad date on row ${i+1}: ${dateStr}`);
        const y = d.getFullYear();
        const m = d.getMonth() + 1; // 1-12
        const record = { date: d, year: y, month: m, yyyymm: `${y}-${String(m).padStart(2,'0')}` };
        for (let c = 0; c < combos.length; c++) {
          const raw = r[c+1];
          const val = raw === undefined || raw === '' ? null : Number(raw);
          record[combos[c].key] = Number.isFinite(val) ? val : null;
        }
        data.push(record);
      }
      return { combos, data };
    }

    // --- Monthly aggregation ---
    function aggregateMonthly(model, opts) {
      const { combos, data } = model;
      const naMode = opts && opts.naMode || 'skip';
      const months = Array.from(new Set(data.map(d => d.yyyymm))).sort();
      const byOrb = new Map();

      const orbMap = new Map();
      for (const { orb_m, target_R, key } of combos) {
        if (!orbMap.has(orb_m)) orbMap.set(orb_m, []);
        orbMap.get(orb_m).push({ target_R, key });
      }
      for (const [orb, arr] of orbMap) arr.sort((a,b) => a.target_R - b.target_R);

      for (const [orb, arr] of orbMap) {
        const rowsOut = [];
        for (const m of months) {
          const monthRows = data.filter(d => d.yyyymm === m);
          const vals = new Map();
          for (const { target_R, key } of arr) {
            let sum = 0;
            let used = 0;
            for (const d of monthRows) {
              const v = d[key];
              if (v === null || !Number.isFinite(v)) {
                if (naMode === 'zero') { sum += 0; used++; }
                continue;
              }
              sum += v; used++;
            }
            vals.set(target_R, used === 0 ? null : sum);
          }
          rowsOut.push({ month: m, vals });
        }
        byOrb.set(orb, { targets: arr.map(o => o.target_R), rows: rowsOut });
      }
      return { byOrb, monthsSorted: months, combosByOrb: orbMap };
    }

    // --- Render ---
    function renderTables(model, combosByOrb, byOrb, monthsSorted, ticker) {
      output.innerHTML = '';

      // NEW: prefix for headings and main title
      const prefix = ticker ? `${ticker} - ` : '';
      const mainTitleEl = document.getElementById('mainTitle');
      if (mainTitleEl) {
        const full = `${prefix}ORB Monthly Performance Tables`;
        mainTitleEl.textContent = full;
        document.title = full;
      }

      // SUMMARY
      const summaryEl = document.createElement('div');
      summaryEl.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6';
      summaryEl.innerHTML = `
        <div class="flex items-center justify-between gap-3 flex-wrap mb-3">
          <h2 class="text-lg font-semibold">${prefix}Totals (sum of daily R) by combo</h2>
          <div class="flex items-center gap-2">
            <span class="text-sm text-slate-600">Days:</span>
            <div id="daysSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden">
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"ALL\">All</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"5\">5</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"10\">10</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"20\">20</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"30\">30</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"60\">60</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-r border-slate-200\" data-days=\"90\">90</button>
              <button type=\"button\" class=\"px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100\" data-days=\"120\">120</button>
            </div>
          </div>
        </div>
        <!-- keep 6 columns but allow horizontal scrolling if necessary; make cards more compact -->
        <div id="summaryCards" class="overflow-x-auto"><div class="grid grid-cols-6 gap-2 min-w-max" id="summaryCardsGrid"></div></div>
      `;
      output.appendChild(summaryEl);

  const seg = summaryEl.querySelector('#daysSegment');
      // We render into inner grid container to allow horizontal scroll on small portrait screens
      const cardsContainer = summaryEl.querySelector('#summaryCardsGrid');

      const setActive = (btn) => {
        seg.querySelectorAll('button').forEach(b => b.classList.remove('bg-slate-800','text-white'));
        if (btn) { btn.classList.add('bg-slate-800','text-white'); seg.setAttribute('data-selected', btn.getAttribute('data-days')); }
      };

      const rebuildSummaryCards = () => {
        const daysSel = seg.getAttribute('data-selected') || 'ALL';
        const naMode = document.getElementById('naSelect').value;
        const totals = computeTotalsByDays(model, combosByOrb, daysSel, naMode); // Map orb -> Map(r -> total|null)

        // Build flat list for rendering & highlighting
        const summaryCards = [];
        const orbs = Array.from(combosByOrb.keys()).sort((a,b) => a - b);
        for (const orb of orbs) {
          const rmap = totals.get(orb) || new Map();
          const rs = (combosByOrb.get(orb) || []).map(o => o.target_R).sort((a,b)=>a-b);
          for (const r of rs) {
            const total = rmap.has(r) ? rmap.get(r) : null;
            summaryCards.push({ orb, r, total });
          }
        }

        // Top/bottom 5 highlights
        const valid = summaryCards.filter(c => c.total !== null);
        const top = [...valid].sort((a,b) => b.total - a.total).slice(0,5);
        const bottom = [...valid].sort((a,b) => a.total - b.total).slice(0,5);
        const hl = new Map();
        top.forEach((c,i)=> hl.set(`${c.orb}|${c.r}`, topShade(i)));
        bottom.forEach((c,i)=> { if (!hl.has(`${c.orb}|${c.r}`)) hl.set(`${c.orb}|${c.r}`, bottomShade(i)); });

        cardsContainer.innerHTML = summaryCards.map(c => {
          const cls = c.total === null ? 'text-slate-400' : (c.total >= 0 ? 'num-pos' : 'num-neg');
          const val = c.total === null ? '—' : fmt(c.total);
          const bg = hl.get(`${c.orb}|${c.r}`) || '';
          // Keep 6 columns but reduce text size and padding to fit portrait mobile
          return `<div class="rounded-2xl border border-slate-200 p-2 sm:p-3 ${bg} min-w-[120px]">
            <div class="text-[11px] sm:text-xs text-slate-500 truncate">orb_m ${c.orb} · R ${c.r}</div>
            <div class="text-lg sm:text-2xl font-semibold ${cls}">${val}</div>
          </div>`;
        }).join('');
      };

      // init to ALL
      const initBtn = seg.querySelector('button[data-days="ALL"]');
      setActive(initBtn);
      rebuildSummaryCards();

      seg.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-days]');
        if (!btn) return;
        setActive(btn);
        rebuildSummaryCards();
      });

  // --- NEW: Equity curve section (below Totals summary) ---
  renderEquitySection(model, combosByOrb, summaryEl);

      // Month & Quarter selector section (unchanged logic)
      const monthSection = document.createElement('section');
      monthSection.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6 space-y-4';
      monthSection.innerHTML = `
        <div class="flex items-center gap-3 flex-wrap">
          <h2 class="text-lg font-semibold">${prefix}Monthly total returns by combo</h2>
          <div class="flex items-center gap-2">
            <label class="text-sm text-slate-600">Month(s):</label>
            <div class="relative inline-block">
              <button id="monthMultiBtn" type="button" class="inline-flex items-center justify-between gap-2 bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm min-w-[180px]">
                <span id="monthMultiLabel" class="truncate">Select months</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </button>
              <div id="monthMultiMenu" class="absolute z-30 mt-1 w-64 bg-white border border-slate-200 rounded-xl shadow-soft p-2 hidden">
                <div id="monthMultiList" class="max-h-64 overflow-auto">
                  <!-- items injected -->
                </div>
              </div>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <label class="text-sm text-slate-600" for="quarterSelect">Quarter:</label>
            <div class="relative inline-block">
              <select id="quarterSelect" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 pr-9 text-sm"></select>
              <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
          </div>
        </div>
        <div id="periodHint" class="text-xs text-slate-500"></div>
        <div id="monthCards" class="space-y-4"></div>
      `;
      output.appendChild(monthSection);

      // Build Month multi-select dropdown items
      const monthBtn = monthSection.querySelector('#monthMultiBtn');
      const monthLabel = monthSection.querySelector('#monthMultiLabel');
      const monthMenu = monthSection.querySelector('#monthMultiMenu');
      const monthList = monthSection.querySelector('#monthMultiList');

      // Add toolbar with Select all / Clear actions
      const monthToolbar = document.createElement('div');
      monthToolbar.className = 'sticky top-0 bg-white z-10 px-2 pb-2 border-b border-slate-200 flex items-center justify-between gap-2';
      monthToolbar.innerHTML = `
        <button id="monthSelectAll" type="button" class="text-xs font-medium text-emerald-700 hover:text-emerald-900 hover:underline">Select all</button>
        <button id="monthClearAll" type="button" class="text-xs text-slate-600 hover:text-slate-800 hover:underline">Clear</button>
      `;
      monthMenu.insertBefore(monthToolbar, monthList);

      function fmtMonthShort(ym){
        const [y, m] = ym.split('-');
        const names = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        return `${names[Number(m)-1]} ${y}`;
      }
      function updateMonthBtnLabel(selected){
        if (!selected || selected.length === 0) { monthLabel.textContent = 'Select months'; return; }
        const shown = selected.slice().sort().map(fmtMonthShort);
        if (shown.length === 1) { monthLabel.textContent = shown[0]; return; }
        if (shown.length <= 3) { monthLabel.textContent = shown.join(', '); return; }
        monthLabel.textContent = `${shown.length} months`; 
      }
      function getSelectedMonths(){
        return Array.from(monthList.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value);
      }
      function setSelectedMonths(values){
        const set = new Set(values);
        monthList.querySelectorAll('input[type="checkbox"]').forEach(i => { i.checked = set.has(i.value); });
        updateMonthBtnLabel(values);
      }

      // Populate items (descending so most recent on top)
      [...monthsSorted].sort().forEach(m => {
        const id = `m_${m.replace('-','_')}`;
        const row = document.createElement('label');
        row.className = 'flex items-center gap-2 px-2 py-1.5 rounded-lg hover:bg-slate-50 cursor-pointer';
        row.innerHTML = `
          <input type="checkbox" class="h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-500" value="${m}" id="${id}" />
          <span class="text-sm text-slate-700">${fmtMonthDisplay(m)}</span>
        `;
        monthList.appendChild(row);
      });

      // Toggle dropdown
      monthBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        monthMenu.classList.toggle('hidden');
      });
      document.addEventListener('click', (e) => {
        const within = monthSection.contains(e.target);
        if (!within) monthMenu.classList.add('hidden');
      });

      // Populate quarter selector (based on months present)
      const quarterSelect = monthSection.querySelector('#quarterSelect');
      const quarters = quartersFromMonths(monthsSorted);
      const blankQ = document.createElement('option');
      blankQ.value = '';
      blankQ.textContent = '—';
      quarterSelect.appendChild(blankQ);
      quarters.forEach(q => {
        const opt = document.createElement('option');
        opt.value = `${q.q}|${q.year}`; // e.g., "3|2024"
        opt.textContent = `Q${q.q}-${q.year}`;
        quarterSelect.appendChild(opt);
      });

      // Wire Select all / Clear buttons
      const monthSelectAllBtn = monthSection.querySelector('#monthSelectAll');
      const monthClearAllBtn = monthSection.querySelector('#monthClearAll');
      if (monthSelectAllBtn) {
        monthSelectAllBtn.addEventListener('click', (e) => {
          e.preventDefault(); e.stopPropagation();
          quarterSelect.value = '';
          setSelectedMonths(monthsSorted.slice());
          const cardsEl = monthSection.querySelector('#monthCards');
          const hintEl = monthSection.querySelector('#periodHint');
          renderPeriodRows(byOrb, { type: 'months', values: monthsSorted.slice() }, cardsEl, hintEl);
        });
      }
      if (monthClearAllBtn) {
        monthClearAllBtn.addEventListener('click', (e) => {
          e.preventDefault(); e.stopPropagation();
          quarterSelect.value = '';
          setSelectedMonths([]);
          const cardsEl = monthSection.querySelector('#monthCards');
          const hintEl = monthSection.querySelector('#periodHint');
          if (cardsEl) cardsEl.innerHTML = '';
          if (hintEl) hintEl.textContent = 'Select one or more months, or choose a quarter.';
        });
      }

      // Defaults: select all months, quarter cleared (months mode)
      setSelectedMonths(monthsSorted.slice());
      renderPeriodRows(byOrb, { type: 'months', values: monthsSorted.slice() }, monthSection.querySelector('#monthCards'), monthSection.querySelector('#periodHint'));

      // Event wiring for checkbox changes (auto-apply)
      monthList.addEventListener('change', () => {
        // When selecting specific months, clear quarter selection
        quarterSelect.value = '';
        const selectedMonths = getSelectedMonths();
        updateMonthBtnLabel(selectedMonths);
        const cardsEl = monthSection.querySelector('#monthCards');
        const hintEl = monthSection.querySelector('#periodHint');
        if (selectedMonths.length === 0) {
          if (cardsEl) cardsEl.innerHTML = '';
          if (hintEl) hintEl.textContent = 'Select one or more months, or choose a quarter.';
          return;
        }
        renderPeriodRows(byOrb, { type: 'months', values: selectedMonths }, cardsEl, hintEl);
      });

      // Quarter change -> render or revert to selected months
      quarterSelect.addEventListener('change', () => {
        const cardsEl = monthSection.querySelector('#monthCards');
        const hintEl = monthSection.querySelector('#periodHint');
        if (!quarterSelect.value) {
          const selectedMonths = getSelectedMonths();
          if (selectedMonths.length > 0) {
            renderPeriodRows(byOrb, { type: 'months', values: selectedMonths }, cardsEl, hintEl);
          } else {
            setSelectedMonths([latestMonth]);
            renderPeriodRows(byOrb, { type: 'months', values: [latestMonth] }, cardsEl, hintEl);
          }
        } else {
          // Clear months visual selection when quarter picked, for clarity
          setSelectedMonths([]);
          const [qStr, yStr] = quarterSelect.value.split('|');
          const q = Number(qStr); const year = Number(yStr);
          renderPeriodRows(byOrb, { type: 'quarter', q, year }, cardsEl, hintEl, monthsSorted);
          monthMenu.classList.add('hidden');
        }
      });

      // Per-orb tables (full monthly detail)
      for (const [orb, table] of byOrb.entries()) {
        const section = document.createElement('section');
        section.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6';

        const header = document.createElement('div');
        header.className = 'flex items-center justify-between mb-4';
        header.innerHTML = `<div>
            <h2 class="text-xl font-semibold">orb_m = ${orb}</h2>
            <p class="text-sm text-slate-600">Monthly sum of daily R by target_R</p>
          </div>
          <button class="inline-flex items-center rounded-xl px-3 py-2 text-sm font-medium bg-slate-100 hover:bg-slate-200" data-download="${orb}">Download CSV</button>`;
        section.appendChild(header);

        const tableEl = document.createElement('div');
        tableEl.className = 'overflow-auto rounded-xl border border-slate-200';
        tableEl.innerHTML = buildTableHTML(table, monthsSorted);
        section.appendChild(tableEl);

        output.appendChild(section);
      }

      // Download handlers
      output.querySelectorAll('button[data-download]').forEach(btn => {
        btn.addEventListener('click', () => {
          const orb = Number(btn.getAttribute('data-download'));
          const tbl = byOrb.get(orb);
          const csv = tableToCSV(tbl, monthsSorted, orb);
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `monthly_orb_${orb}.csv`;
          a.click();
          URL.revokeObjectURL(url);
        });
      });

      // --- NEW: Last 20 days section at the very end ---
      renderLastDaysSection(model, combosByOrb, ticker);
    }

    // Compute totals by last N days from the raw daily data
    function computeTotalsByDays(model, combosByOrb, daysSel, naMode) {
      const times = Array.from(new Set(model.data.map(d => d.date.getTime()))).sort((a,b) => a - b);
      const allowedTimes = (daysSel === 'ALL') ? times : times.slice(-Math.max(0, parseInt(daysSel,10)));
      const allowed = new Set(allowedTimes);
      const result = new Map(); // orb -> Map(target_R -> total|null)

      for (const [orb, arr] of combosByOrb.entries()) {
        const rmap = new Map();
        for (const { target_R, key } of arr) {
          let sum = 0; let used = 0;
          for (const row of model.data) {
            const t = row.date.getTime();
            if (!allowed.has(t)) continue;
            const v = row[key];
            if (v === null || !Number.isFinite(v)) {
              if (naMode === 'zero') { sum += 0; used++; }
              continue;
            }
            sum += v; used++;
          }
          rmap.set(target_R, used === 0 ? null : sum);
        }
        result.set(orb, rmap);
      }
      return result;
    }

    // --- NEW: Equity curve rendering using Plotly ---
  function renderEquitySection(model, combosByOrb, mountAfterEl) {
      // Build container under the summary section
  const section = document.createElement('section');
  section.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6 mt-4 overflow-hidden';
      section.innerHTML = `
        <div class="flex items-center justify-between gap-3 flex-wrap mb-3">
          <h2 class="text-lg font-semibold">Equity curve (daily compounding)</h2>
          <div class="flex items-center gap-3">
            <label class="text-sm text-slate-600">orb_m:</label>
            <div class="relative inline-block">
              <select id="eqOrbSelect" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 pr-9 text-sm"></select>
              <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
            <label class="text-sm text-slate-600">target_R:</label>
            <div class="relative inline-block">
              <select id="eqRSelect" class="appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 pr-9 text-sm"></select>
              <span class="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-slate-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
          </div>
        </div>
        <div class="text-xs text-slate-500 mb-2">Assumes starting balance of $100,000 and treats daily R value as percentage return (1R = 1%).</div>
  <div id="equityChart" class="w-full min-h-[320px]"></div>
      `;
  // Insert right after the provided element (summary section)
  mountAfterEl.parentNode.insertBefore(section, mountAfterEl.nextSibling);

      // Populate orb and R selects
      const orbSelect = section.querySelector('#eqOrbSelect');
      const rSelect = section.querySelector('#eqRSelect');
      const orbs = Array.from(combosByOrb.keys()).sort((a,b)=>a-b);
      orbs.forEach(o => {
        const opt = document.createElement('option');
        opt.value = String(o);
        opt.textContent = o;
        orbSelect.appendChild(opt);
      });
      function populateRSelect(orb){
        rSelect.innerHTML = '';
        const arr = (combosByOrb.get(Number(orb)) || []).slice().sort((a,b)=>a.target_R - b.target_R);
        for (const { target_R } of arr) {
          const opt = document.createElement('option');
          opt.value = String(target_R);
          opt.textContent = target_R;
          rSelect.appendChild(opt);
        }
      }
      populateRSelect(orbs[0]);

      // Default selections: first orb and first R
      orbSelect.value = String(orbs[0]);
      rSelect.value = rSelect.options.length ? rSelect.options[0].value : '';

      // Compute and plot
    function computeEquity(orb, r){
        const key = `m${orb}_r${r}`;
        const rows = [...model.data].sort((a,b)=> a.date - b.date);
        const x = [];
        const y = [];
        const start = 100000;
        let equity = start;
        const naMode = document.getElementById('naSelect').value;
        for (const row of rows) {
          let v = row[key];
          if ((v === null || !Number.isFinite(v))) {
            if (naMode === 'zero') v = 0; else continue;
          }
          const pct = v / 100; // Treat 1R as 1% daily return
          equity = equity * (1 + pct);
      // Use ISO date string to allow Plotly 'date' axis to auto-manage ticks
      x.push(row.date.toISOString().slice(0,10));
          y.push(equity);
        }
        return { x, y };
      }

      function fmtPct(p){
        if (p === null || p === undefined || !Number.isFinite(p)) return '—';
        return (p * 100).toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 }) + '%';
      }

      function computeStatsFromSeries(x, y){
        if (!y || y.length < 2) return { cagr: null, maxDD: null };
        const startVal = y[0];
        const endVal = y[y.length - 1];
        const parse = (s) => new Date(s.replace(/\//g,'-'));
        const startDate = parse(x[0]);
        const endDate = parse(x[x.length - 1]);
        const years = (endDate - startDate) / (365.25 * 24 * 3600 * 1000);
        const cagr = (years > 0 && startVal > 0) ? Math.pow(endVal / startVal, 1 / years) - 1 : null;
        // Max Drawdown
        let peak = -Infinity; let maxDD = 0; // negative number like -0.25 for -25%
        for (const v of y) {
          if (v > peak) peak = v;
          const dd = (v / peak) - 1;
          if (dd < maxDD) maxDD = dd;
        }
        return { cagr, maxDD };
      }

      function draw(){
        const orb = Number(orbSelect.value);
        const r = Number(rSelect.value);
        const { x, y } = computeEquity(orb, r);
        const { cagr, maxDD } = computeStatsFromSeries(x, y);
        const annText = `CAGR ${fmtPct(cagr)}\nMaxDD ${fmtPct(maxDD)}`;
        const layout = {
          height: 340,
          margin: { l: 50, r: 20, t: 10, b: 40 },
          xaxis: { title: 'Date', type: 'date', tickformat: '%Y-%m', ticklabelmode: 'period', nticks: 8, automargin: true },
          yaxis: { title: 'Equity ($)', hoverformat: ',.2f' },
          hovermode: 'x unified',
          template: 'plotly_white',
          annotations: [{
            xref: 'paper', yref: 'paper', x: 1, y: 0, xanchor: 'right', yanchor: 'bottom', showarrow: false,
            text: annText,
            align: 'right',
            font: { color: '#334155', size: 12 },
            bgcolor: 'rgba(148,163,184,0.12)', // slate-400 at low alpha
            bordercolor: '#cbd5e1', borderwidth: 1, borderpad: 4
          }]
        };
        const data = [{
          x, y,
          type: 'scatter', mode: 'lines',
          line: { color: '#059669', width: 2 },
          hovertemplate: '%{x|%Y-%m-%d}<br>$%{y:,.2f}<extra></extra>'
        }];
  Plotly.react(section.querySelector('#equityChart'), data, layout, { responsive: true, displaylogo: false });
      }

      // Wire change handlers
      orbSelect.addEventListener('change', () => {
        populateRSelect(Number(orbSelect.value));
        // reset R to first option on orb change for clarity
        if (rSelect.options.length) rSelect.value = rSelect.options[0].value;
        draw();
      });
      rSelect.addEventListener('change', draw);

      // Initial draw
      draw();
    }

    function cardHTML(c) {
      const cls = c.total === null ? 'text-slate-400' : (c.total >= 0 ? 'num-pos' : 'num-neg');
      const val = c.total === null ? '—' : fmt(c.total);
      return `<div class="rounded-2xl border border-slate-200 p-4 ${c._bg ? c._bg : ''}">
        <div class="text-xs text-slate-500">orb_m ${c.orb} · R ${c.r}</div>
        <div class="text-2xl font-semibold ${cls}">${val}</div>
      </div>`;
    }

    function buildTableHTML(tbl, months) {
      const cols = tbl.targets;

      // --- Column-wise extremes for independent scaling per target_R ---
      const colMaxPos = new Map(); // R -> max positive monthly value
      const colMaxNegAbs = new Map(); // R -> max absolute negative monthly value
      for (const r of cols) {
        let maxPos = 0;
        let maxNegAbs = 0;
        for (const m of months) {
          const v = tbl.rows.find(x => x.month === m)?.vals.get(r) ?? null;
          if (v === null || !Number.isFinite(v)) continue;
          if (v > 0 && v > maxPos) maxPos = v;
          if (v < 0 && Math.abs(v) > maxNegAbs) maxNegAbs = Math.abs(v);
        }
        colMaxPos.set(r, maxPos);
        colMaxNegAbs.set(r, maxNegAbs);
      }

      const shadeGreen = (ratio) => {
        if (ratio > 0.8) return 'bg-emerald-400';
        if (ratio > 0.6) return 'bg-emerald-300';
        if (ratio > 0.4) return 'bg-emerald-200';
        if (ratio > 0.2) return 'bg-emerald-100';
        return 'bg-emerald-50';
      };
      const shadeRed = (ratio) => {
        // Increase minimum shade to >= 150 by flooring at rose-200
        if (ratio > 0.8) return 'bg-rose-400';
        if (ratio > 0.5) return 'bg-rose-300';
        return 'bg-rose-200';
      };

      let html = '<table class="min-w-full text-sm">';
      html += '<thead class="bg-slate-50"><tr>';
      html += '<th class="sticky-th text-left font-semibold px-3 py-2 border-b border-slate-200">Month</th>';
      for (const r of cols) {
        html += `<th class="sticky-th text-right font-semibold px-3 py-2 border-b border-slate-200">R ${r}</th>`;
      }
      html += '</tr></thead><tbody>';

      for (const m of months) {
        html += '<tr class="odd:bg-white even:bg-slate-50/50">';
        html += `<td class="px-3 py-2 whitespace-nowrap">${m}</td>`;
        for (const r of cols) {
          const v = tbl.rows.find(x => x.month === m)?.vals.get(r) ?? null;
          const maxPos = colMaxPos.get(r) || 0;
          const maxNegAbs = colMaxNegAbs.get(r) || 0;

          let bgCls = '';
          let textCls = '';
          if (v !== null && Number.isFinite(v)) {
            if (v > 0 && maxPos > 0) {
              const ratio = Math.max(0, Math.min(1, v / maxPos));
              bgCls = shadeGreen(ratio);
              textCls = ratio > 0.8 ? 'text-white' : 'num-pos';
            } else if (v < 0 && maxNegAbs > 0) {
              const ratio = Math.max(0, Math.min(1, Math.abs(v) / maxNegAbs));
              bgCls = shadeRed(ratio);
              textCls = ratio > 0.8 ? 'text-white' : 'num-neg';
            } else if (v === 0) {
              textCls = 'text-slate-600';
            }
          } else {
            textCls = 'text-slate-400';
          }

          html += `<td class="px-3 py-2 text-right ${textCls} ${bgCls}">${v === null ? '—' : fmt(v)}</td>`;
        }
        html += '</tr>';
      }

      // Totals row
      html += '<tr class="bg-slate-100 font-semibold">';
      html += '<td class="px-3 py-2">Total</td>';
      for (const r of cols) {
        let total = 0; let has = false;
        for (const row of tbl.rows) { const v = row.vals.get(r); if (v !== null && Number.isFinite(v)) { total += v; has = true; } }
        html += `<td class="px-3 py-2 text-right ${has ? (total>=0?'num-pos':'num-neg') : ''}">${has ? fmt(total) : '—'}</td>`;
      }
      html += '</tr>';

      html += '</tbody></table>';
      return html;
    }

    function tableToCSV(tbl, months, orb) {
      const header = ['month', ...tbl.targets.map(r => `orb_${orb}_R_${r}`)];
      const rows = [header.join(',')];
      for (const m of months) {
        const vals = tbl.targets.map(r => {
          const v = tbl.rows.find(x => x.month === m)?.vals.get(r) ?? null;
          return v === null ? '' : v;
        });
        rows.push([m, ...vals].join(','));
      }
      const totals = tbl.targets.map(r => {
        let t = 0; let has = false;
        for (const row of tbl.rows) { const v = row.vals.get(r); if (v !== null && Number.isFinite(v)) { t += v; has = true; } }
        return has ? t : '';
      });
      rows.push(['TOTAL', ...totals].join(','));
      return rows.join('\n'); // fixed newline delimiter
    }

    function fmtMonthDisplay(ym) {
      // ym in 'YYYY-MM' -> 'MM/YYYY'
      if (!ym) return '';
      const [y, m] = ym.split('-');
      return `${m}/${y}`;
    }

    // Compute array of quarter objects from months array
    function quartersFromMonths(months) {
      const qMap = new Map(); // key `${year}-${q}` -> Set of months strings
      for (const ym of months) {
        const { year, q } = getQuarterFromYYYYMM(ym);
        const key = `${year}-${q}`;
        if (!qMap.has(key)) qMap.set(key, new Set());
        qMap.get(key).add(ym);
      }
      const out = [];
      for (const [key, set] of qMap.entries()) {
        const [yearStr, qStr] = key.split('-');
        out.push({ year: Number(yearStr), q: Number(qStr), months: Array.from(set).sort() });
      }
      out.sort((a,b) => a.year - b.year || a.q - b.q);
      return out;
    }

    function getQuarterFromYYYYMM(ym) {
      const [yStr, mStr] = ym.split('-');
      const y = Number(yStr); const m = Number(mStr);
      const q = Math.floor((m - 1) / 3) + 1; // 1..4
      return { year: y, q };
    }

    // highlight shade helpers
    function topShade(rank){ const shades=['bg-emerald-400','bg-emerald-300','bg-emerald-200','bg-emerald-100','bg-emerald-50']; return shades[Math.min(rank, shades.length-1)] || ''; }
    function bottomShade(rank){ const shades=['bg-rose-400','bg-rose-300','bg-rose-200','bg-rose-100','bg-rose-50']; return shades[Math.min(rank, shades.length-1)] || ''; }

    // Render a selected period (single month OR calendar quarter)
    function renderPeriodRows(byOrb, period, containerEl, hintEl, monthsSortedAll) {
      containerEl.innerHTML = '';
      if (hintEl) {
        if (period.type === 'month') {
          hintEl.textContent = `Showing month: ${fmtMonthDisplay(period.value)}`;
        } else if (period.type === 'months') {
          const list = (period.values || []).map(fmtMonthDisplay).join(', ');
          hintEl.textContent = list ? `Showing months: ${list}` : 'Select one or more months, or choose a quarter.';
        } else {
          hintEl.textContent = `Showing quarter: Q${period.q}-${period.year}`;
        }
      }

      function getVal(tbl, r) {
        if (period.type === 'month') {
          const row = tbl.rows.find(x => x.month === period.value);
          return row ? row.vals.get(r) : null;
        } else if (period.type === 'months') {
          const monthsInSel = (period.values || []);
          let sum = 0; let used = 0;
          for (const ym of monthsInSel) {
            const row = tbl.rows.find(x => x.month === ym);
            const v = row ? row.vals.get(r) : null;
            if (v === null || !Number.isFinite(v)) continue;
            sum += v; used++;
          }
          return used === 0 ? null : sum;
        } else {
          const monthsInQ = (monthsSortedAll || []).filter(ym => {
            const { year, q } = getQuarterFromYYYYMM(ym);
            return year === period.year && q === period.q;
          });
          let sum = 0; let used = 0;
          for (const ym of monthsInQ) {
            const row = tbl.rows.find(x => x.month === ym);
            const v = row ? row.vals.get(r) : null;
            if (v === null || !Number.isFinite(v)) continue;
            sum += v; used++;
          }
          return used === 0 ? null : sum;
        }
      }

      const all = [];
      for (const [orbKey, tblAll] of byOrb.entries()) {
        for (const r of tblAll.targets) {
          const v = getVal(tblAll, r);
          if (v !== null && Number.isFinite(v)) all.push({ orb: orbKey, r, v });
        }
      }
      const hi = [...all].sort((a,b) => b.v - a.v).slice(0,5);
      const lo = [...all].sort((a,b) => a.v - b.v).slice(0,5);
      const highlight = new Map();
      hi.forEach((o,i) => highlight.set(`${o.orb}|${o.r}`, topShade(i)));
      lo.forEach((o,i) => { if (!highlight.has(`${o.orb}|${o.r}`)) highlight.set(`${o.orb}|${o.r}`, bottomShade(i)); });

      const orbs = Array.from(byOrb.keys()).sort((a,b) => a - b);
      for (const orb of orbs) {
        const tbl = byOrb.get(orb);
        const rowDiv = document.createElement('div');
        rowDiv.className = 'space-y-2';

        const title = document.createElement('div');
        title.className = 'text-sm font-medium text-slate-700';
        title.textContent = `orb_m = ${orb}`;
        rowDiv.appendChild(title);

        const cardsWrap = document.createElement('div');
        // keep 6 columns but allow horizontal scrolling on small portrait screens; make cards compact
        cardsWrap.className = 'overflow-x-auto';
        const innerGrid = document.createElement('div');
        innerGrid.className = 'grid grid-cols-6 gap-3 min-w-max';
        for (const r of tbl.targets) {
          const v = getVal(tbl, r);
          const cls = v === null ? 'text-slate-400' : (v >= 0 ? 'num-pos' : 'num-neg');
          const val = v === null ? '—' : fmt(v);
          const key = `${orb}|${r}`;
          const bg = highlight.get(key) || '';
          const card = document.createElement('div');
          // compact card styling to match summary cards: smaller label, smaller padding, fixed min-width for columns
          card.className = 'rounded-2xl border border-slate-200 p-2 sm:p-3 min-w-[120px] ' + bg;
          card.innerHTML = `<div class="text-[11px] sm:text-xs text-slate-500 truncate">R ${r}</div><div class="text-lg sm:text-2xl font-semibold ${cls}">${val}</div>`;
          innerGrid.appendChild(card);
        }
        cardsWrap.appendChild(innerGrid);
        rowDiv.appendChild(cardsWrap);
        containerEl.appendChild(rowDiv);
      }
    }

    // --- NEW: Last 20 days section (helper) ---
    function renderLastDaysSection(model, combosByOrb, ticker) {
      const prefix = ticker ? `${ticker} - ` : '';
      const section = document.createElement('section');
      section.className = 'bg-white rounded-2xl shadow-soft p-4 md:p-6';
      section.innerHTML = `
        <div class=\"mb-4\">
          <h2 class=\"text-lg font-semibold\">${prefix}Last 20 days — daily R by combo</h2>
          <p class=\"text-sm text-slate-600\">Most recent first. Each column is an <code>orb_m</code> × <code>target_R</code> combo.</p>
        </div>
        <div class=\"overflow-auto rounded-xl border border-slate-200\">
          <div id=\"lastDaysTable\"></div>
        </div>
      `;
      output.appendChild(section);

      // Create ordered list of all combos (orb asc, R asc)
      const combos = [];
      const orbs = Array.from(combosByOrb.keys()).sort((a,b)=>a-b);
      for (const orb of orbs) {
        const arr = (combosByOrb.get(orb) || []).slice().sort((a,b)=>a.target_R - b.target_R);
        for (const { target_R, key } of arr) {
          combos.push({ orb_m: orb, target_R, key });
        }
      }

      // Last 20 rows by date (descending)
      const rows = [...model.data].sort((a,b)=>b.date - a.date).slice(0, 20);
      const naMode = document.getElementById('naSelect').value;

      // Build table HTML
      let html = '<table class="min-w-full text-xs md:text-sm">';
      html += '<thead class="bg-slate-50"><tr>';
      html += '<th class="sticky-th text-left font-semibold px-3 py-2 border-b border-slate-200">Date</th>';
      for (const c of combos) {
        html += `<th class="sticky-th text-right font-semibold px-3 py-2 border-b border-slate-200">m ${c.orb_m} · R ${c.target_R}</th>`;
      }
      html += '</tr></thead><tbody>';

      for (const r of rows) {
        // Compute per-row highlights (best 5 green, worst 5 red) using existing gradient helpers
        const entries = [];
        for (let i = 0; i < combos.length; i++) {
          const c = combos[i];
          let v = r[c.key];
          if ((v === null || !Number.isFinite(v)) && naMode === 'zero') v = 0;
          if (v !== null && Number.isFinite(v)) entries.push({ key: c.key, v });
        }
        const hi = [...entries].sort((a,b) => b.v - a.v).slice(0, 5);
        const lo = [...entries].sort((a,b) => a.v - b.v).slice(0, 5);
        const hl = new Map();
        hi.forEach((o,i) => hl.set(o.key, topShade(i)));
        lo.forEach((o,i) => { if (!hl.has(o.key)) hl.set(o.key, bottomShade(i)); });

        html += '<tr class="odd:bg-white even:bg-slate-50/50">';
        html += `<td class="px-3 py-2 whitespace-nowrap">${fmtDate(r.date)}</td>`;
        for (const c of combos) {
          let v = r[c.key];
          if ((v === null || !Number.isFinite(v)) && naMode === 'zero') v = 0;

          let cls = 'text-slate-400';
          let disp = '—';
          if (v !== null && Number.isFinite(v)) {
            disp = fmt(v);
            if (v > 0) cls = 'num-pos';
            else if (v < 0) cls = 'num-neg';
            else cls = 'text-slate-600';
          }
          const bg = hl.get(c.key) || '';
          html += `<td class="px-3 py-2 text-right ${cls} ${bg}">${disp}</td>`;
        }
        html += '</tr>';
      }

      html += '</tbody></table>';
      section.querySelector('#lastDaysTable').innerHTML = html;
    }
    // --- /NEW ---

    function fmt(n) {
      const abs = Math.abs(n);
      const decimals = abs < 1 ? 4 : 2;
      return n.toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
    }

    // --- NEW: date formatter used by the last-20-days table ---
    function fmtDate(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }
    // --- /NEW ---

    // --- NEW: Controls section toggle ---
    (function() {
      const toggleBtn = document.getElementById('controlsToggle');
      const bodyEl = document.getElementById('controlsBody');
      if (!toggleBtn || !bodyEl) return;

      toggleBtn.addEventListener('click', () => {
        const expanded = toggleBtn.getAttribute('aria-expanded') === 'true';
        toggleBtn.setAttribute('aria-expanded', !expanded);
        bodyEl.classList.toggle('hidden', expanded);
        // Update button text based on state
        toggleBtn.innerHTML = expanded ? 'Expand' : 'Collapse';
        // Focus first input in the body when expanding
        if (!expanded) {
          const firstInput = bodyEl.querySelector('input,textarea,select');
          if (firstInput) firstInput.focus();
        }
      });
    })();
  </script>
  <script>
    // Controls expand/collapse wiring (chevron only; no visible text)
    (function(){
      const toggle = document.getElementById('controlsToggle');
      const body = document.getElementById('controlsBody');
      const chevron = document.getElementById('controlsChevron');
      if (!toggle || !body || !chevron) return;
      const setCollapsed = (collapsed) => {
        if (collapsed) {
          body.classList.add('hidden');
          toggle.setAttribute('aria-expanded', 'false');
          toggle.setAttribute('aria-label', 'Expand upload controls');
          chevron.classList.remove('rotate-180');
        } else {
          body.classList.remove('hidden');
          toggle.setAttribute('aria-expanded', 'true');
          toggle.setAttribute('aria-label', 'Collapse upload controls');
          chevron.classList.add('rotate-180');
        }
      };
      // start collapsed
      setCollapsed(true);
      toggle.addEventListener('click', (e) => { e.preventDefault(); const collapsed = body.classList.contains('hidden'); setCollapsed(collapsed); });
    })();
  </script>
  <script>
      // Populate the ticker segmented control by listing files in ./data/
      async function populateTickerSegment(){
        const container = document.getElementById('tickerSegment');
        if (!container) return;
        const defaultSymbols = ['TQQQ','TSLA','PLTR','UVXY'];
        container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';

        // Helper to render an array of plain symbols into the segment
        function renderSymbols(symbols){
          container.innerHTML = '';
          symbols.forEach((s, i) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            const cls = 'px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100' + (i < symbols.length - 1 ? ' border-r border-slate-200' : '');
            btn.className = cls;
            btn.setAttribute('data-symbol', s);
            btn.textContent = s;
            container.appendChild(btn);
          });
        }

        // 1) Try a simple manifest at data/index.json containing ["SYM","SYM2",...]
        try {
          const mres = await fetch('data/index.json', { cache: 'no-cache' });
          if (mres.ok) {
            const list = await mres.json();
            if (Array.isArray(list) && list.length) {
              const syms = list.map(s => String(s).toUpperCase());
              renderSymbols(syms);
              return;
            }
          }
        } catch (e) {
          // ignore and fall back to directory listing
        }

        // 2) Fallback: try to parse a directory index (works only on some servers)
        try {
          const res = await fetch('data/', { cache: 'no-cache' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const text = await res.text();
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let files = [];
          if (ct.includes('text/html')) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            files = Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href')).filter(Boolean);
          } else {
            files = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          }
          const regex = /^([A-Za-z0-9-]+)_backtest_results\.csv$/i;
          const syms = [];
          for (const f of files) {
            const name = (f || '').split('/').pop();
            const m = name.match(regex);
            if (m) syms.push(m[1].toUpperCase());
          }
          const uniq = Array.from(new Set(syms));
          const toRender = uniq.length ? uniq : defaultSymbols;
          renderSymbols(toRender);
          return;
        } catch (err) {
          // fall through to defaults
        }

        // 3) Default fallback
        renderSymbols(defaultSymbols);
      }
       // run now (page script is at bottom so element exists)
      populateTickerSegment().catch(()=>{});
    </script>
</body>
</html>
