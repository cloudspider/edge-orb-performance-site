<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>About Grid</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"
  />
  <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
  <style>
    .shadow-soft { box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <nav class="bg-white border-b border-slate-200 sticky top-0 z-50 shadow-sm">
    <div class="max-w-screen-2xl mx-auto px-6 py-3 flex items-center gap-4">
      <div class="flex items-center gap-6 flex-1 min-w-0">
        <div class="flex items-center gap-2 font-semibold text-slate-800">
          <svg class="h-5 w-5 text-emerald-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" fill="currentColor" aria-hidden="true"><path d="M192 384L88.5 384C63.6 384 48.3 356.9 61.1 335.5L114 247.3C122.7 232.8 138.3 224 155.2 224L250.2 224C326.3 95.1 439.8 88.6 515.7 99.7C528.5 101.6 538.5 111.6 540.3 124.3C551.4 200.2 544.9 313.7 416 389.8L416 484.8C416 501.7 407.2 517.3 392.7 526L304.5 578.9C283.2 591.7 256 576.3 256 551.5L256 448C256 412.7 227.3 384 192 384L191.9 384zM464 224C464 197.5 442.5 176 416 176C389.5 176 368 197.5 368 224C368 250.5 389.5 272 416 272C442.5 272 464 250.5 464 224z"/></svg>
          <span>GRID</span>
        </div>
        <div class="flex items-center gap-2 flex-wrap">
          <a data-nav href="grid.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Grid Backtest</a>
          <a data-nav href="grid_calc.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Grid Calculator</a>
          <a data-nav href="grid_about.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">About</a>
        </div>
      </div>
    </div>
  </nav>
  <script>
    (function(){
      try {
        const file = (location.pathname.split('/').pop() || 'grid.html').toLowerCase();
        document.querySelectorAll('a[data-nav]').forEach(a => {
          const href = (a.getAttribute('href') || '').toLowerCase();
          const active = href === file || (file === '' && href.endsWith('index.html'));
          a.classList.toggle('bg-slate-800', active);
          a.classList.toggle('text-white', active);
          a.classList.toggle('hover:bg-slate-100', !active);
          if (active) a.setAttribute('aria-current','page'); else a.removeAttribute('aria-current');
        });
      } catch {}
    })();
  </script>

  <div class="max-w-screen-2xl mx-auto p-6 space-y-6">
    <header class="mb-2">
      <h1 class="text-2xl md:text-3xl font-semibold">About Grid</h1>
      <p class="text-sm text-slate-500">More details coming soon.</p>
    </header>
    <section class="bg-white rounded-2xl shadow-soft p-8 prose prose-slate max-w-none"
            aria-label="About Panel">
      <!-- Article container -->
      <div id="grid-article" class="space-y-4 text-slate-800"></div>
    </section>

    <!-- Markdown renderer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const container = document.getElementById('grid-article');
        if (!container || typeof window.marked === 'undefined') return;
        const articleMarkdown = `
        # Grid Trading: Turning Volatility Into a Compounding Machine  
        <i class="fa-solid fa-wave-square text-emerald-600"></i> *Featuring the IREN 5,540-trade case study*

        ---

        ## Why Grid Trading Exists

        Most trading styles depend on **prediction**.  
        Grid trading depends on **oscillation**.

        A grid trader asks:

        - ✔ *Will the stock oscillate?*  
        - ✔ *Can I harvest the movement repeatedly?*  
        - ✔ *Can volatility become income?*

        This philosophical shift turns noise into cashflow—especially when applied to a stock like **IREN**, which over two years produced:

        - **5,540 completed trades on a 2% grid spacing**  
        - **Three separate 65% drawdowns**  
        - **Full recoveries**  
        - **Constant oscillation**

        Exactly the environment where grid trading thrives.

        ---

        ## Grid Types Overview <i class="fa-solid fa-layer-group text-sky-600"></i>

        We will focus on the **Buy-the-Dip Grid**, the simplest and most robust variant.

        ---

        ## 1. Buy-the-Dip Grid (Default)

        The rule set is extremely clear:

        - Seed **buy orders** at every rung *below* the base price  
        - When a buy fills → spawn a **sell** one rung above  
        - When a sell fills → re-arm a **buy** one rung below  

        This creates a continuous “buy dips, sell bounces” rhythm.

        ### Trend Coverage  
        The system tracks the highest rung it has ever armed with a buy.

        If price continues climbing several rungs above that point, the grid **pre-loads new buy rungs upward** so that any pullback will still trigger meaningful dip entries.

        ### Sell-to-Buy Recycling  
        A sell fill always enqueues a buy one rung below, keeping the ladder alive and ensuring dips remain harvestable.

        Buy-the-Dip is simple, robust, and extremely effective in oscillatory symbols.

        ---

        # Continuous ATH Base Reset  
        <i class="fa-solid fa-arrow-trend-up text-rose-500"></i>

        This is the major enhancement.

        Every time price prints a **new All-Time High (ATH)**:

        1. The **Base Price is reset to the new ATH**  
        2. All rungs are **recalculated downward** starting from that ATH  
        3. Old rungs far below price are discarded  
        4. The system waits for the *next dip*  
        5. The first rung below the ATH becomes the new entry point  

        This keeps the grid:

        - aligned with long-term uptrends  
        - clean and focused  
        - relevant to current price  
        - ready to act immediately when a pullback appears  

        ### Why ATH reset matters
        Without it:

        - the ladder drifts too far below price  
        - entry spacing becomes too wide  
        - capital is inefficiently allocated  
        - the grid misses profitable near-term dips  

        With ATH reset:

        - the ladder is always fresh  
        - spacing is preserved  
        - risk profile is consistent  
        - the first buy is always at a meaningful dip from the current high  

        ---

        # Example of Continuous ATH Reset  
        <i class="fa-solid fa-arrows-spin text-purple-600"></i>

        Assume:

        - Grid spacing = 2%  
        - Base price = $100  
        - Buy rungs: $98, $96.04, $94.12…

        ### Scenario 1 — Price hits a new ATH at $105  
        We immediately:

        - Set **new base = $105**  
        - Rebuild buy rungs downward:  
          - $102.90  
          - $100.84  
          - $98.82  
          - $96.86  
          - …

        No buys are active while price is rising.  
        We simply wait.

        ---

        ### Scenario 2 — Price pulls back to $102.90  
        First buy triggers.

        We immediately:

        - Buy at **$102.90**  
        - Place a sell at **$105.00**  
        - Keep lower rungs ready  

        ---

        ### Scenario 3 — Price rebounds to $105  
        - Sell triggers  
        - Profit captured  
        - If a newer ATH forms (say $108), we reset the ladder again  

        This loop continues, turning **all pullbacks** into **harvestable oscillations**.

        ---

        # The Mathematics of the Ladder <i class="fa-solid fa-calculator text-indigo-600"></i>

        ## Distance (%)

        For a rung price \`p\`:

        \`\`\`
        (p - startPrice) / startPrice × 100
        \`\`\`

        Shown in the “Distance (%)” ladder preview.

        ---

        ## Loss (%)

        This is the most misunderstood part of grid trading.

        Loss% is computed by:

        1. Summing unrealized losses across all filled entries  
        2. Comparing that to cumulative invested capital  
        3. Calculating:

        \`\`\`
        lossPct = (totalLoss / prevInvested) × 100
        \`\`\`

        ### **Important:**  
        Loss% is **NOT** equal to the underlying price drop.

        Grid drawdown is *mathematically softer* because:

        - capital is deployed across many entry points  
        - lower rungs have extremely low cost bases  
        - losses dilute across aggregated entries  

        ---

        # The 100-Level Ladder Example (2% Spacing)

        From your preview table:

        - **Price drop: –86.7%**  
        - **Actual capital loss: –57.5%**  
        - *(Worst case, assuming zero sells)*  

        This happens because:

        - The lowest rungs are extremely cheap  
        - Many filled levels are far below the current rung  
        - Unrealized loss spreads across many entries  

        And again — this scenario assumes **zero wins**.

        In reality, every bounce harvests profits and reduces risk.

        ---

        # Drawdown Decreases Over Time  
        <i class="fa-solid fa-arrow-down-short-wide text-emerald-600"></i>

        Every sell fill:

        - realizes profit  
        - removes high-cost inventory  
        - improves average cost  
        - increases future drawdown resilience  

        This is why a grid with 500 completed trades has dramatically lower risk than a brand-new grid—even with identical settings.

        ---

        # IREN Case Study  
        <i class="fa-solid fa-chart-line text-amber-500"></i>

        ### Why IREN was an ideal Buy-the-Dip candidate:

        - ~507 days  
        - 44,936 10-minute bars  
        - **5,540 completed trades at 2% spacing**  
        - **3 major 65% drawdowns**  
        - Full recoveries  
        - Constant oscillation  

        These drawdowns **helped** the system:

        - They created deep, cheap rungs  
        - They amplified oscillations during recovery  
        - They produced an enormous number of profitable cycles  

        IREN’s volatility + survivability made it nearly perfect for this strategy.

        ---

        # Breakeven Math

        With:

        - 59 rungs  
        - 2% spacing  
        - 1,000 per rung  

        You need:

        \`\`\`
        59 × 50 = 2,950 trades
        \`\`\`

        IREN delivered:

        - **5,540 trades**  

        Nearly **2× breakeven**.

        This put the system firmly into **free carry** territory.

        ---

        # Choosing Good Grid Candidates  
        <i class="fa-solid fa-magnifying-glass-chart text-cyan-600"></i>

        Look for stocks with:

        - ✔ Strong oscillation  
        - ✔ Deep but recoverable drawdowns  
        - ✔ Healthy long-term uptrends  
        - ✔ Solid liquidity  
        - ✔ Potential to 5–10×  

        Avoid:

        - Terminal decline patterns  
        - Stocks that never reclaim ATHs  
        - Assets that stay frozen at –80% forever  

        You want volatility **with recovery**, not volatility **into oblivion**.

        ---

        # Final Thoughts  
        <i class="fa-solid fa-sparkles text-yellow-500"></i>

        The Buy-the-Dip Grid with continuous ATH resets is:

        - simple  
        - robust  
        - adaptive  
        - self-correcting  
        - highly effective in volatile symbols  

        It works because it:

        - Buys dips  
        - Sells bounces  
        - Resets to ATHs  
        - Keeps the ladder aligned with the market  
        - Reduces drawdown as wins accumulate  
        - Turns oscillation into income  
        - Turns volatility into long-term compounding  

        When matched with the right stock—like IREN—volatility becomes the fuel, and time becomes the multiplier.
        `;

        const normalizeIndent = (text) => {
          const lines = text.split('\n');
          const indents = lines
            .filter(line => line.trim().length)
            .map(line => line.match(/^(\s*)/)?.[1]?.length ?? 0);
          const minIndent = indents.length ? Math.min(...indents) : 0;
          return lines.map(line => line.slice(minIndent)).join('\n').trim();
        };
        const markdown = normalizeIndent(articleMarkdown);
        const renderer = typeof window.marked.parse === 'function'
          ? (md) => window.marked.parse(md)
          : window.marked;
        container.innerHTML = renderer(markdown);
      });
    </script>

  </div>
</body>
</html>
