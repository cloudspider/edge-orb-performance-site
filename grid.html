
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grid Backtest</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"
  />
  <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
  <!-- Apache ECharts for interactive charts (mobile pinch-zoom supported) -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    :root {
      --color-slate-900: #0f172a;
      --color-slate-300: #cbd5e1;
      --color-slate-200: #e2e8f0;
      --color-slate-600: #475569;
      --color-emerald-500: #10b981;
      --color-violet-500: #a855f7;
      --radius-pill: 999px;
      --app-bg: #f8fafc;
      --app-surface: #ffffff;
      --app-surface-muted: #f1f5f9;
      --app-surface-strong: #e2e8f0;
      --app-border: #e2e8f0;
      --app-border-muted: rgba(148, 163, 184, 0.4);
      --app-text: #0f172a;
      --app-text-muted: #475569;
      --app-text-subtle: #94a3b8;
      --app-header-bg: rgba(255, 255, 255, 0.9);
      --app-header-border: #e2e8f0;
      --app-sidebar-bg: #f8fafc;
      --app-tabbar-bg: #ffffff;
      --app-shadow-soft: 0 25px 45px rgba(15, 23, 42, 0.08);
      --app-shadow-elevated: 0 16px 32px rgba(15, 23, 42, 0.12);
      --app-log-bg: #0b1221;
      --app-log-border: rgba(148, 163, 184, 0.35);
      --app-chart-card-bg: #ffffff;
      --app-chart-card-border: rgba(226, 232, 240, 0.9);
      --app-chart-stat-bg: rgba(241, 245, 249, 0.9);
      --app-chart-stat-border: rgba(226, 232, 240, 0.9);
      --app-chart-dot: rgba(148, 163, 184, 0.8);
      --app-chart-dot-hover: rgba(100, 116, 139, 0.9);
      --app-chart-overlay-bg: rgba(255, 255, 255, 0.82);
      --app-chart-key-harvest: rgba(16, 185, 129, 0.95);
      --app-chart-key-cash: rgba(139, 92, 246, 0.95);
      --app-chart-axis-text: #64748b;
      --app-chart-grid: rgba(226, 232, 240, 0.9);
      --app-chart-legend-text: #334155;
      --app-chart-cash-line: rgba(139, 92, 246, 0.95);
      --app-chart-cash-fill: rgba(139, 92, 246, 0.1);
      --app-chart-harvest-line: rgba(16, 185, 129, 0.95);
      --app-chart-harvest-fill: rgba(16, 185, 129, 0.1);
      --app-overlay-bg: rgba(15, 23, 42, 0.75);
      --app-overlay-text: #ffffff;
      --app-badge-warning-bg: rgba(251, 146, 60, 0.15);
      --app-badge-warning-border: rgba(251, 146, 60, 0.35);
      --app-badge-warning-text: #c2410c;
      --app-badge-neutral-bg: rgba(148, 163, 184, 0.15);
      --app-badge-info-hover: rgba(59, 130, 246, 0.12);
      --app-badge-info-bg: rgba(59, 130, 246, 0.18);
      --app-badge-info-border: rgba(59, 130, 246, 0.8);
      --app-badge-info-ring: rgba(59, 130, 246, 0.25);
      --app-badge-info-text: #e0f2fe;
      --app-badge-success-hover: rgba(16, 185, 129, 0.14);
      --app-badge-success-bg: rgba(16, 185, 129, 0.18);
      --app-badge-success-border: rgba(16, 185, 129, 0.75);
      --app-badge-success-ring: rgba(16, 185, 129, 0.25);
      --app-badge-success-text: #dcfce7;
      --app-live-badge-on-bg: #10b981;
      --app-live-badge-on-text: #ffffff;
      --app-live-badge-off-bg: #e2e8f0;
      --app-live-badge-off-text: #64748b;
      --app-live-badge-off-border: #cbd5e1;
      --app-alert-warning-bg: #fffbeb;
      --app-alert-warning-border: #fde68a;
      --app-alert-warning-text: #92400e;
      --app-status-inactive-bg: #f2f2f2;
      --app-status-idle-bg: var(--color-slate-300);
      --app-status-armed-bg: #69e499;
      --app-status-waiting-bg: #ff5654;
      --app-status-orphan-bg: var(--color-violet-500);
      --app-card-buy-bg: #69e499;
      --app-card-buy-border: #7bd79f;
      --app-card-sell-bg: #ffa3a2;
      --app-card-sell-border: #f97374;
      --app-split-buy-bg: #c7f5d9;
      --app-split-sell-bg: #ff3d3b;
      --app-market-open-bg: linear-gradient(135deg, #ecfdf3, #dcfce7);
      --app-market-open-border: #34d399;
      --app-market-open-text: #065f46;
      --app-market-open-shadow: 0 15px 35px rgba(16, 185, 129, 0.2);
      --app-market-open-icon-bg: #d1fae5;
      --app-market-open-icon-text: #047857;
      --app-market-closed-bg: linear-gradient(135deg, #fef2f2, #fee2e2);
      --app-market-closed-border: #fca5a5;
      --app-market-closed-text: #991b1b;
      --app-market-closed-shadow: 0 15px 35px rgba(248, 113, 113, 0.2);
      --app-market-closed-icon-bg: #fee2e2;
      --app-market-closed-icon-text: #b91c1c;
      --app-market-guard-bg: linear-gradient(135deg, #fffbeb, #fef3c7);
      --app-market-guard-border: #facc15;
      --app-market-guard-text: #854d0e;
      --app-market-guard-shadow: 0 15px 35px rgba(250, 204, 21, 0.18);
      --app-market-guard-icon-bg: #fef9c3;
      --app-market-guard-icon-text: #a16207;
      --app-pill-neutral-bg: linear-gradient(135deg, var(--color-slate-200), #f8fafc);
      --app-pill-neutral-border: var(--color-slate-300);
      --app-pill-neutral-text: var(--color-slate-900);
      --app-pill-buy-bg: linear-gradient(135deg, var(--color-emerald-500), #34d399);
      --app-pill-buy-border: #059669;
      --app-pill-buy-text: #ecfdf3;
      --app-pill-sell-bg: linear-gradient(135deg, #f43f5e, #ef4444);
      --app-pill-sell-border: #e11d48;
      --app-pill-sell-text: #fff1f2;
      --app-accent: #2563eb;
      --app-accent-strong: #1d4ed8;
      --app-scrollbar-thumb: rgba(148, 163, 184, 0.6);
      --app-sort-indicator: #cbd5f5;
      --app-spinner-border: rgba(148, 163, 184, 0.6);
      --app-tooltip-bg: #0f172a;
      --app-tooltip-text: #f1f5f9;
      --app-tooltip-shadow: 0 20px 45px rgba(15, 23, 42, 0.4);
      --app-tooltip-button-bg: #0f172a;
      --app-tooltip-button-border: rgba(255, 255, 255, 0.15);
      --app-tooltip-button-text: #f1f5f9;
      --app-tooltip-button-hover-bg: #111b33;
      --app-tooltip-button-hover-border: rgba(16, 185, 129, 0.35);
      --app-tooltip-button-ring: rgba(52, 211, 153, 0.6);
      --app-tooltip-button-success-bg: #10b981;
      --app-tooltip-button-success-border: #10b981;
      --app-tooltip-button-success-text: #f8fbff;
      --app-tooltip-close-bg: rgba(15, 23, 42, 0.6);
      --app-tooltip-close-hover-bg: rgba(15, 23, 42, 0.9);
      --app-tooltip-close-text: #cbd5f5;
      --app-tooltip-close-hover-text: #ffffff;
      --app-tooltip-code-bg: rgba(255, 255, 255, 0.08);
      --app-tooltip-code-border: rgba(255, 255, 255, 0.12);
      --app-focus-ring: rgba(16, 185, 129, 0.7);
      --app-segment-active-shadow: 0 4px 12px rgba(16, 185, 129, 0.35);
      --app-pull-bg: rgba(248, 250, 252, 0.92);
      --app-pull-border: rgba(148, 163, 184, 0.5);
      --app-pull-text: #475569;
      --app-pull-shadow: 0 6px 14px rgba(15, 23, 42, 0.08);
      --app-border-strong: #cbd5e1;
      --app-row-hover-bg: rgba(16, 185, 129, 0.08);
      --app-row-selected-bg: rgba(16, 185, 129, 0.16);
      --app-row-selected-ring: rgba(16, 185, 129, 0.4);
      --app-checkbox-border: #94a3b8;
      --app-checkbox-bg: #ffffff;
      --app-checkbox-indeterminate-bg: #e2e8f0;
      --app-checkbox-indeterminate-border: #94a3b8;
      --app-checkbox-indeterminate-icon: #64748b;
      --app-level-metric-bg: rgba(241, 245, 249, 0.9);
      --app-level-metric-border: rgba(226, 232, 240, 0.9);
      --app-level-metric-label: rgba(100, 116, 139, 0.95);
      --app-level-bar-bg: #f1f5f9;
      --app-level-bar-border: rgba(15, 23, 42, 0.06);
      --app-level-bar-divider: rgba(15, 23, 42, 0.18);
      --app-level-marker: rgba(15, 23, 42, 0.25);
      --app-level-price-label: #1f2937;
      --app-level-price-dot: #0ee932;
      --app-level-price-dot-border: #ecfeff;
      --app-level-price-dot-shadow: 0 2px 6px rgba(14, 165, 233, 0.4);
      --app-menu-bg: #0f172a;
      --app-menu-text: #e2e8f0;
      --app-menu-border: rgba(148, 163, 184, 0.35);
      --app-menu-item-bg: rgba(255, 255, 255, 0.04);
      --app-menu-item-border: rgba(255, 255, 255, 0.08);
      --app-menu-item-text: #f8fafc;
      --app-menu-item-hover-bg: rgba(16, 185, 129, 0.16);
      --app-menu-item-hover-border: rgba(16, 185, 129, 0.45);
      --app-menu-item-hover-text: #befae0;
      --app-sheet-bg: #ffffff;
      --app-sheet-text: #0f172a;
      --app-sheet-border: rgba(148, 163, 184, 0.22);
      --app-sheet-shadow: 0 -18px 45px rgba(15, 23, 42, 0.18);
      --app-sheet-backdrop: rgba(15, 23, 42, 0.35);
      --app-sheet-handle: rgba(15, 23, 42, 0.18);
      --app-sheet-title: #0f172a;
      --app-sheet-subtitle: #64748b;
      --app-sheet-close: #334155;
      --app-sheet-close-hover: #047857;
      --app-sheet-item-bg: #ffffff;
      --app-sheet-item-text: #0f172a;
      --app-sheet-item-border: rgba(148, 163, 184, 0.28);
      --app-sheet-item-shadow: 0 10px 22px rgba(15, 23, 42, 0.06);
      --app-sheet-item-hover-border: rgba(16, 185, 129, 0.55);
      --app-sheet-item-hover-shadow: 0 12px 28px rgba(16, 185, 129, 0.12);
      --app-sheet-icon-bg: rgba(15, 23, 42, 0.06);
      --app-sheet-icon-text: #0f172a;
      --app-negative-text: #dc2626;
      --app-highlight-symbol: #fde047;
      --app-market-pill-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7), 0 15px 35px rgba(15, 23, 42, 0.08);
      --app-market-icon-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 8px 18px rgba(15, 23, 42, 0.12);
      --app-meta-tile-shadow: 0 10px 25px rgba(15, 23, 42, 0.2);
      --app-on-accent-text: #ffffff;
      --app-meta-text: #ffffff;
      --app-meta-subtext: rgba(255, 255, 255, 0.85);
      --app-success-border: #059669;
      --app-success-ring: rgba(16, 185, 129, 0.18);
      --app-on-success-text: #ffffff;
      --app-order-ref-default: #334155;
      --app-order-ref-buy: #047857;
      --app-order-ref-sell: #b91c1c;
      --app-order-accent-emerald: #10b981;
      --app-order-accent-sky: #0ea5e9;
      --app-order-accent-amber: #f59e0b;
      --app-order-accent-purple: #a855f7;
      --app-order-accent-rose: #f43f5e;
      --app-order-accent-indigo: #6366f1;
      --app-level-action-sell-text: #b91c1c;
      --app-level-action-sell-bg: rgba(248, 113, 113, 0.16);
      --app-level-action-buy-text: #047857;
      --app-level-action-buy-bg: rgba(16, 185, 129, 0.16);
      --app-level-action-grid-text: #0f172a;
      --app-level-action-grid-bg: rgba(15, 23, 42, 0.07);
      --app-level-action-split-text: #1d4ed8;
      --app-level-action-split-bg: rgba(59, 130, 246, 0.16);
      --app-badge-emerald-bg: #d1fae5;
      --app-badge-emerald-text: #047857;
      --app-badge-sky-bg: #e0f2fe;
      --app-badge-sky-text: #0369a1;
      --app-badge-amber-bg: #fef3c7;
      --app-badge-amber-border: #fcd34d;
      --app-badge-amber-text: #b45309;
      --app-badge-purple-bg: #f3e8ff;
      --app-badge-purple-text: #6b21a8;
      --app-badge-rose-bg: #ffe4e6;
      --app-badge-rose-text: #be123c;
      --app-badge-indigo-bg: #e0e7ff;
      --app-badge-indigo-text: #4338ca;
      --app-timeline-bg: linear-gradient(135deg, #f8fbff, #f1f5f9);
      --app-timeline-border: #e2e8f0;
      --app-timeline-shadow: 0 12px 28px rgba(15, 23, 42, 0.08);
      --app-timeline-chip-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.05), 0 8px 18px rgba(15, 23, 42, 0.06);
      --app-timeline-chip-icon-bg: rgba(255, 255, 255, 0.42);
      --app-timeline-chip-icon-border: rgba(255, 255, 255, 0.28);
      --app-timeline-chip-time: rgba(15, 23, 42, 0.8);
      --app-timeline-axis-text: #475569;
      --app-timeline-axis-strong: #0f172a;
      --app-timeline-axis-line: rgba(148, 163, 184, 0.35);
      --app-timeline-axis-tick: rgba(148, 163, 184, 0.7);
      --app-timeline-now: #fbbf24;
      --app-timeline-now-ring: rgba(251, 191, 36, 0.25);
      --app-timeline-now-glow-start: rgba(251, 191, 36, 0.16);
      --app-timeline-now-glow-end: rgba(251, 191, 36, 0.08);
      --app-live-panel-bg: transparent;
      --app-live-panel-border: #e2e8f0;
      --session-overnight-bg: #e2e8f0;
      --session-overnight-text: #0f172a;
      --session-premarket-bg: #fcd34d;
      --session-premarket-text: #92400e;
      --session-market-bg: rgba(34, 197, 94, 0.85);
      --session-market-text: #064e3b;
      --session-afterhours-bg: #7c9cf5;
      --session-afterhours-text: #1e3a8a;
    }

    html[data-theme="dark"] {
      color-scheme: dark;
      --app-bg: #0b1120;
      --app-surface: #111827;
      --app-surface-muted: #0f172a;
      --app-surface-strong: #1f2937;
      --app-border: #1f2937;
      --app-border-muted: rgba(148, 163, 184, 0.2);
      --app-text: #f8fafc;
      --app-text-muted: #cbd5e1;
      --app-text-subtle: #94a3b8;
      --app-header-bg: rgba(15, 23, 42, 0.92);
      --app-header-border: #1f2937;
      --app-sidebar-bg: #0f172a;
      --app-tabbar-bg: #0f172a;
      --app-shadow-soft: 0 25px 45px rgba(0, 0, 0, 0.35);
      --app-shadow-elevated: 0 16px 32px rgba(0, 0, 0, 0.45);
      --app-log-bg: #0b1221;
      --app-log-border: rgba(148, 163, 184, 0.25);
      --app-chart-card-bg: #111827;
      --app-chart-card-border: rgba(31, 41, 55, 0.9);
      --app-chart-stat-bg: rgba(15, 23, 42, 0.9);
      --app-chart-stat-border: rgba(31, 41, 55, 0.9);
      --app-chart-dot: rgba(148, 163, 184, 0.55);
      --app-chart-dot-hover: rgba(148, 163, 184, 0.8);
      --app-chart-overlay-bg: rgba(15, 23, 42, 0.72);
      --app-chart-key-harvest: rgba(52, 211, 153, 0.95);
      --app-chart-key-cash: rgba(167, 139, 250, 0.95);
      --app-chart-axis-text: #94a3b8;
      --app-chart-grid: rgba(148, 163, 184, 0.2);
      --app-chart-legend-text: #e2e8f0;
      --app-chart-cash-line: rgba(167, 139, 250, 0.95);
      --app-chart-cash-fill: rgba(167, 139, 250, 0.2);
      --app-chart-harvest-line: rgba(52, 211, 153, 0.95);
      --app-chart-harvest-fill: rgba(52, 211, 153, 0.2);
      --app-overlay-bg: rgba(2, 6, 23, 0.7);
      --app-overlay-text: #e2e8f0;
      --app-badge-warning-bg: rgba(251, 146, 60, 0.2);
      --app-badge-warning-border: rgba(251, 146, 60, 0.45);
      --app-badge-warning-text: #fdba74;
      --app-badge-neutral-bg: rgba(148, 163, 184, 0.2);
      --app-badge-info-hover: rgba(59, 130, 246, 0.2);
      --app-badge-info-bg: rgba(59, 130, 246, 0.22);
      --app-badge-info-border: rgba(59, 130, 246, 0.85);
      --app-badge-info-ring: rgba(59, 130, 246, 0.35);
      --app-badge-info-text: #bfdbfe;
      --app-badge-success-hover: rgba(16, 185, 129, 0.2);
      --app-badge-success-bg: rgba(16, 185, 129, 0.24);
      --app-badge-success-border: rgba(16, 185, 129, 0.7);
      --app-badge-success-ring: rgba(16, 185, 129, 0.35);
      --app-badge-success-text: #bbf7d0;
      --app-live-badge-on-bg: #10b981;
      --app-live-badge-on-text: #ecfdf5;
      --app-live-badge-off-bg: #1f2937;
      --app-live-badge-off-text: #94a3b8;
      --app-live-badge-off-border: #334155;
      --app-alert-warning-bg: rgba(180, 83, 9, 0.2);
      --app-alert-warning-border: rgba(251, 191, 36, 0.4);
      --app-alert-warning-text: #fcd34d;
      --app-status-inactive-bg: #334155;
      --app-status-idle-bg: #475569;
      --app-status-armed-bg: #22c55edd;
      --app-status-waiting-bg: #f59e0b;
      --app-status-orphan-bg: #8b5cf6;
      --app-card-buy-bg: #14532d;
      --app-card-buy-border: #22c55e;
      --app-card-sell-bg: #4c0519;
      --app-card-sell-border: #f43f5e;
      --app-split-buy-bg: #065f46;
      --app-split-sell-bg: #b45309;
      --app-market-open-bg: linear-gradient(135deg, #064e3b, #0f766e);
      --app-market-open-border: #34d399;
      --app-market-open-text: #d1fae5;
      --app-market-open-shadow: 0 15px 35px rgba(16, 185, 129, 0.35);
      --app-market-open-icon-bg: #065f46;
      --app-market-open-icon-text: #a7f3d0;
      --app-market-closed-bg: linear-gradient(135deg, #7f1d1d, #991b1b);
      --app-market-closed-border: #f87171;
      --app-market-closed-text: #fee2e2;
      --app-market-closed-shadow: 0 15px 35px rgba(248, 113, 113, 0.3);
      --app-market-closed-icon-bg: #7f1d1d;
      --app-market-closed-icon-text: #fecaca;
      --app-market-guard-bg: linear-gradient(135deg, #78350f, #92400e);
      --app-market-guard-border: #fbbf24;
      --app-market-guard-text: #fef3c7;
      --app-market-guard-shadow: 0 15px 35px rgba(250, 204, 21, 0.25);
      --app-market-guard-icon-bg: #78350f;
      --app-market-guard-icon-text: #fde68a;
      --app-pill-neutral-bg: linear-gradient(135deg, #1f2937, #111827);
      --app-pill-neutral-border: #334155;
      --app-pill-neutral-text: #e2e8f0;
      --app-pill-buy-bg: linear-gradient(135deg, #059669, #34d399);
      --app-pill-buy-border: #10b981;
      --app-pill-buy-text: #ecfdf3;
      --app-pill-sell-bg: linear-gradient(135deg, #be123c, #f43f5e);
      --app-pill-sell-border: #f43f5e;
      --app-pill-sell-text: #ffe4e6;
      --app-accent: #60a5fa;
      --app-accent-strong: #3b82f6;
      --app-scrollbar-thumb: rgba(148, 163, 184, 0.45);
      --app-sort-indicator: #475569;
      --app-spinner-border: rgba(148, 163, 184, 0.35);
      --app-tooltip-bg: #0b1221;
      --app-tooltip-text: #f8fafc;
      --app-tooltip-shadow: 0 20px 45px rgba(0, 0, 0, 0.5);
      --app-tooltip-button-bg: #111827;
      --app-tooltip-button-border: rgba(148, 163, 184, 0.2);
      --app-tooltip-button-text: #e2e8f0;
      --app-tooltip-button-hover-bg: #1e293b;
      --app-tooltip-button-hover-border: rgba(16, 185, 129, 0.5);
      --app-tooltip-button-ring: rgba(52, 211, 153, 0.45);
      --app-tooltip-button-success-bg: #059669;
      --app-tooltip-button-success-border: #059669;
      --app-tooltip-button-success-text: #ecfdf3;
      --app-tooltip-close-bg: rgba(15, 23, 42, 0.7);
      --app-tooltip-close-hover-bg: rgba(15, 23, 42, 0.95);
      --app-tooltip-close-text: #cbd5f5;
      --app-tooltip-close-hover-text: #ffffff;
      --app-tooltip-code-bg: rgba(148, 163, 184, 0.15);
      --app-tooltip-code-border: rgba(148, 163, 184, 0.25);
      --app-focus-ring: rgba(16, 185, 129, 0.45);
      --app-segment-active-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
      --app-pull-bg: rgba(15, 23, 42, 0.85);
      --app-pull-border: rgba(148, 163, 184, 0.35);
      --app-pull-text: #cbd5e1;
      --app-pull-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
      --app-border-strong: #334155;
      --app-row-hover-bg: rgba(16, 185, 129, 0.16);
      --app-row-selected-bg: rgba(16, 185, 129, 0.24);
      --app-row-selected-ring: rgba(16, 185, 129, 0.45);
      --app-checkbox-border: #64748b;
      --app-checkbox-bg: #0f172a;
      --app-checkbox-indeterminate-bg: #1f2937;
      --app-checkbox-indeterminate-border: #64748b;
      --app-checkbox-indeterminate-icon: #94a3b8;
      --app-level-metric-bg: rgba(15, 23, 42, 0.9);
      --app-level-metric-border: rgba(31, 41, 55, 0.9);
      --app-level-metric-label: rgba(148, 163, 184, 0.9);
      --app-level-bar-bg: #0f172a;
      --app-level-bar-border: rgba(148, 163, 184, 0.18);
      --app-level-bar-divider: rgba(148, 163, 184, 0.35);
      --app-level-marker: rgba(148, 163, 184, 0.4);
      --app-level-price-label: #e2e8f0;
      --app-level-price-dot: #22c55e;
      --app-level-price-dot-border: #ecfeff;
      --app-level-price-dot-shadow: 0 2px 6px rgba(34, 197, 94, 0.3);
      --app-menu-bg: #0b1221;
      --app-menu-text: #e2e8f0;
      --app-menu-border: rgba(148, 163, 184, 0.25);
      --app-menu-item-bg: rgba(148, 163, 184, 0.08);
      --app-menu-item-border: rgba(148, 163, 184, 0.18);
      --app-menu-item-text: #e2e8f0;
      --app-menu-item-hover-bg: rgba(16, 185, 129, 0.2);
      --app-menu-item-hover-border: rgba(16, 185, 129, 0.5);
      --app-menu-item-hover-text: #bbf7d0;
      --app-sheet-bg: #0f172a;
      --app-sheet-text: #e2e8f0;
      --app-sheet-border: rgba(148, 163, 184, 0.2);
      --app-sheet-shadow: 0 -18px 45px rgba(0, 0, 0, 0.5);
      --app-sheet-backdrop: rgba(2, 6, 23, 0.6);
      --app-sheet-handle: rgba(148, 163, 184, 0.35);
      --app-sheet-title: #f8fafc;
      --app-sheet-subtitle: #94a3b8;
      --app-sheet-close: #cbd5e1;
      --app-sheet-close-hover: #34d399;
      --app-sheet-item-bg: #111827;
      --app-sheet-item-text: #e2e8f0;
      --app-sheet-item-border: rgba(148, 163, 184, 0.22);
      --app-sheet-item-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
      --app-sheet-item-hover-border: rgba(52, 211, 153, 0.6);
      --app-sheet-item-hover-shadow: 0 12px 28px rgba(16, 185, 129, 0.2);
      --app-sheet-icon-bg: rgba(148, 163, 184, 0.15);
      --app-sheet-icon-text: #e2e8f0;
      --app-negative-text: #f87171;
      --app-highlight-symbol: #fcd34d;
      --app-market-pill-shadow: inset 0 1px 0 rgba(15, 23, 42, 0.6), 0 15px 35px rgba(0, 0, 0, 0.35);
      --app-market-icon-shadow: inset 0 1px 0 rgba(15, 23, 42, 0.4), 0 8px 18px rgba(0, 0, 0, 0.4);
      --app-meta-tile-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
      --app-on-accent-text: #ffffff;
      --app-meta-text: #ffffff;
      --app-meta-subtext: rgba(255, 255, 255, 0.85);
      --app-success-border: #10b981;
      --app-success-ring: rgba(16, 185, 129, 0.25);
      --app-on-success-text: #ffffff;
      --app-order-ref-default: #cbd5e1;
      --app-order-ref-buy: #34d399;
      --app-order-ref-sell: #f87171;
      --app-order-accent-emerald: #34d399;
      --app-order-accent-sky: #38bdf8;
      --app-order-accent-amber: #fbbf24;
      --app-order-accent-purple: #c084fc;
      --app-order-accent-rose: #fb7185;
      --app-order-accent-indigo: #818cf8;
      --app-level-action-sell-text: #f87171;
      --app-level-action-sell-bg: rgba(248, 113, 113, 0.2);
      --app-level-action-buy-text: #34d399;
      --app-level-action-buy-bg: rgba(16, 185, 129, 0.2);
      --app-level-action-grid-text: #e2e8f0;
      --app-level-action-grid-bg: rgba(148, 163, 184, 0.15);
      --app-level-action-split-text: #93c5fd;
      --app-level-action-split-bg: rgba(59, 130, 246, 0.2);
      --app-badge-emerald-bg: rgba(16, 185, 129, 0.2);
      --app-badge-emerald-text: #6ee7b7;
      --app-badge-sky-bg: rgba(56, 189, 248, 0.2);
      --app-badge-sky-text: #7dd3fc;
      --app-badge-amber-bg: rgba(251, 191, 36, 0.2);
      --app-badge-amber-border: rgba(251, 191, 36, 0.45);
      --app-badge-amber-text: #fcd34d;
      --app-badge-purple-bg: rgba(192, 132, 252, 0.2);
      --app-badge-purple-text: #e9d5ff;
      --app-badge-rose-bg: rgba(251, 113, 133, 0.2);
      --app-badge-rose-text: #fda4af;
      --app-badge-indigo-bg: rgba(129, 140, 248, 0.2);
      --app-badge-indigo-text: #c7d2fe;
      --app-timeline-bg: linear-gradient(135deg, #0f172a, #111827);
      --app-timeline-border: #1f2937;
      --app-timeline-shadow: 0 12px 28px rgba(0, 0, 0, 0.4);
      --app-timeline-chip-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.4), 0 8px 18px rgba(0, 0, 0, 0.4);
      --app-timeline-chip-icon-bg: rgba(15, 23, 42, 0.35);
      --app-timeline-chip-icon-border: rgba(148, 163, 184, 0.25);
      --app-timeline-chip-time: rgba(226, 232, 240, 0.8);
      --app-timeline-axis-text: #94a3b8;
      --app-timeline-axis-strong: #e2e8f0;
      --app-timeline-axis-line: rgba(148, 163, 184, 0.2);
      --app-timeline-axis-tick: rgba(148, 163, 184, 0.45);
      --app-timeline-now: #fbbf24;
      --app-timeline-now-ring: rgba(251, 191, 36, 0.35);
      --app-timeline-now-glow-start: rgba(251, 191, 36, 0.2);
      --app-timeline-now-glow-end: rgba(251, 191, 36, 0.1);
      --app-live-panel-bg: transparent;
      --app-live-panel-border: var(--app-border);
      --session-overnight-bg: #1f2937;
      --session-overnight-text: #e2e8f0;
      --session-premarket-bg: #f59e0b;
      --session-premarket-text: #1f2937;
      --session-market-bg: rgba(34, 197, 94, 0.35);
      --session-market-text: #bbf7d0;
      --session-afterhours-bg: #3b82f6;
      --session-afterhours-text: #eff6ff;
    }

    html,
    body {
      background: var(--app-bg);
      color: var(--app-text);
    }
    .bg-white {
      background-color: var(--app-surface) !important;
    }
    .bg-slate-50 {
      background-color: var(--app-bg) !important;
    }
    .bg-slate-100 {
      background-color: var(--app-surface-muted) !important;
    }
    .bg-slate-200 {
      background-color: var(--app-surface-strong) !important;
    }
    .text-slate-500 {
      color: var(--app-text-subtle) !important;
    }
    .text-slate-600,
    .text-slate-700 {
      color: var(--app-text-muted) !important;
    }
    .text-slate-800,
    .text-slate-900 {
      color: var(--app-text) !important;
    }
    .border-slate-100 {
      border-color: var(--app-border-muted) !important;
    }
    .border-slate-200 {
      border-color: var(--app-border) !important;
    }
    .border-slate-300 {
      border-color: var(--app-border-strong) !important;
    }
    .hover\\:bg-slate-50:hover {
      background-color: var(--app-row-hover-bg) !important;
    }
    .hover\\:bg-slate-100:hover {
      background-color: var(--app-surface-muted) !important;
    }
    .bg-emerald-50 {
      background-color: var(--app-row-selected-bg) !important;
    }
    .shadow-soft {
      box-shadow: var(--app-shadow-soft);
    }
    .sticky-th {
      background: var(--app-surface);
    }
    thead th {
      background: var(--app-surface);
    }
    input:not([type="checkbox"]):not([type="radio"]),
    select,
    textarea {
      background-color: var(--app-surface);
      color: var(--app-text);
      border-color: var(--app-border);
    }
    input::placeholder,
    textarea::placeholder {
      color: var(--app-text-subtle);
    }
    .num-pos { color: #119d6e !important; }
    .num-neg { color: #ff0000 !important; }
    .pnl-strong { font-size: 1.8rem !important; }
    .sticky-th { position: sticky; top: 0; background: var(--app-surface); z-index: 1; }
    .shadow-soft { box-shadow: var(--app-shadow-soft); }
    thead th { position: sticky; top: 0; background: var(--app-surface); z-index: 1; }
    th.sortable button {
      width: 100%;
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.35rem;
      font: inherit;
      color: inherit;
      background: transparent;
      border: none;
      padding: 0;
      cursor: pointer;
    }
    th.sortable button:focus-visible {
      outline: 2px solid var(--app-focus-ring);
      outline-offset: 2px;
    }
    th.sortable .sort-indicator {
      font-size: 0.65rem;
      opacity: 0.4;
    }
    th[data-sort="asc"] .sort-indicator::after {
      content: "▲";
      opacity: 0.9;
    }
    th[data-sort="desc"] .sort-indicator::after {
      content: "▼";
      opacity: 0.9;
    }
    th[data-sort="none"] .sort-indicator::after {
      content: "";
      opacity: 0;
    }

    /* Hide native spin buttons for key numeric inputs */
    #inp_orb_m::-webkit-outer-spin-button,
    #inp_orb_m::-webkit-inner-spin-button,
    #inp_target_R::-webkit-outer-spin-button,
    #inp_target_R::-webkit-inner-spin-button,
    #inp_stop_R::-webkit-outer-spin-button,
    #inp_stop_R::-webkit-inner-spin-button,
    #inp_risk_pct::-webkit-outer-spin-button,
    #inp_risk_pct::-webkit-inner-spin-button,
    #inp_aum0::-webkit-outer-spin-button,
    #inp_aum0::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    #inp_orb_m,
    #inp_target_R,
    #inp_stop_R,
    #inp_risk_pct,
    #inp_aum0 {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Generic: hide spinners for any future number input */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Segment controls responsive layout */
    #tickerSegment {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      grid-auto-rows: 1fr;
      width: 100%;
      gap: 1px;
    }
    #tickerSegment button {
      width: 100%;
      height: 100%;
    }
    #sessionSegment {
      display: flex;
      flex-wrap: wrap;
      max-width: 100%;
      min-width: 0;
      white-space: normal;
    }
    #sessionSegment button {
      flex: 0 0 auto;
    }
    .summary-tile {
      position: relative;
    }
    .summary-tile .summary-tooltip {
      position: absolute;
      left: 50%;
      bottom: calc(100% + 0.5rem);
      transform: translate(-50%, 0) scale(0.98);
      transform-origin: bottom center;
      background: var(--app-tooltip-bg);
      color: var(--app-tooltip-text);
      padding: 0.65rem 0.75rem;
      border-radius: 0.65rem;
      text-align: left;
      font-size: 0.75rem;
      line-height: 1.25;
      width: max(14rem, min(18rem, 70vw));
      box-shadow: var(--app-tooltip-shadow);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 40;
    }
    .summary-tile .summary-tooltip::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: var(--app-tooltip-bg) transparent transparent transparent;
    }
    .summary-tile:hover .summary-tooltip,
    .summary-tile:focus-within .summary-tooltip {
      opacity: 1;
      transform: translate(-50%, -0.35rem) scale(1);
    }
    #gridTradesSection table {
      color: var(--app-text-muted);
    }
    #gridTradesSection thead {
      background-color: var(--app-surface-muted);
      color: var(--app-text-subtle);
    }
    #gridTradesSection thead th {
      color: var(--app-text-subtle);
    }
    #gridTradesSection tbody td:not(.text-emerald-600):not(.text-red-600) {
      color: var(--app-text-muted);
    }
    #gridTradesSection tbody tr {
      border-color: var(--app-border-muted);
    }
    #gridTradesSection table,
    #gridTradesSection thead tr {
      border-color: var(--app-border-muted);
    }
    #gridTradesSection .divide-slate-100 > :not([hidden]) ~ :not([hidden]),
    #gridTradesSection .divide-slate-200 > :not([hidden]) ~ :not([hidden]) {
      border-color: var(--app-border-muted);
    }
    #batchResultsSection table {
      color: var(--app-text-muted);
    }
    #batchResultsSection thead {
      background-color: var(--app-surface-muted);
      color: var(--app-text-subtle);
    }
    #batchResultsSection thead th {
      color: var(--app-text-subtle);
    }
    #batchResultsSection tbody td {
      color: var(--app-text-muted);
    }
    #batchResultsSection tbody tr {
      border-color: var(--app-border-muted);
    }
    #batchResultsSection table,
    #batchResultsSection thead tr {
      border-color: var(--app-border-muted);
    }
    #batchResultsSection .divide-slate-100 > :not([hidden]) ~ :not([hidden]),
    #batchResultsSection .divide-slate-200 > :not([hidden]) ~ :not([hidden]) {
      border-color: var(--app-border-muted);
    }
    .table-row:hover {
      background-color: var(--app-row-hover-bg) !important;
    }
    .table-row.table-row-selected {
      background-color: var(--app-row-selected-bg) !important;
      box-shadow: inset 0 0 0 1px var(--app-row-selected-ring);
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Site navigation -->
  <nav class="bg-white border-b border-slate-200 sticky top-0 z-50 shadow-sm">
    <div class="max-w-screen-2xl mx-auto px-6 py-3 flex items-center gap-4">
      <div class="flex items-center gap-6 flex-1 min-w-0">
        <div class="flex items-center gap-2 font-semibold text-slate-800">
          <svg class="h-5 w-5 text-emerald-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" fill="currentColor" aria-hidden="true"><path d="M192 384L88.5 384C63.6 384 48.3 356.9 61.1 335.5L114 247.3C122.7 232.8 138.3 224 155.2 224L250.2 224C326.3 95.1 439.8 88.6 515.7 99.7C528.5 101.6 538.5 111.6 540.3 124.3C551.4 200.2 544.9 313.7 416 389.8L416 484.8C416 501.7 407.2 517.3 392.7 526L304.5 578.9C283.2 591.7 256 576.3 256 551.5L256 448C256 412.7 227.3 384 192 384L191.9 384zM464 224C464 197.5 442.5 176 416 176C389.5 176 368 197.5 368 224C368 250.5 389.5 272 416 272C442.5 272 464 250.5 464 224z"/></svg>
          <span>GRID</span>
        </div>
        <div class="flex items-center gap-2 flex-wrap">
          <a data-nav href="grid.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Grid Backtest</a>
          <a data-nav href="grid_calc.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Grid Calculator</a>
          <a data-nav href="grid_about.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">About</a>
        </div>
      </div>
      <label class="inline-flex items-center gap-2 text-xs text-slate-500 cursor-pointer">
        <span>Dark mode</span>
        <span class="relative inline-flex h-5 w-9 items-center">
          <input id="toggleTheme" type="checkbox" class="peer sr-only">
          <span class="absolute inset-0 rounded-full bg-slate-200 transition peer-checked:bg-emerald-500"></span>
          <span class="absolute left-0.5 h-4 w-4 rounded-full bg-white shadow-sm transition peer-checked:translate-x-4"></span>
        </span>
      </label>
    </div>
  </nav>
  <script>
    // Activate nav item for current page
    (function(){
      try {
        const file = (location.pathname.split('/').pop() || 'grid.html').toLowerCase();
        document.querySelectorAll('a[data-nav]').forEach(a => {
          const href = (a.getAttribute('href') || '').toLowerCase();
          const active = href === file || (file === '' && href.endsWith('index.html'));
          a.classList.toggle('bg-slate-800', active);
          a.classList.toggle('text-white', active);
          if (active) {
            a.classList.remove('text-slate-700');
          } else {
            a.classList.add('text-slate-700');
          }
          a.classList.toggle('hover:bg-slate-100', !active);
          if (active) a.setAttribute('aria-current','page'); else a.removeAttribute('aria-current');
        });
      } catch {}
    })();
  </script>

  <div class="max-w-screen-2xl mx-auto p-6 space-y-6">
    <header class="mb-2">
      <h1 id="mainTitle" class="text-2xl md:text-3xl font-semibold">Grid Backtest</h1>
      <!-- <p class="text-slate-600 mt-1">Under construction. Hook up buy-the-dip datasets and controls here.</p> -->
    </header>

    <section id="symbolPicker" class="bg-white rounded-2xl shadow-soft p-3 md:p-4">
      <div class="overflow-x-auto -mx-3 md:mx-0 px-3 md:px-0">
        <nav class="flex min-w-max border-b border-slate-200 gap-1" role="tablist">
          <button type="button" class="inline-flex items-center gap-2 border-b-2 border-blue-500 px-3 py-2 text-sm font-medium text-slate-900 transition">
            <span class="inline-flex h-8 w-8 items-center justify-center text-emerald-500">
              <ion-icon name="grid-outline" class="text-2xl"></ion-icon>
            </span>
            <span>Buy the Dip</span>
          </button>
        </nav>
      </div>

      <div class="flex-1 min-w-0 mt-4">
        <div class="flex flex-wrap items-center gap-2 mb-2">
          <label class="text-sm text-slate-600" for="inpAdhocSymbol">Ad hoc symbol</label>
          <input
            id="inpAdhocSymbol"
            type="text"
            inputmode="text"
            autocomplete="off"
            placeholder="TSLA"
            class="w-28 rounded-lg border border-slate-200 px-3 py-1.5 text-sm text-slate-900 uppercase focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-200"
          >
          <button
            type="button"
            id="btnAdhocGetData"
            class="inline-flex items-center gap-2 rounded-lg bg-slate-900 px-3 py-1.5 text-sm font-semibold text-white shadow-sm transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:bg-slate-400"
          >
            <ion-icon name="download-outline" class="text-base"></ion-icon>
            <span>Get Data</span>
          </button>
          <button
            type="button"
            id="watchlistAddAdhocBtn"
            class="inline-flex items-center gap-2 rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-sm font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50 disabled:cursor-not-allowed disabled:text-slate-400"
            disabled
          >
            <ion-icon name="bookmark-outline" class="text-base"></ion-icon>
            <span>Add to Watchlist</span>
          </button>
        </div>
        <div class="flex flex-wrap items-center gap-2 mb-2">
          <label class="text-sm text-slate-600" for="watchlistSelect">Watchlist</label>
          <div class="relative">
            <select
              id="watchlistSelect"
              class="w-56 appearance-none rounded-lg border border-slate-200 bg-white pl-3 pr-9 py-1.5 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="__all__">All symbols</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
          <button
            type="button"
            id="watchlistNewBtn"
            class="inline-flex items-center gap-1 rounded-lg border border-slate-200 bg-white px-2.5 py-1.5 text-xs font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50"
          >
            New
          </button>
          <button
            type="button"
            id="watchlistDeleteBtn"
            class="inline-flex items-center gap-1 rounded-lg border border-slate-200 bg-white px-2.5 py-1.5 text-xs font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50 disabled:cursor-not-allowed disabled:text-slate-400"
            disabled
          >
            Delete
          </button>
          <button
            type="button"
            id="watchlistBacktestAllBtn"
            class="inline-flex items-center gap-1 rounded-lg border border-amber-300 bg-amber-300 px-2.5 py-1.5 text-xs font-semibold text-black shadow-sm transition hover:bg-amber-200 disabled:cursor-not-allowed disabled:text-slate-400"
          >
            Backtest All
          </button>
        </div>
        <div class="flex items-center gap-2 mb-2">
          <div class="flex-1 min-w-0">
            <div id="tickerSegment" class="w-full rounded-xl border border-slate-200 bg-slate-200 p-px overflow-hidden">
              <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
            </div>
          </div>
        </div>
        <div class="flex items-center gap-2 text-xs text-slate-500">
          <label class="inline-flex items-center gap-2 cursor-pointer">
            <input id="toggleDownsample" type="checkbox" class="h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-500" checked>
            <span>Downsample to 10m</span>
          </label>
        </div>
        <div id="status" class="text-xs text-slate-500 whitespace-normal break-words"></div>
        <div class="mt-2 flex items-center justify-end">
          <label class="inline-flex items-center gap-2 text-xs text-slate-500 cursor-pointer">
            <span>Show Details</span>
            <span class="relative inline-flex h-5 w-9 items-center">
              <input id="toggleSymbolProfile" type="checkbox" class="peer sr-only">
              <span class="absolute inset-0 rounded-full bg-slate-200 transition peer-checked:bg-emerald-500"></span>
              <span class="absolute left-0.5 h-4 w-4 rounded-full bg-white shadow-sm transition peer-checked:translate-x-4"></span>
            </span>
          </label>
        </div>
      </div>
    </section>
    <section id="symbolProfileSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-3 hidden">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Symbol Profile</h2>
        <span id="symbolProfileLabel" class="text-xs text-slate-500"></span>
      </div>
      <div id="tvSymbolProfile" class="min-h-[320px]">
        <div class="text-sm text-slate-500">Select a symbol to load key facts.</div>
      </div>
    </section>

    <section id="gridParameters" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
        <div>
          <h2 class="font-semibold text-slate-700">Grid Parameters</h2>
          <p class="text-sm text-slate-500">Adjust spacing and sizing, then run the backtest on the loaded symbol.</p>
        </div>
        <div class="flex flex-wrap gap-2">
          <button
            type="button"
            id="btnRunGridBacktest"
            class="inline-flex items-center justify-center gap-2 rounded-xl bg-emerald-600 px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-emerald-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-500 disabled:cursor-not-allowed disabled:bg-slate-300"
            disabled
          >
            <ion-icon name="play-outline" class="text-lg"></ion-icon>
            <span>Run Backtest</span>
          </button>
          <button
            type="button"
            id="btnSaveGridBacktest"
            class="inline-flex items-center justify-center gap-2 rounded-xl border border-slate-300 bg-white px-4 py-2 text-sm font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-400 disabled:cursor-not-allowed disabled:bg-slate-100"
            disabled
          >
            <ion-icon name="save-outline" class="text-lg"></ion-icon>
            <span>Save Backtest</span>
          </button>
        </div>
      </div>

      <div class="grid gap-4 md:grid-cols-8">
        <label class="block">
          <span class="text-sm text-slate-600">Grid Type</span>
          <div class="mt-1 rounded-xl border border-slate-200 bg-slate-50 px-3 py-2 text-sm text-slate-700">
            Buy the Dip
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Entry Filter</span>
          <div class="relative mt-1">
            <select
              id="selEntryFilter"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="none" selected>None</option>
              <option value="sma10">10 SMA</option>
              <option value="sma20">20 SMA</option>
              <option value="sma50">50 SMA</option>
              <option value="sma100">100 SMA</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Retained Shares</span>
          <div class="relative mt-1" title="Choose how much of a profitable leg to leave on after selling the trade-value portion.">
            <select
              id="selRetentionMode"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="none">None</option>
              <option value="profit" selected>Profit Portion</option>
              <option value="profit_plus_5">Profit + 5%</option>
              <option value="profit_plus_10">Profit + 10%</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Grid Spacing</span>
          <div class="relative mt-1">
            <select
              id="selGridSpacing"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="fixed">Fixed Price</option>
              <option value="percent_fixed" selected>Percentage · Fixed Anchor</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span id="gridSizeLabel" class="text-sm text-slate-600">Grid Size ($)</span>
          <div class="mt-1 relative">
            <input
              id="inpGridSize"
              type="number"
              step="0.5"
              min="0.5"
              value="5"
              class="w-full border border-slate-200 bg-white text-slate-700 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            />
            <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase grid size" data-num-target="inpGridSize" data-num-step="1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd" /></svg>
              </button>
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease grid size" data-num-target="inpGridSize" data-num-step="-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd" /></svg>
              </button>
            </div>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Base Price ($)</span>
          <div class="mt-1 relative">
            <input
              id="inpBasePrice"
              type="number"
              step="0.01"
              min="0.01"
              value="100"
              data-default="100"
              class="w-full border border-slate-200 bg-white text-slate-700 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            />
            <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase base price" data-num-target="inpBasePrice" data-num-step="1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd" /></svg>
              </button>
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease base price" data-num-target="inpBasePrice" data-num-step="-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd" /></svg>
              </button>
            </div>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Trade Value ($)</span>
          <input
            id="inpTradeValue"
            type="number"
            step="100"
            min="100"
            value="1000"
            class="mt-1 w-full appearance-none rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
          />
        </label>
        <label class="flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-600 shadow-sm transition focus-within:ring-2 focus-within:ring-emerald-500/60">
          <input
            id="inpFractionalShares"
            type="checkbox"
            class="h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-500"
            checked
          />
          <span>Allow fractional shares</span>
        </label>
      </div>
    </section>

    <section id="gridLevelsSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4 hidden">
      <div class="flex flex-col gap-3 md:flex-row md:items-start md:justify-between">
        <div class="flex flex-col gap-1">
          <h2 class="font-semibold text-slate-700">Grid Levels</h2>
          <p id="gridLevelsSummary" class="text-sm text-slate-500">Run the backtest to list the ladder levels currently seeded for buys and sells.</p>
        </div>
        <button
          type="button"
          id="gridLevelsToggle"
          aria-expanded="false"
          aria-controls="gridLevelsBody"
          class="inline-flex items-center gap-2 self-start rounded-full border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600"
        >
          <span id="gridLevelsToggleLabel">Show Levels</span>
          <svg
            id="gridLevelsChevron"
            xmlns="http://www.w3.org/2000/svg"
            class="h-4 w-4 text-slate-500 transition-transform"
            viewBox="0 0 20 20"
            fill="currentColor"
            aria-hidden="true"
          >
            <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
          </svg>
        </button>
      </div>
      <div id="gridLevelsBody" class="grid gap-4 md:grid-cols-2 hidden">
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm flex flex-col">
          <div class="flex items-center justify-between pb-2 border-b border-slate-100">
            <h3 class="text-sm font-semibold text-slate-600">Buy Levels</h3>
            <span id="gridBuyLevelCount" class="text-xs text-slate-500">0</span>
          </div>
          <div id="gridBuyLevels" class="mt-3 grow overflow-y-auto text-sm text-slate-700 max-h-72">
            <div class="text-slate-500 text-xs">Run the backtest to populate buy levels.</div>
          </div>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm flex flex-col">
          <div class="flex items-center justify-between pb-2 border-b border-slate-100">
            <h3 class="text-sm font-semibold text-slate-600">Sell Levels</h3>
            <span id="gridSellLevelCount" class="text-xs text-slate-500">0</span>
          </div>
          <div id="gridSellLevels" class="mt-3 grow overflow-y-auto text-sm text-slate-700 max-h-72">
            <div class="text-slate-500 text-xs">Run the backtest to populate sell levels.</div>
          </div>
        </div>
      </div>
    </section>

    <section id="gridFiltersSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2">
        <h2 class="font-semibold text-slate-700">Filters</h2>
        <p class="text-sm text-slate-500">Limit the displayed results to specific months.</p>
      </div>
      <div class="relative inline-block" aria-label="Months">
        <button id="sumMonthMultiBtn" type="button" class="inline-flex items-center justify-between gap-2 bg-white text-slate-800 border border-slate-200 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm min-w-[200px]">
          <span id="sumMonthMultiLabel" class="truncate">All months</span>
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
        </button>
        <div id="sumMonthMultiMenu" class="absolute z-30 mt-1 w-64 bg-white border border-slate-200 rounded-xl shadow-soft p-2 hidden">
          <div class="sticky top-0 bg-white z-10 px-2 pb-2 border-b border-slate-200 flex items-center justify-between gap-2">
            <button id="sumMonthSelectAll" type="button" class="text-xs font-medium text-emerald-700 hover:text-emerald-900 hover:underline">Select all</button>
            <button id="sumMonthClearAll" type="button" class="text-xs text-slate-600 hover:text-slate-800 hover:underline">Clear</button>
          </div>
          <div id="sumMonthMultiList" class="max-h-64 overflow-auto text-sm text-slate-700"></div>
        </div>
      </div>
    </section>

    <section id="batchResultsSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4 hidden">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <div>
          <h2 class="font-semibold text-slate-700">Batch Results</h2>
          <p class="text-sm text-slate-500">Backtest all symbols in the active watchlist and compare summary outcomes.</p>
        </div>
        <div id="batchResultsStatus" class="text-xs text-slate-500"></div>
      </div>
      <div class="overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead class="text-[11px] uppercase tracking-wide text-slate-500">
            <tr>
              <th class="px-3 py-2 text-left sortable" data-batch-sort="symbol" data-sort="none"><button type="button"><span>Symbol</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="trades" data-sort="none"><button type="button"><span>Trades</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="netProfit" data-sort="none"><button type="button"><span>Net Profit</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="finalEquity" data-sort="none"><button type="button"><span>Final Equity</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="cash" data-sort="none"><button type="button"><span>Cash</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="shares" data-sort="none"><button type="button"><span>Shares</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="maxDrawdownPct" data-sort="none"><button type="button"><span>Max DD %</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="cagr" data-sort="none"><button type="button"><span>CAGR</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="maxLevels" data-sort="none"><button type="button"><span>Max Levels</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="profitPerLevel" data-sort="none"><button type="button"><span>Profit / Level</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="calmSells" data-sort="none"><button type="button"><span>Calm</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="normalSells" data-sort="none"><button type="button"><span>Normal</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-batch-sort="volatileSells" data-sort="none"><button type="button"><span>Volatile</span><span class="sort-indicator"></span></button></th>
            </tr>
          </thead>
          <tbody id="batchResultsBody" class="divide-y divide-slate-100"></tbody>
        </table>
        <div id="batchResultsEmpty" class="py-6 text-center text-sm text-slate-500">No batch results yet.</div>
      </div>
    </section>

    <section id="gridSummarySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
        <div>
          <h2 class="font-semibold text-slate-700">Summary</h2>
          <p id="gridStatus" class="text-sm text-slate-500">Load data and run the backtest to populate results.</p>
        </div>
        <div class="flex flex-wrap items-center gap-x-6 gap-y-2 text-xs text-slate-500">
          <span title="Final account cash balance (cashBalance).">Cash:</span>
          <span id="summaryCash" class="text-sm font-semibold text-slate-800">$0.00</span>
          <span title="Final holdings quantity.">Shares:</span>
          <span id="summaryShares" class="text-sm font-semibold text-slate-800">0</span>
          <span title="Last trade price used for holdings valuation.">Last Price:</span>
          <span id="summaryLastPrice" class="text-sm font-semibold text-slate-800">—</span>
          <span title="Open levels at the end of the backtest.">Open Levels:</span>
          <span id="summaryOpenLevels" class="text-sm font-semibold text-slate-800">0</span>
        </div>
      </div>
      <div class="grid gap-4 lg:grid-cols-[minmax(0,1fr)_260px]">
        <dl class="grid gap-4 sm:grid-cols-2 lg:grid-cols-5">
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Capital Contributed</dt>
            <dd id="summaryCapitalContributed" class="mt-2 text-xl font-semibold text-slate-800">—</dd>
            <span class="summary-tooltip">Total capital deposited into the strategy over the backtest (autofund deposits). Used for reconciliation: Account Equity = Capital Contributed + Net P/L.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Net Trade Cashflow</dt>
            <dd id="summaryNetCashflow" class="mt-2 text-xl font-semibold text-slate-800">—</dd>
            <span class="summary-tooltip">Net cashflow from trades only (buys negative, sells positive, commissions included). This is the cash ledger truth.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Harvested Profit</dt>
            <dd id="summaryHarvestedProfit" class="mt-2 text-xl font-semibold text-slate-800">—</dd>
            <span class="summary-tooltip">Realized profit from completed trades only (sells minus cost basis). Excludes open inventory and unrealized holdings value.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Holdings Value</dt>
            <dd id="summaryHoldingsValue" class="mt-2 text-xl font-semibold text-slate-800">—</dd>
            <span class="summary-tooltip">Market value of current holdings at the final price: shares × final price.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Net P/L (if liquidated)</dt>
            <dd id="summaryNetProfit" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
            <span class="summary-tooltip">Net P/L if liquidated at the final price: netCashflowTrades + holdingsValue.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Account Equity</dt>
            <dd id="summaryAccountEquity" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
            <span class="summary-tooltip">Account equity at the final price: cashBalance + holdingsValue. Also equals Capital Contributed + Net P/L.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Completed Trades</dt>
            <dd id="summaryTotalTrades" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
            <span class="summary-tooltip">Number of completed SELL executions (fills) recorded by the backtest.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Levels</dt>
            <dd id="summaryMaxLevels" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
            <span class="summary-tooltip">Maximum number of concurrently open grid sell orders (ladder activity metric).</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Profit per Level</dt>
            <dd id="summaryProfitPerLevel" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
            <span class="summary-tooltip">Net P/L normalized by ladder size: net profit ÷ peak open levels.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">CAGR</dt>
            <dd id="summaryCagr" class="mt-2 text-xl font-semibold text-slate-800">0.00%</dd>
            <span class="summary-tooltip">Annualised return using Required Capital as the base: ((Required Capital + Net P/L) / Required Capital) over the backtest period.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Retained Shares</dt>
            <dd id="summaryRetained" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
            <span class="summary-tooltip">Total shares intentionally retained by the retention rule (planned retention only; excludes unsold due to rounding/availability).</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Required Capital</dt>
            <dd id="summaryRequiredCapital" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
            <span class="summary-tooltip">Peak cash required by the strategy, measured as max(-netCashflowTrades). If this is below Capital Contributed, it means harvested profits reduced the net cash needed before the max open levels were reached.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Min Cash</dt>
            <dd id="summaryMinCash" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
            <span class="summary-tooltip">Minimum account cash balance (cashBalance). In autofund mode this may stay near 0; in margin mode it can go negative.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Drawdown</dt>
            <dd id="summaryMaxDD" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
            <span class="summary-tooltip">Worst peak-to-trough drawdown of account equity (cash + holdings value) over the backtest path.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Drawdown %</dt>
            <dd id="summaryMaxDDPct" class="mt-2 text-xl font-semibold text-slate-800">0.00%</dd>
            <span class="summary-tooltip">Max equity drawdown divided by peak equity at the time of the peak.</span>
          </div>
        </dl>
        <dl class="grid gap-4">
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Calm-Day Sells (Median)</dt>
            <dd id="summaryCalmDaySells" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
            <span class="summary-tooltip">Median number of sell fills per day over the selected lookback period. Represents a typical low-volatility or quiet market day and is robust to outlier spikes.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Normal-Market Sells (5–95% Avg)</dt>
            <dd id="summaryNormalMarketSells" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
            <span class="summary-tooltip">Average daily sell fills after excluding the top and bottom 5% of days. Captures expected activity under normal market conditions while filtering extreme volatility events.</span>
          </div>
          <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
            <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Volatility-Day Sells (95th %ile)</dt>
            <dd id="summaryVolatilityDaySells" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
            <span class="summary-tooltip">95th percentile of daily sell fills. Indicates high-activity or stress days and is useful for capacity planning, rate limits, and risk monitoring.</span>
          </div>
        </dl>
      </div>
    </section>

    <section id="gridEquitySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Equity Curve</h2>
        <span id="equitySummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="gridEquityChart" class="w-full h-72 md:h-96"></div>
        <div id="gridEquityEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to plot equity over time.
        </div>
      </div>
    </section>

    <dialog id="watchlistEditDialog" class="rounded-2xl border border-slate-200 p-0 shadow-soft backdrop:bg-slate-900/30">
      <form method="dialog" class="p-5 min-w-[280px]">
        <h3 class="text-sm font-semibold text-slate-800 mb-3">Edit Symbol</h3>
        <label class="block text-xs text-slate-500 mb-2">
          Name
          <input id="watchlistEditName" type="text" class="mt-1 w-full rounded-lg border border-slate-200 px-3 py-1.5 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-200" />
        </label>
        <label class="block text-xs text-slate-500 mb-3">
          Sector
          <input id="watchlistEditSector" type="text" class="mt-1 w-full rounded-lg border border-slate-200 px-3 py-1.5 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-200" />
        </label>
        <label class="block text-xs text-slate-500 mb-3">
          Exchange
          <input id="watchlistEditExchange" type="text" class="mt-1 w-full rounded-lg border border-slate-200 px-3 py-1.5 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-200" />
        </label>
        <div class="flex items-center justify-end gap-2">
          <button type="button" class="rounded-lg border border-slate-200 px-3 py-1.5 text-xs font-semibold text-slate-600 hover:bg-slate-50" onclick="this.closest('dialog').close()">Cancel</button>
          <button type="submit" class="rounded-lg bg-emerald-600 px-3 py-1.5 text-xs font-semibold text-white hover:bg-emerald-500">Save</button>
        </div>
      </form>
    </dialog>

    <section id="gridLadderSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Ladder Activity</h2>
        <span id="ladderSummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="gridLadderChart" class="w-full h-72 md:h-80"></div>
        <div id="gridLadderEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to visualize ladder entries and exits.
        </div>
      </div>
    </section>

    <section id="fillsPerMonthSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Fills per Month</h2>
        <span id="fillsMonthSummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="monthlyFillsChart" class="w-full h-72 md:h-80"></div>
        <div id="monthlyFillsEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to tally fills per month.
        </div>
      </div>
    </section>

    <section id="fillsPerDaySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Fills per Day</h2>
        <span id="fillsDaySummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="dailyFillsChart" class="w-full h-72 md:h-80"></div>
        <div id="dailyFillsEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to tally fills per day.
        </div>
      </div>
    </section>

    <section id="openLevelsSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Open Levels</h2>
        <span id="openLevelsSummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="openLevelsChart" class="w-full h-72 md:h-80"></div>
        <div id="openLevelsEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to view open levels at the end of each day.
        </div>
      </div>
    </section>

    <section id="priceDistributionSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <div class="flex flex-col gap-1">
          <h2 class="font-semibold text-slate-700">Price Fill Distribution</h2>
          <span id="priceDistributionLabel" class="text-sm text-slate-500"></span>
        </div>
        <div id="priceFillToggle" class="inline-flex rounded-full border border-slate-200 bg-slate-100 p-1 text-xs font-semibold text-slate-600">
          <button type="button" data-view="buy" class="px-3 py-1 rounded-full">Buy fills</button>
          <button type="button" data-view="sell" class="px-3 py-1 rounded-full">Sell fills</button>
        </div>
      </div>
      <div class="relative">
        <div id="priceDistributionChart" class="w-full h-72 md:h-80"></div>
        <div id="priceDistributionEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to chart buy fill counts by price.
        </div>
      </div>
    </section>

    <section id="levelDistributionSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Level Fill Distribution</h2>
        <span id="levelDistributionLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="levelDistributionChart" class="w-full h-72 md:h-80"></div>
        <div id="levelDistributionEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to chart sell fills per level.
        </div>
      </div>
    </section>

    <section id="cumulativeLevelDistributionSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Cumulative Level Fill Distribution</h2>
        <span id="cumulativeLevelDistributionLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="cumulativeLevelDistributionChart" class="w-full h-72 md:h-80"></div>
        <div id="cumulativeLevelDistributionEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to see how quickly sell fills accumulate by level.
        </div>
      </div>
    </section>

    <section id="gridTradesSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Trade Log</h2>
        <span id="tradeCountLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="overflow-x-auto">
        <table class="min-w-full divide-y divide-slate-200 text-sm">
          <thead class="bg-slate-50 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">
            <tr>
              <th class="px-3 py-2 sortable" data-sort-key="buyTime"><button type="button"><span>Buy Time</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="buyPrice"><button type="button"><span>Buy Price</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="buyQty"><button type="button"><span>Buy Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="openQty"><button type="button"><span>Open Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="openEquity"><button type="button"><span>Open Equity</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="openLevels"><button type="button"><span>Open Levels</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 sortable" data-sort-key="sellTime"><button type="button"><span>Sell Time</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="sellPrice"><button type="button"><span>Sell Price</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="sellQty"><button type="button"><span>Sell Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="closeQty"><button type="button"><span>Close Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="closeEquity"><button type="button"><span>Close Equity</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="qtyRetained"><button type="button"><span>Qty Retained</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="cumQtyRetained"><button type="button"><span>Cum Retained</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="daysHeld"><button type="button"><span>Days Held</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="profit"><button type="button"><span>Profit $</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="cumProfit"><button type="button"><span>Cum Profit $</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="runningPnl"><button type="button"><span>PnL</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="drawdown"><button type="button"><span>Drawdown</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="roiPct"><button type="button"><span>ROI %</span><span class="sort-indicator"></span></button></th>
            </tr>
          </thead>
          <tbody id="gridTradeRows" class="divide-y divide-slate-100"></tbody>
        </table>
        <div id="gridTradesEmpty" class="py-6 text-center text-sm text-slate-500">Run the backtest to see individual trades.</div>
      </div>
      <div class="mt-3 flex flex-col gap-2 text-xs text-slate-500 sm:flex-row sm:items-center sm:justify-between">
        <div id="tradePaginationInfo"></div>
        <div class="flex flex-wrap items-center gap-2">
          <label for="tradePageSize" class="text-[11px] uppercase tracking-wide font-semibold text-slate-500">Rows per page</label>
          <select id="tradePageSize" class="rounded-lg border border-slate-200 bg-white px-2 py-1 text-xs text-slate-700 focus:outline-none focus:ring-2 focus:ring-emerald-500/60">
            <option value="100">100</option>
            <option value="250" selected>250</option>
            <option value="500">500</option>
            <option value="1000">1000</option>
          </select>
          <div class="inline-flex rounded-full border border-slate-200 bg-white shadow-sm">
            <button id="tradePagePrev" type="button" class="px-3 py-1 text-xs font-semibold text-slate-500 hover:text-emerald-600 disabled:opacity-40 disabled:hover:text-slate-400">&larr; Prev</button>
            <span class="h-6 w-px bg-slate-200 self-center"></span>
            <button id="tradePageNext" type="button" class="px-3 py-1 text-xs font-semibold text-slate-500 hover:text-emerald-600 disabled:opacity-40 disabled:hover:text-slate-400">Next &rarr;</button>
          </div>
        </div>
      </div>
    </section>
  </div>
<script>
  (function(){
    const DEFAULT_PRICE_PRECISION = 2;
    const GRID_DEFAULTS = {
      gridSize: 5,
      gridSpacingType: 'percent_fixed',
      tradeValue: 1000,
      fractionalShares: true,
      entryFilter: 'none'
    };
    const GRID_TYPE = 'buy_the_dip';
    const WATCHLIST_ALL = '__all__';
    const WATCHLIST_DEFAULTS = { active: WATCHLIST_ALL, watchlists: { Default: [] }, symbol_meta: {} };
    const DEFAULT_EXCHANGE = 'NASDAQ';
    const CURRENCY_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const NUMBER_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const NUMBER_FORMAT_4 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 4, maximumFractionDigits: 4 });
    const PERCENT_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const DAILY_SMA_WINDOWS = [10, 20, 50, 100];
    const SMA_FILTER_LOOKUP = {
      sma10: 10,
      sma20: 20,
      sma50: 50,
      sma100: 100
    };
    const DEFAULT_RESAMPLE_INTERVAL_MINUTES = 10;
    let RESAMPLE_INTERVAL_MINUTES = DEFAULT_RESAMPLE_INTERVAL_MINUTES;
    const SMA_PROPERTY_BY_WINDOW = {
      10: 'sma10',
      20: 'sma20',
      50: 'sma50',
      100: 'sma100'
    };
    const SMA_PROPERTIES = Object.values(SMA_PROPERTY_BY_WINDOW);
    const PRICE_FORMATTERS = new Map();
    const THEME_STORAGE_KEY = 'grid_theme';
    const THEME_DARK = 'dark';
    const THEME_LIGHT = 'light';

    const pad2 = (n) => String(n).padStart(2, '0');
    const dateKeyFromStr = (val) => {
      if (val == null) return null;
      if (typeof val === 'string') {
        const m = val.trim().match(/^(\d{4}-\d{2}-\d{2})/);
        if (m) return m[1];
      }
      const d = new Date(val);
      if (isNaN(d)) return null;
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
    };

    function applyTheme(theme) {
      const next = theme === THEME_DARK ? THEME_DARK : THEME_LIGHT;
      document.documentElement.setAttribute('data-theme', next);
      return next;
    }

    function getPreferredTheme() {
      try {
        const stored = localStorage.getItem(THEME_STORAGE_KEY);
        if (stored === THEME_DARK || stored === THEME_LIGHT) return stored;
      } catch {}
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return THEME_DARK;
      }
      return THEME_LIGHT;
    }

    let currentTicker = '';
    let BASE_ROWS = [];
    let ROWS = [];
    let DAY_GROUPS = new Map();
    let DAYS = [];
    let DAY_SMA_MAPS = new Map();
    let SMA_METADATA = new Map();
    let SYMBOL_META = new Map();
    let SYMBOL_LIST_CACHE = null;
    let WATCHLIST_STATE = { ...WATCHLIST_DEFAULTS };
    let LAST_ACTIVE_WATCHLIST = 'Default';
    let LAST_ADHOC_SYMBOL = '';
    let GRID_STATE = { trades: [], summary: null, equitySeries: [], ladderHistory: [], buyLevels: [], sellLevels: [], baseLevel: null, gridLevels: [] };
    let BACKTEST_ALL_RESULTS = [];
    let BACKTEST_ALL_RUNNING = false;
    let BACKTEST_ALL_SELECTED = '';
    let BACKTEST_ALL_SORT = { key: 'symbol', dir: 'asc' };
    let TRADE_SORT_STATE = { key: 'buyTime', dir: 'asc' };
    let gridEquityChartInst = null;
    let gridLadderChartInst = null;
    let fillsPerDayChartInst = null;
    let fillsPerMonthChartInst = null;
    let openLevelsChartInst = null;
    let priceDistributionChartInst = null;
    let levelDistributionChartInst = null;
    let cumulativeLevelDistributionChartInst = null;
    let AVAILABLE_MONTHS = [];
    let VIEW_MONTHS = new Set();
    let PRICE_DISTRIBUTION_VIEW = 'buy';
    const TRADE_TABLE_STATE = { page: 1, pageSize: 250 };

    function setStatus(msg) {
      const el = document.getElementById('status');
      if (el) el.textContent = msg || '';
    }

    function formatResampleLabel(minutes) {
      const interval = Number(minutes);
      if (!Number.isFinite(interval) || interval <= 1) return '1-minute';
      return `${Math.max(1, Math.floor(interval))}-minute`;
    }

    function updateLoadedStatus() {
      if (!Array.isArray(ROWS) || !ROWS.length) {
        setStatus('');
        return;
      }
      const label = formatResampleLabel(RESAMPLE_INTERVAL_MINUTES);
      setStatus(`Loaded ${ROWS.length.toLocaleString()} ${label} bars across ${DAYS.length.toLocaleString()} day(s).`);
    }

    function updateLoadedGridStatus(suffix) {
      if (!Array.isArray(ROWS) || !ROWS.length) return;
      const label = formatResampleLabel(RESAMPLE_INTERVAL_MINUTES);
      const tail = suffix ? ` ${suffix}` : '';
      setGridStatus(`Loaded ${ROWS.length.toLocaleString()} ${label} bars across ${DAYS.length.toLocaleString()} day(s).${tail}`);
    }

    function setGridStatus(msg) {
      const el = document.getElementById('gridStatus');
      if (el) el.textContent = msg || '';
    }

    function setBatchResultsStatus(msg) {
      const el = document.getElementById('batchResultsStatus');
      if (el) el.textContent = msg || '';
    }

    function setRunButtonEnabled(enabled) {
      const btn = document.getElementById('btnRunGridBacktest');
      if (!btn) return;
      btn.disabled = !enabled;
      btn.classList.toggle('opacity-70', !enabled);
    }

    function setSaveButtonEnabled(enabled) {
      const btn = document.getElementById('btnSaveGridBacktest');
      if (!btn) return;
      btn.disabled = !enabled;
      btn.classList.toggle('opacity-70', !enabled);
    }

    function updateGridSizeLabel() {
      const label = document.getElementById('gridSizeLabel');
      if (!label) return;
      const spacingType = (document.getElementById('selGridSpacing')?.value || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const percentMode = spacingType.startsWith('percent');
      label.textContent = percentMode ? 'Grid Size (%)' : 'Grid Size ($)';
      const input = document.getElementById('inpGridSize');
      if (input) {
        if (percentMode) {
          input.min = '0.5';
          input.step = '0.5';
        } else {
          input.min = '0.5';
          input.step = '0.5';
        }
      }
    }

    function ensureSymbolMetaEntry(symbol) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return null;
      if (!SYMBOL_META.has(sym)) {
        SYMBOL_META.set(sym, {
          symbol: sym,
          name: sym,
          sector: '',
          exchange: DEFAULT_EXCHANGE,
          multiplier: 1,
          precision: DEFAULT_PRICE_PRECISION,
          basePrice: 100,
          tickSize: 0.01
        });
      }
      const meta = SYMBOL_META.get(sym);
      if (meta && !meta.symbol) meta.symbol = sym;
      if (meta && !normalizeExchange(meta.exchange)) meta.exchange = DEFAULT_EXCHANGE;
      return meta || null;
    }

    function normalizeExchange(value) {
      if (typeof value !== 'string') return '';
      return value.trim().toUpperCase();
    }

    function countPriceDecimals(value) {
      if (!Number.isFinite(value)) return 0;
      const str = Number(value).toFixed(8).replace(/0+$/,'').replace(/\.$/,'');
      const idx = str.indexOf('.');
      return idx >= 0 ? (str.length - idx - 1) : 0;
    }

    function inferPricePrecisionFromRows(rows) {
      if (!Array.isArray(rows)) return DEFAULT_PRICE_PRECISION;
      let maxDecimals = 0;
      const limit = Math.min(rows.length, 400);
      for (let i = 0; i < limit; i++) {
        const row = rows[i];
        if (!row) continue;
        const values = [row.open, row.high, row.low, row.close];
        for (const val of values) {
          const decimals = countPriceDecimals(val);
          if (decimals > maxDecimals) {
            maxDecimals = decimals;
            if (maxDecimals >= 6) return 6;
          }
        }
      }
      return Math.min(Math.max(maxDecimals, DEFAULT_PRICE_PRECISION), 8);
    }

    function updateSymbolPrecisionFromRows(symbol, rows) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return;
      const precision = inferPricePrecisionFromRows(rows);
      const meta = ensureSymbolMetaEntry(sym);
      if (meta) {
        meta.precision = precision;
        SYMBOL_META.set(sym, meta);
      }
    }

    function findFirstPriceFromRows(rows) {
      if (!Array.isArray(rows) || !rows.length) return null;
      for (const row of rows) {
        if (!row) continue;
        const candidates = [row.open, row.close, row.high, row.low];
        for (const val of candidates) {
          if (Number.isFinite(val) && val > 0) return Number(val);
        }
      }
      return null;
    }

    function roundUpBaseAnchor(maxPrice) {
      if (!Number.isFinite(maxPrice) || maxPrice <= 0) return null;
      let step = 1;
      if (maxPrice > 100) {
        step = 100;
      } else if (maxPrice > 1) {
        step = 10;
      }
      return Math.ceil(maxPrice / step) * step;
    }

    function updateSymbolBasePriceFromRows(symbol) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return;
      const rows = Array.isArray(BASE_ROWS) && BASE_ROWS.length ? BASE_ROWS : ROWS;
      if (!Array.isArray(rows) || !rows.length) return;
      let minPrice = Number.POSITIVE_INFINITY;
      let maxPrice = Number.NEGATIVE_INFINITY;
      for (const row of rows) {
        if (!row) continue;
        const low = Number(row.low);
        const high = Number(row.high);
        if (Number.isFinite(low)) minPrice = Math.min(minPrice, low);
        if (Number.isFinite(high)) maxPrice = Math.max(maxPrice, high);
      }
      if (!Number.isFinite(minPrice) || !Number.isFinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) return;
      const meta = ensureSymbolMetaEntry(sym);
      if (!meta) return;
      const roundedBase = roundUpBaseAnchor(maxPrice);
      if (!Number.isFinite(roundedBase) || roundedBase <= 0) return;
      meta.basePrice = roundedBase;
      SYMBOL_META.set(sym, meta);
      updateBasePriceInput(sym);
    }

    function countDecimals(value) {
      if (!Number.isFinite(value)) return 0;
      const s = String(value);
      if (!s.includes('.')) return 0;
      const trimmed = s.replace(/0+$/, '');
      const idx = trimmed.indexOf('.');
      return idx >= 0 ? (trimmed.length - idx - 1) : 0;
    }

    function decimalsFromStep(step) {
      if (!Number.isFinite(step)) return 0;
      const s = String(step);
      const idx = s.indexOf('.');
      return idx === -1 ? 0 : (s.length - idx - 1);
    }

    function snapToTick(value, tick) {
      if (!Number.isFinite(value) || !Number.isFinite(tick) || tick <= 0) return value;
      const snapped = Math.round(value / tick) * tick;
      const d = decimalsFromStep(tick);
      return Number(snapped.toFixed(Math.min(Math.max(d, 0), 8)));
    }

    function formatCurrency(value) {
      if (!Number.isFinite(value)) return '$0.00';
      return `$${CURRENCY_FORMAT.format(value)}`;
    }

    function formatNumber(value, digits = 2) {
      if (!Number.isFinite(value)) return digits === 4 ? '0.0000' : '0.00';
      if (digits === 4) return NUMBER_FORMAT_4.format(value);
      return NUMBER_FORMAT.format(value);
    }

    function getActiveTickSize(symbol) {
      const meta = ensureSymbolMetaEntry(symbol || currentTicker);
      const tickSize = Number(meta?.tickSize);
      return Number.isFinite(tickSize) && tickSize > 0 ? tickSize : 0.01;
    }

    function updateBasePriceInput(symbol) {
      const input = document.getElementById('inpBasePrice');
      if (!input) return;
      const meta = ensureSymbolMetaEntry(symbol || currentTicker);
      const basePrice = Number.isFinite(meta?.basePrice) ? meta.basePrice : 100;
      const tickSize = getActiveTickSize(symbol || currentTicker);
      const digits = countDecimals(tickSize);
      const valueStr = Number.isFinite(basePrice)
        ? (digits > 0 ? basePrice.toFixed(digits) : String(Math.round(basePrice)))
        : '100';
      input.step = String(tickSize);
      input.min = String(tickSize);
      input.value = valueStr;
      input.setAttribute('data-default', valueStr);
    }

    function getActivePricePrecision() {
      const meta = ensureSymbolMetaEntry(currentTicker);
      const precision = meta && Number.isInteger(meta.precision) ? meta.precision : DEFAULT_PRICE_PRECISION;
      return Math.min(Math.max(precision, 0), 8);
    }

    function formatPrice(value, precision) {
      const digits = Number.isInteger(precision) ? Math.min(Math.max(precision, 0), 8) : DEFAULT_PRICE_PRECISION;
      if (!Number.isFinite(value)) {
        return digits ? `0.${'0'.repeat(digits)}` : '0';
      }
      let formatter = PRICE_FORMATTERS.get(digits);
      if (!formatter) {
        formatter = new Intl.NumberFormat(undefined, {
          minimumFractionDigits: digits,
          maximumFractionDigits: digits
        });
        PRICE_FORMATTERS.set(digits, formatter);
      }
      return formatter.format(value);
    }

    function roundToPrecision(value, precision) {
      if (!Number.isFinite(value)) return null;
      const digits = Number.isInteger(precision) ? Math.min(Math.max(precision, 0), 8) : DEFAULT_PRICE_PRECISION;
      if (!digits) return Math.round(value);
      const factor = Math.pow(10, digits);
      return Math.round(value * factor) / factor;
    }

    function formatPercent(value) {
      if (!Number.isFinite(value)) return '0.00%';
      return `${PERCENT_FORMAT.format(value)}%`;
    }

    function formatDateTime(value) {
      if (!(value instanceof Date) || isNaN(value)) return '';
      const year = value.getFullYear();
      const month = pad2(value.getMonth() + 1);
      const day = pad2(value.getDate());
      const hour = pad2(value.getHours());
      const minute = pad2(value.getMinutes());
      return `${year}-${month}-${day} ${hour}:${minute}`;
    }

    // Numeric steppers for grid controls
    (function(){
      function decimals(stepStr){
        if (!stepStr) return 0;
        const s = String(stepStr);
        const idx = s.indexOf('.');
        return idx === -1 ? 0 : (s.length - idx - 1);
      }
      function roundTo(value, step){
        const d = decimals(step);
        return Number(value.toFixed(d));
      }
      function adjustNumberInput(id, deltaUnits){
        const el = document.getElementById(id);
        if (!el) return;
        const stepAttr = parseFloat(el.getAttribute('step') || '1');
        const step = Number.isFinite(stepAttr) && stepAttr > 0 ? stepAttr : 1;
        const minAttr = parseFloat(el.getAttribute('min'));
        const maxAttr = parseFloat(el.getAttribute('max'));
        const defAttr = parseFloat(el.getAttribute('data-default'));
        const curVal = parseFloat(el.value);
        const base = Number.isFinite(curVal) ? curVal : (Number.isFinite(defAttr) ? defAttr : 0);
        const next = base + (Number(deltaUnits) || 0) * step;
        const clamped = Math.min(Number.isFinite(maxAttr) ? maxAttr : Infinity, Math.max(Number.isFinite(minAttr) ? minAttr : -Infinity, next));
        const rounded = roundTo(clamped, step);
        el.value = String(rounded);
        el.dispatchEvent(new Event('change', { bubbles: true }));
        el.dispatchEvent(new Event('input', { bubbles: true }));
      }
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-num-target][data-num-step]');
        if (!btn) return;
        const id = btn.getAttribute('data-num-target');
        const delta = parseFloat(btn.getAttribute('data-num-step')) || 0;
        adjustNumberInput(id, delta);
      });
    })();

    const RETENTION_EXTRA_PCT = {
      none: 0,
      profit: 0,
      profit_plus_5: 0.05,
      profit_plus_10: 0.10
    };

    function computeSellExecution({ baseQty, desiredQty, sharesAvailable, mode, fractional }) {
      const normalizedMode = (mode || 'profit').toLowerCase();
      const safeDesired = Number.isFinite(desiredQty) && desiredQty > 0 ? desiredQty : baseQty;
      let desiredSell = Math.min(baseQty, safeDesired);
      if (!Number.isFinite(desiredSell) || desiredSell < 0) desiredSell = baseQty;
      const baseRetained = Math.max(0, baseQty - desiredSell);
      let targetRetained;
      switch (normalizedMode) {
        case 'none':
          targetRetained = 0;
          break;
        case 'profit':
          targetRetained = baseRetained;
          break;
        case 'profit_plus_5':
        case 'profit_plus_10':
          targetRetained = baseRetained + (RETENTION_EXTRA_PCT[normalizedMode] || 0) * baseQty;
          break;
        default:
          targetRetained = baseRetained;
          break;
      }
      const plannedRetained = Math.min(baseQty, Math.max(0, targetRetained));
      const targetSell = Math.max(0, baseQty - plannedRetained);
      const availableShares = Number.isFinite(sharesAvailable) ? sharesAvailable : baseQty;
      let qty = Math.max(0, Math.min(targetSell, baseQty, availableShares));
      if (!fractional) {
        qty = Math.floor(qty);
        if (qty <= 0 && baseQty > 0 && availableShares > 0) {
          qty = Math.min(baseQty, availableShares, 1);
        }
      }
      const unsold = Math.max(0, targetSell - qty);
      const retained = Math.max(0, baseQty - qty);
      return {
        qty,
        retained,
        plannedRetained,
        targetSell,
        unsold
      };
    }

    function buildPercentFixedGridLevels({ basePrice, gridSize, minPrice, maxPrice, tickSize }) {
      const rawPercent = Number(gridSize);
      const stepPercent = rawPercent / 100;
      if (!Number.isFinite(stepPercent) || stepPercent <= 0 || stepPercent >= 1) {
        return { ladder: [], pairs: [], baseIndex: -1 };
      }
      const resolvedTickSize = Number.isFinite(tickSize) && tickSize > 0 ? tickSize : 0.01;
      const rawBase = Number(basePrice);
      const base = snapToTick(rawBase, resolvedTickSize);
      if (!Number.isFinite(base) || base <= 0) {
        return { ladder: [], pairs: [], baseIndex: -1 };
      }
      const minBound = Number.isFinite(minPrice) && minPrice > 0 ? minPrice : base;
      const maxBound = Number.isFinite(maxPrice) && maxPrice > 0 ? maxPrice : base;
      const tolerance = 1e-9 * Math.max(1, minBound, maxBound, base);
      const divisor = 1 - stepPercent;
      if (divisor <= 0) return { ladder: [], pairs: [], baseIndex: -1 };
      const down = [];
      let priceAccumulator = base;
      let safety = 0;
      while (safety < 5000) {
        priceAccumulator = priceAccumulator * divisor;
        const price = snapToTick(priceAccumulator, resolvedTickSize);
        if (!Number.isFinite(price) || price <= 0) break;
        if (price < minBound - tolerance) break;
        if (!down.length || Math.abs(price - down[down.length - 1]) > tolerance) {
          down.push(price);
        }
        safety += 1;
      }
      const up = [];
      priceAccumulator = base;
      safety = 0;
      while (safety < 5000) {
        priceAccumulator = priceAccumulator / divisor;
        const price = snapToTick(priceAccumulator, resolvedTickSize);
        if (!Number.isFinite(price) || price <= 0) break;
        if (price > maxBound + tolerance) break;
        if (!up.length || Math.abs(price - up[up.length - 1]) > tolerance) {
          up.push(price);
        }
        safety += 1;
      }
      const ladder = [...down.reverse(), base, ...up];
      const baseIndex = down.length;
      const pairs = [];
      for (let i = 0; i < ladder.length - 1; i++) {
        pairs.push({
          level: i - baseIndex,
          buyPrice: ladder[i],
          sellPrice: ladder[i + 1]
        });
      }
      return { ladder, pairs, baseIndex };
    }

    function createGridSpacingHelpers({ spacingType, gridSize, basePrice, firstPrice, minPrice, maxPrice, tickSize }) {
      const typeRaw = (spacingType || 'fixed').toLowerCase();
      const isPercentType = typeRaw === 'percent' || typeRaw === 'percent_fixed';
      if (isPercentType) {
        const rawPercent = Number(gridSize);
        const percent = rawPercent / 100;
        if (!Number.isFinite(percent) || percent <= 0 || percent >= 1) {
          return { error: 'invalid_percent' };
        }
        const rawBase = Number(basePrice);
        const anchorBase = Number.isFinite(rawBase) && rawBase > 0 ? rawBase : null;
        let anchor = Math.max(anchorBase != null ? anchorBase : Number(firstPrice) || 0, 1e-9);
        if (typeRaw === 'percent_fixed') {
          const levels = buildPercentFixedGridLevels({
            basePrice: anchor,
            gridSize: rawPercent,
            minPrice,
            maxPrice,
            tickSize
          });
          if (Number.isInteger(levels.baseIndex) && levels.baseIndex >= 0 && Array.isArray(levels.ladder)) {
            const snappedBase = levels.ladder[levels.baseIndex];
            if (Number.isFinite(snappedBase)) {
              anchor = snappedBase;
            }
          }
          if (Array.isArray(levels.pairs)) {
            console.log('Percent fixed grid levels:', levels.pairs);
          }
          const ladder = Array.isArray(levels.ladder) ? levels.ladder : [];
          const priceTolerance = 1e-6;
          const findFloorIndex = (value) => {
            if (!Number.isFinite(value) || !ladder.length) return -1;
            let lo = 0;
            let hi = ladder.length - 1;
            if (value <= ladder[0]) return 0;
            if (value >= ladder[hi]) return hi;
            while (lo <= hi) {
              const mid = Math.floor((lo + hi) / 2);
              const level = ladder[mid];
              if (Math.abs(level - value) <= priceTolerance) return mid;
              if (level < value) {
                lo = mid + 1;
              } else {
                hi = mid - 1;
              }
            }
            return Math.max(0, Math.min(ladder.length - 1, hi));
          };
          const findCeilIndex = (value) => {
            if (!Number.isFinite(value) || !ladder.length) return -1;
            let lo = 0;
            let hi = ladder.length - 1;
            if (value <= ladder[0]) return 0;
            if (value >= ladder[hi]) return hi;
            while (lo <= hi) {
              const mid = Math.floor((lo + hi) / 2);
              const level = ladder[mid];
              if (Math.abs(level - value) <= priceTolerance) return mid;
              if (level < value) {
                lo = mid + 1;
              } else {
                hi = mid - 1;
              }
            }
            return Math.max(0, Math.min(ladder.length - 1, lo));
          };
          const findNearestIndex = (value) => {
            const floorIdx = findFloorIndex(value);
            const ceilIdx = findCeilIndex(value);
            if (floorIdx < 0) return ceilIdx;
            if (ceilIdx < 0) return floorIdx;
            const floorVal = ladder[floorIdx];
            const ceilVal = ladder[ceilIdx];
            if (!Number.isFinite(floorVal)) return ceilIdx;
            if (!Number.isFinite(ceilVal)) return floorIdx;
            return Math.abs(value - floorVal) <= Math.abs(ceilVal - value) ? floorIdx : ceilIdx;
          };
          const snap = (value) => {
            if (!Number.isFinite(value)) return NaN;
            const idx = findNearestIndex(value);
            return idx >= 0 ? ladder[idx] : NaN;
          };
          const move = (value, steps = 1) => {
            if (!Number.isFinite(value) || !ladder.length) return NaN;
            const idx = findNearestIndex(value);
            const target = idx + Math.round(steps);
            return ladder[target] ?? NaN;
          };
          const nextUp = (value) => move(value, 1);
          const nextDown = (value) => move(value, -1);
          const stepsBetween = (from, to) => {
            if (!Number.isFinite(from) || !Number.isFinite(to) || !ladder.length) return 0;
            const fromIdx = findNearestIndex(from);
            const toIdx = findNearestIndex(to);
            if (fromIdx < 0 || toIdx < 0) return 0;
            return toIdx - fromIdx;
          };
          const key = (value) => {
            if (!Number.isFinite(value)) return 'nan';
            const snapped = snap(value);
            return Number.isFinite(snapped) ? snapped.toFixed(6) : 'nan';
          };
          const floor = (value) => {
            const idx = findFloorIndex(value);
            return idx >= 0 ? ladder[idx] : NaN;
          };
          const ceil = (value) => {
            const idx = findCeilIndex(value);
            return idx >= 0 ? ladder[idx] : NaN;
          };
          const setAnchor = (value) => {
            if (!Number.isFinite(value) || value <= 0) return;
            anchor = value;
          };
          const getAnchor = () => anchor;
          return {
            type: 'percent',
            gridSize: rawPercent,
            percent,
            anchor,
            snap,
            move,
            nextUp,
            nextDown,
            stepsBetween,
            key,
            floor,
            ceil,
            priceTolerance,
            setAnchor,
            getAnchor,
            gridLevels: Array.isArray(levels.pairs) ? levels.pairs : [],
            gridLadder: ladder
          };
        }
        const ratio = 1 + percent;
        const logRatio = Math.log(ratio);
        const priceTolerance = 1e-6;
        const snap = (value) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          const idx = Math.round(Math.log(value / anchor) / logRatio);
          return anchor * Math.pow(ratio, idx);
        };
        const move = (value, steps = 1) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          return snap(value * Math.pow(ratio, steps));
        };
        const nextUp = (value) => move(value, 1);
        const nextDown = (value) => move(value, -1);
        const stepsBetween = (from, to) => {
          if (!Number.isFinite(from) || !Number.isFinite(to) || from <= 0 || to <= 0) return 0;
          return Math.log(to / from) / logRatio;
        };
        const key = (value) => {
          if (!Number.isFinite(value) || value <= 0) return 'nan';
          return snap(value).toFixed(6);
        };
        const floor = (value) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          const idx = Math.floor(Math.log(value / anchor) / logRatio);
          return anchor * Math.pow(ratio, idx);
        };
        const ceil = (value) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          const idx = Math.ceil(Math.log(value / anchor) / logRatio);
          return anchor * Math.pow(ratio, idx);
        };
        const setAnchor = (value) => {
          if (!Number.isFinite(value) || value <= 0) return;
          anchor = value;
        };
        const getAnchor = () => anchor;
        return {
          type: 'percent',
          gridSize: rawPercent,
          percent,
          anchor,
          ratio,
          logRatio,
          snap,
          move,
          nextUp,
          nextDown,
          stepsBetween,
          key,
          floor,
          ceil,
          priceTolerance,
          setAnchor,
          getAnchor
        };
      }
      const size = Number(gridSize);
      if (!Number.isFinite(size) || size <= 0) {
        return { error: 'invalid_fixed' };
      }
      const rawBase = Number(basePrice);
      const offset = Number.isFinite(rawBase) ? rawBase : (Number(firstPrice) || 0);
      const decimals = Math.min(Math.max(countDecimals(size), 0), 4);
      const scale = Math.pow(10, Math.min(decimals + 2, 8));
      const round = (value) => Math.round(value * scale) / scale;
      const snap = (value) => {
        if (!Number.isFinite(value)) return NaN;
        const snapped = offset + Math.round((value - offset) / size) * size;
        return round(snapped);
      };
      const move = (value, steps = 1) => snap(value + steps * size);
      const nextUp = (value) => move(value, 1);
      const nextDown = (value) => move(value, -1);
      const stepsBetween = (from, to) => {
        if (!Number.isFinite(from) || !Number.isFinite(to)) return 0;
        return (to - from) / size;
      };
      const key = (value) => snap(value).toFixed(6);
      const floor = (value) => {
        if (!Number.isFinite(value)) return NaN;
        return snap(offset + Math.floor((value - offset) / size) * size);
      };
      const ceil = (value) => {
        if (!Number.isFinite(value)) return NaN;
        return snap(offset + Math.ceil((value - offset) / size) * size);
      };
      return {
        type: 'fixed',
        gridSize: size,
        snap,
        move,
        nextUp,
        nextDown,
        stepsBetween,
        key,
        floor,
        ceil,
        priceTolerance: 1e-9,
        decimals,
        scale,
        round
      };
    }

    function passesEntryFilter(price, row, filter) {
      const normalized = (filter || 'none').toLowerCase();
      if (normalized === 'none') return true;
      if (!row) return false;
      const candidates = [
        Number(price),
        Number(row.open),
        Number(row.high),
        Number(row.close)
      ].filter(Number.isFinite);
      if (!candidates.length) return false;
      const priceNum = Math.min(...candidates);
      const windowLength = SMA_FILTER_LOOKUP[normalized];
      if (!windowLength) return true;
      const prop = SMA_PROPERTY_BY_WINDOW[windowLength];
      const comparison = prop ? row[prop] : null;
      if (!Number.isFinite(comparison) || Math.abs(comparison) < 1e-9) return true;
      const tolerance = 1e-9 * Math.max(1, Math.abs(comparison));
      return priceNum >= (comparison - tolerance);
    }

    function getEntryFilterWindow(filter) {
      const key = (filter || '').toLowerCase();
      return SMA_FILTER_LOOKUP[key] || null;
    }

    function describeSmaAvailability(filter) {
      const window = getEntryFilterWindow(filter);
      if (!window) return null;
      if (!(SMA_METADATA instanceof Map) || !SMA_METADATA.size) return null;
      const meta = SMA_METADATA.get(window);
      if (!meta) return null;
      const remaining = Math.max(0, window - (meta.totalDays || 0));
      return {
        window,
        totalDays: meta.totalDays || 0,
        availableDays: meta.availableDays || 0,
        required: window,
        remaining
      };
    }

    function getGridParamsFromUI() {
      const gridSize = Number(document.getElementById('inpGridSize')?.value ?? GRID_DEFAULTS.gridSize);
      const basePrice = Number(document.getElementById('inpBasePrice')?.value ?? 100);
      const tradeValue = Number(document.getElementById('inpTradeValue')?.value ?? GRID_DEFAULTS.tradeValue);
      const fractionalShares = !!document.getElementById('inpFractionalShares')?.checked;
      const gridType = GRID_TYPE;
      const gridSpacingType = (document.getElementById('selGridSpacing')?.value || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const retentionMode = (document.getElementById('selRetentionMode')?.value || 'profit').toLowerCase();
      const entryFilter = (document.getElementById('selEntryFilter')?.value || GRID_DEFAULTS.entryFilter).toLowerCase();
      const tickSize = getActiveTickSize();
      return {
        gridSize: Number.isFinite(gridSize) ? gridSize : GRID_DEFAULTS.gridSize,
        basePrice: Number.isFinite(basePrice) ? basePrice : 100,
        tradeValue: Number.isFinite(tradeValue) ? tradeValue : GRID_DEFAULTS.tradeValue,
        fractionalShares,
        gridType,
        gridSpacingType,
        retentionMode,
        entryFilter,
        tickSize
      };
    }

    function renderGridSummary(summary) {
      const totalTradesEl = document.getElementById('summaryTotalTrades');
      const maxLevelsEl = document.getElementById('summaryMaxLevels');
      const capitalContributedEl = document.getElementById('summaryCapitalContributed');
      const netCashflowEl = document.getElementById('summaryNetCashflow');
      const harvestedEl = document.getElementById('summaryHarvestedProfit');
      const holdingsValueEl = document.getElementById('summaryHoldingsValue');
      const netProfitEl = document.getElementById('summaryNetProfit');
      const profitPerLevelEl = document.getElementById('summaryProfitPerLevel');
      const accountEquityEl = document.getElementById('summaryAccountEquity');
      const requiredCapitalEl = document.getElementById('summaryRequiredCapital');
      const retainedEl = document.getElementById('summaryRetained');
      const cagrEl = document.getElementById('summaryCagr');
      const maxDdEl = document.getElementById('summaryMaxDD');
      const maxDdPctEl = document.getElementById('summaryMaxDDPct');
      const minCashEl = document.getElementById('summaryMinCash');
      const cashEl = document.getElementById('summaryCash');
      const sharesEl = document.getElementById('summaryShares');
      const lastPriceEl = document.getElementById('summaryLastPrice');
      const openLevelsEl = document.getElementById('summaryOpenLevels');
      const formatCurrencyOrDash = (value) => (Number.isFinite(value) ? formatCurrency(value) : '—');
      const formatNumberOrDash = (value, digits = 2) => (Number.isFinite(value) ? formatNumber(value, digits) : '—');
      const formatPercentOrDash = (value) => (Number.isFinite(value) ? formatPercent(value) : '—');
      const safeSummary = summary || {};
      const maxLevels = Number.isFinite(safeSummary?.maxOpenLevels) ? safeSummary.maxOpenLevels : 0;
      const hasLedger = Number.isFinite(safeSummary?.netPLFinal)
        || Number.isFinite(safeSummary?.netCashflowTradesFinal)
        || Number.isFinite(safeSummary?.netCashflowTrades)
        || Number.isFinite(safeSummary?.capitalContributed)
        || Number.isFinite(safeSummary?.capitalContributedFinal)
        || Number.isFinite(safeSummary?.requiredCapital);
      const requiredCapital = Number.isFinite(safeSummary?.requiredCapital)
        ? safeSummary.requiredCapital
        : NaN;
      let netPLFinal = Number.isFinite(safeSummary?.netPLFinal)
        ? safeSummary.netPLFinal
        : NaN;
      const netProfitFallback = Number.isFinite(safeSummary?.netProfit)
        ? safeSummary.netProfit
        : NaN;
      const holdingsValueFinal = Number.isFinite(safeSummary?.holdingsValueFinal)
        ? safeSummary.holdingsValueFinal
        : (Number.isFinite(safeSummary?.finalEquity) && Number.isFinite(safeSummary?.cash)
          ? safeSummary.finalEquity - safeSummary.cash
          : NaN);
      const accountEquityFinal = Number.isFinite(safeSummary?.finalEquity)
        ? safeSummary.finalEquity
        : (Number.isFinite(safeSummary?.accountEquityFinal) ? safeSummary.accountEquityFinal : NaN);
      const capitalContributedFinal = Number.isFinite(safeSummary?.capitalContributedFinal)
        ? safeSummary.capitalContributedFinal
        : (Number.isFinite(safeSummary?.capitalContributed) ? safeSummary.capitalContributed : NaN);
      const netCashflowTradesFinal = Number.isFinite(safeSummary?.netCashflowTradesFinal)
        ? safeSummary.netCashflowTradesFinal
        : (Number.isFinite(safeSummary?.netCashflowTrades) ? safeSummary.netCashflowTrades : NaN);
      const minCashBalance = Number.isFinite(safeSummary?.minCashBalance)
        ? safeSummary.minCashBalance
        : (Number.isFinite(safeSummary?.minCash) ? safeSummary.minCash : NaN);
      const lastPrice = Number.isFinite(safeSummary?.lastPrice)
        ? safeSummary.lastPrice
        : (Number.isFinite(holdingsValueFinal)
          && Number.isFinite(safeSummary?.shares)
          && Math.abs(safeSummary.shares) > 1e-9
          ? (holdingsValueFinal / safeSummary.shares)
          : NaN);
      const openLevelsFinal = Number.isFinite(safeSummary?.openLevelsFinal)
        ? safeSummary.openLevelsFinal
        : NaN;
      const maxDrawdown = Number.isFinite(safeSummary?.maxDrawdown) ? safeSummary.maxDrawdown : NaN;
      const maxDrawdownPct = Number.isFinite(safeSummary?.maxDrawdownPct)
        ? safeSummary.maxDrawdownPct
        : NaN;
      if (!Number.isFinite(netPLFinal)
        && Number.isFinite(netCashflowTradesFinal)
        && Number.isFinite(holdingsValueFinal)) {
        netPLFinal = netCashflowTradesFinal + holdingsValueFinal;
      }
      if (!Number.isFinite(netPLFinal) && Number.isFinite(netProfitFallback)) {
        netPLFinal = netProfitFallback;
      }
      const profitPerLevel = (Number.isFinite(netPLFinal) && maxLevels > 0)
        ? netPLFinal / maxLevels
        : NaN;
      const requiredCapitalValue = hasLedger ? requiredCapital : NaN;
      const netCashflowValue = hasLedger ? netCashflowTradesFinal : NaN;
      const capitalContributedValue = hasLedger ? capitalContributedFinal : NaN;
      const harvestedProfit = Number.isFinite(safeSummary?.realizedProfit)
        ? safeSummary.realizedProfit
        : NaN;
      const maxDrawdownValue = Number.isFinite(maxDrawdown) ? maxDrawdown : NaN;
      const maxDrawdownPctValue = Number.isFinite(maxDrawdownPct) ? maxDrawdownPct : NaN;
      if (!hasLedger && !Number.isFinite(netProfitFallback)) {
        netPLFinal = NaN;
      }
      if (totalTradesEl) totalTradesEl.textContent = String(safeSummary.totalTrades ?? 0);
      if (maxLevelsEl) maxLevelsEl.textContent = maxLevels.toLocaleString();
      if (capitalContributedEl) capitalContributedEl.textContent = formatCurrencyOrDash(capitalContributedValue);
      if (netCashflowEl) netCashflowEl.textContent = formatCurrencyOrDash(netCashflowValue);
      if (harvestedEl) {
        harvestedEl.textContent = formatCurrencyOrDash(harvestedProfit);
        harvestedEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (Number.isFinite(harvestedProfit) && harvestedProfit > 1e-8) {
          harvestedEl.classList.add('text-emerald-600');
        } else if (Number.isFinite(harvestedProfit) && harvestedProfit < -1e-8) {
          harvestedEl.classList.add('text-red-600');
        } else {
          harvestedEl.classList.add('text-slate-800');
        }
      }
      if (holdingsValueEl) holdingsValueEl.textContent = formatCurrencyOrDash(holdingsValueFinal);
      if (accountEquityEl) accountEquityEl.textContent = formatCurrencyOrDash(accountEquityFinal);
      if (requiredCapitalEl) requiredCapitalEl.textContent = formatCurrencyOrDash(requiredCapitalValue);
      if (netProfitEl) {
        netProfitEl.textContent = formatCurrencyOrDash(netPLFinal);
        netProfitEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (Number.isFinite(netPLFinal) && netPLFinal > 1e-8) {
          netProfitEl.classList.add('text-emerald-600');
        } else if (Number.isFinite(netPLFinal) && netPLFinal < -1e-8) {
          netProfitEl.classList.add('text-red-600');
        } else {
          netProfitEl.classList.add('text-slate-800');
        }
      }
      if (profitPerLevelEl) {
        profitPerLevelEl.textContent = formatCurrencyOrDash(profitPerLevel);
        profitPerLevelEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (Number.isFinite(profitPerLevel) && profitPerLevel > 1e-8) {
          profitPerLevelEl.classList.add('text-emerald-600');
        } else if (Number.isFinite(profitPerLevel) && profitPerLevel < -1e-8) {
          profitPerLevelEl.classList.add('text-red-600');
        } else {
          profitPerLevelEl.classList.add('text-slate-800');
        }
      }
      if (retainedEl) retainedEl.textContent = formatNumberOrDash(safeSummary.totalRetainedShares, 4);
      if (cagrEl) {
        const cagr = safeSummary.cagr;
        const pct = Number.isFinite(cagr) ? cagr * 100 : NaN;
        cagrEl.textContent = formatPercentOrDash(pct);
        cagrEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (Number.isFinite(cagr) && cagr > 1e-6) {
          cagrEl.classList.add('text-emerald-600');
        } else if (Number.isFinite(cagr) && cagr < -1e-6) {
          cagrEl.classList.add('text-red-600');
        } else {
          cagrEl.classList.add('text-slate-800');
        }
      }
      if (maxDdEl) {
        maxDdEl.textContent = formatCurrencyOrDash(maxDrawdownValue);
        maxDdEl.classList.remove('text-slate-800', 'text-red-600');
        if (Number.isFinite(maxDrawdownValue) && maxDrawdownValue < -1e-8) {
          maxDdEl.classList.add('text-red-600');
        } else {
          maxDdEl.classList.add('text-slate-800');
        }
      }
      if (maxDdPctEl) {
        maxDdPctEl.textContent = formatPercentOrDash(maxDrawdownPctValue);
        maxDdPctEl.classList.remove('text-slate-800', 'text-red-600');
        if (Number.isFinite(maxDrawdownPctValue) && maxDrawdownPctValue < -1e-8) {
          maxDdPctEl.classList.add('text-red-600');
        } else {
          maxDdPctEl.classList.add('text-slate-800');
        }
      }
      if (minCashEl) minCashEl.textContent = formatCurrencyOrDash(minCashBalance);
      if (cashEl) cashEl.textContent = formatCurrencyOrDash(safeSummary.cash);
      if (sharesEl) sharesEl.textContent = formatNumberOrDash(safeSummary.shares, 4);
      if (lastPriceEl) lastPriceEl.textContent = formatCurrencyOrDash(lastPrice);
      if (openLevelsEl) openLevelsEl.textContent = formatNumberOrDash(openLevelsFinal, 0);
    }

    function getTradeSortValue(trade, key) {
      if (!trade) return 0;
      switch (key) {
        case 'buyTime':
          return trade.buyTime instanceof Date ? trade.buyTime.getTime() : new Date(trade.buyTime).getTime() || 0;
        case 'sellTime':
          return trade.sellTime instanceof Date ? trade.sellTime.getTime() : new Date(trade.sellTime).getTime() || 0;
        case 'buyPrice':
        case 'sellPrice':
        case 'buyQty':
        case 'openQty':
        case 'openEquity':
        case 'sellQty':
        case 'closeQty':
        case 'closeEquity':
        case 'qtyRetained':
        case 'cumQtyRetained':
        case 'daysHeld':
        case 'profit':
        case 'cumProfit':
        case 'runningPnl':
          if (Number.isFinite(trade.closeNetPL)) return trade.closeNetPL;
          return Number(trade.runningPnl) || 0;
        case 'drawdown':
          if (Number.isFinite(trade.drawdownNetPL)) return trade.drawdownNetPL;
          return Number(trade.drawdown) || 0;
        case 'roiPct':
        case 'gridLevel':
        case 'openLevels':
          return Number(trade[key]) || 0;
        default:
          return 0;
      }
    }

    function sortTradesForDisplay(trades) {
      if (!Array.isArray(trades) || trades.length <= 1) return Array.isArray(trades) ? trades.slice() : [];
      const { key, dir } = TRADE_SORT_STATE;
      const direction = dir === 'desc' ? -1 : 1;
      return trades.slice().sort((a, b) => {
        const va = getTradeSortValue(a, key);
        const vb = getTradeSortValue(b, key);
        if (va === vb) return 0;
        return va > vb ? direction : -direction;
      });
    }

    function updateTradeSortIndicators() {
      const headers = document.querySelectorAll('th[data-sort-key]');
      headers.forEach((th) => {
        const key = th.getAttribute('data-sort-key');
        if (!key) return;
        if (key === TRADE_SORT_STATE.key) {
          th.setAttribute('data-sort', TRADE_SORT_STATE.dir);
        } else {
          th.setAttribute('data-sort', 'none');
        }
      });
    }

    function formatMonthKeyFromDate(value) {
      const date = value instanceof Date ? value : new Date(value);
      if (!(date instanceof Date) || isNaN(date)) return null;
      const mm = pad2(date.getMonth() + 1);
      const yy = date.getFullYear();
      return `${mm}/${yy}`;
    }

    function monthChoicesFromDays() {
      if (!Array.isArray(DAYS) || !DAYS.length) return [];
      const set = new Set();
      for (const dayKey of DAYS) {
        if (typeof dayKey !== 'string' || dayKey.length < 7) continue;
        set.add(`${dayKey.slice(5, 7)}/${dayKey.slice(0, 4)}`);
      }
      return Array.from(set).sort((a, b) => {
        const [am, ay] = a.split('/').map(Number);
        const [bm, by] = b.split('/').map(Number);
        if (ay !== by) return by - ay;
        return bm - am;
      });
    }

    function isMonthFilterStrict() {
      return VIEW_MONTHS.size > 0 && VIEW_MONTHS.size < AVAILABLE_MONTHS.length;
    }

    function formatDayKeyToMonth(dayKey) {
      if (typeof dayKey !== 'string' || dayKey.length < 7) return null;
      return `${dayKey.slice(5, 7)}/${dayKey.slice(0, 4)}`;
    }

    function applyMonthFilter(trades) {
      if (!Array.isArray(trades) || !trades.length) return [];
      if (!VIEW_MONTHS.size) return trades.slice();
      return trades.filter((trade) => {
        const key = formatMonthKeyFromDate(trade?.buyTime);
        return key && VIEW_MONTHS.has(key);
      });
    }

    function filterRowsBySelectedMonths(rows) {
      if (!Array.isArray(rows) || !rows.length) return [];
      if (!VIEW_MONTHS.size) return rows.slice();
      return rows.filter((row) => {
        if (!row || !row.dayKey) return false;
        const key = formatDayKeyToMonth(row.dayKey);
        return key && VIEW_MONTHS.has(key);
      });
    }

    function rerunBacktestIfDataLoaded() {
      if (Array.isArray(ROWS) && ROWS.length) {
        runGridBacktest();
      }
    }

    function clampTradePage(totalRows) {
      const size = Math.max(25, Math.min(1000, Math.round(TRADE_TABLE_STATE.pageSize) || 250));
      TRADE_TABLE_STATE.pageSize = size;
      const total = Math.max(0, Number(totalRows) || 0);
      const totalPages = total > 0 ? Math.ceil(total / size) : 1;
      if (TRADE_TABLE_STATE.page > totalPages) TRADE_TABLE_STATE.page = totalPages;
      if (TRADE_TABLE_STATE.page < 1) TRADE_TABLE_STATE.page = 1;
      return { pageSize: size, totalPages };
    }

    function normalizeSymbolInput(val) {
      return (val || '').trim().toUpperCase();
    }

    function collectGridBacktestPayload() {
      if (!GRID_STATE?.summary) return null;
      const params = getGridParamsFromUI();
      const summary = GRID_STATE.summary || {};
      const days = Array.isArray(DAYS) ? DAYS : [];
      const dateStart = days.length ? days[0] : null;
      const dateEnd = days.length ? days[days.length - 1] : null;
      return {
        symbol: currentTicker || null,
        bar_interval_minutes: RESAMPLE_INTERVAL_MINUTES,
        bar_count: Array.isArray(ROWS) ? ROWS.length : 0,
        day_count: days.length,
        date_start: dateStart,
        date_end: dateEnd,
        base_price: Number.isFinite(params?.basePrice) ? params.basePrice : null,
        grid_type: params?.gridType || null,
        grid_size: Number.isFinite(params?.gridSize) ? params.gridSize : null,
        trade_value: Number.isFinite(params?.tradeValue) ? params.tradeValue : null,
        retention_mode: params?.retentionMode || null,
        max_levels: Number.isFinite(summary?.maxOpenLevels) ? summary.maxOpenLevels : null,
        completed_trades: Number.isFinite(summary?.totalTrades) ? summary.totalTrades : null,
        net_profit: Number.isFinite(summary?.netProfit) ? summary.netProfit : null,
        profit_per_level: Number.isFinite(summary?.profitPerLevel) ? summary.profitPerLevel : null,
        final_equity: Number.isFinite(summary?.finalEquity) ? summary.finalEquity : null,
        cagr: Number.isFinite(summary?.cagr) ? summary.cagr : null,
        retained_shares: Number.isFinite(summary?.totalRetainedShares) ? summary.totalRetainedShares : null,
        max_drawdown: Number.isFinite(summary?.maxDrawdown) ? summary.maxDrawdown : null,
        max_drawdown_pct: Number.isFinite(summary?.maxDrawdownPct) ? summary.maxDrawdownPct : null,
        max_deployed_capital: Number.isFinite(summary?.maxDeployedCapital) ? summary.maxDeployedCapital : null
      };
    }

    async function requestSaveGridBacktest(payload) {
      const res = await fetch('/api/save-grid-backtest', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      const data = contentType.includes('application/json') ? await res.json() : null;
      if (!res.ok) {
        const errMsg = data && data.error ? data.error : `HTTP ${res.status}`;
        throw new Error(errMsg);
      }
      return data;
    }

    let adhocStatusPoll = null;

    function stopAdhocStatusPolling() {
      if (adhocStatusPoll) {
        clearInterval(adhocStatusPoll);
        adhocStatusPoll = null;
      }
    }

    async function fetchAdhocStatus(symbol) {
      const res = await fetch(`/api/polygon-download/status?symbol=${encodeURIComponent(symbol)}`);
      if (!res.ok) return;
      const payload = await res.json();
      const message = payload && payload.message ? payload.message : '';
      if (message) {
        setStatus(message);
        setGridStatus(message);
      }
      if (payload && payload.state && payload.state !== 'running') {
        stopAdhocStatusPolling();
      }
    }

    function startAdhocStatusPolling(symbol) {
      stopAdhocStatusPolling();
      if (!symbol) return;
      adhocStatusPoll = setInterval(() => {
        fetchAdhocStatus(symbol).catch(() => {});
      }, 1000);
      fetchAdhocStatus(symbol).catch(() => {});
    }

    function setAdhocDownloadBusy(isBusy) {
      const btn = document.getElementById('btnAdhocGetData');
      const watchBtn = document.getElementById('watchlistAddAdhocBtn');
      const input = document.getElementById('inpAdhocSymbol');
      if (btn) btn.disabled = !!isBusy;
      if (input) input.disabled = !!isBusy;
      if (watchBtn) watchBtn.disabled = !!isBusy || !LAST_ADHOC_SYMBOL;
    }

    async function requestAdhocDownload(symbol) {
      const res = await fetch('/api/polygon-download', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ symbol })
      });
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      const payload = contentType.includes('application/json') ? await res.json() : null;
      if (!res.ok) {
        const errMsg = payload && payload.error ? payload.error : `HTTP ${res.status}`;
        throw new Error(errMsg);
      }
      return payload;
    }

    function setAdhocWatchlistSymbol(symbol) {
      LAST_ADHOC_SYMBOL = (symbol || '').toUpperCase().trim();
      const watchBtn = document.getElementById('watchlistAddAdhocBtn');
      if (watchBtn) watchBtn.disabled = !LAST_ADHOC_SYMBOL;
    }

    function updateTradePaginationControls(totalRows, range) {
      const info = document.getElementById('tradePaginationInfo');
      const prev = document.getElementById('tradePagePrev');
      const next = document.getElementById('tradePageNext');
      const select = document.getElementById('tradePageSize');
      const { pageSize, totalPages } = clampTradePage(totalRows);
      const page = TRADE_TABLE_STATE.page;
      const start = Math.max(0, range?.start ?? 0);
      const end = Math.max(start, Math.min(totalRows, range?.end ?? (start + pageSize)));
      if (info) {
        if (!totalRows) {
          info.textContent = 'No trades to display.';
        } else {
          info.textContent = `${start + 1}–${end} of ${totalRows.toLocaleString()} trade${totalRows === 1 ? '' : 's'}`;
        }
      }
      if (prev) prev.disabled = page <= 1 || totalRows <= 0;
      if (next) next.disabled = page >= totalPages || totalRows <= pageSize;
      if (select && select.value !== String(pageSize)) {
        select.value = String(pageSize);
      }
    }

    function renderGridTrades(trades, options = {}) {
      if (options?.resetPage) {
        TRADE_TABLE_STATE.page = 1;
      }
      const tbody = document.getElementById('gridTradeRows');
      const emptyState = document.getElementById('gridTradesEmpty');
      const label = document.getElementById('tradeCountLabel');
      if (!tbody) return;
      const source = Array.isArray(trades) ? trades : [];
      const filtered = applyMonthFilter(source);
      const filterActive = isMonthFilterStrict();
      tbody.innerHTML = '';
      if (!filtered.length) {
        if (emptyState) {
          emptyState.textContent = filterActive
            ? 'No trades match the selected month filter.'
            : 'Run the backtest to see individual trades.';
          emptyState.classList.remove('hidden');
        }
        if (label) label.textContent = '0 trades';
        updateTradePaginationControls(0);
        updateTradeSortIndicators();
        return;
      }
      if (emptyState) {
        emptyState.textContent = 'Run the backtest to see individual trades.';
        emptyState.classList.add('hidden');
      }
      const displayTrades = sortTradesForDisplay(filtered);
      const { pageSize } = clampTradePage(displayTrades.length);
      const page = TRADE_TABLE_STATE.page;
      const start = (page - 1) * pageSize;
      const end = Math.min(displayTrades.length, start + pageSize);
      const visibleTrades = displayTrades.slice(start, end);
      const frag = document.createDocumentFragment();
      for (const trade of visibleTrades) {
        const tr = document.createElement('tr');
        tr.className = 'table-row';
        const openLevelsLabel = Number.isFinite(trade.openLevels) ? trade.openLevels.toLocaleString() : '—';
        const pnlValue = Number.isFinite(trade.closeNetPL)
          ? trade.closeNetPL
          : (Number.isFinite(trade.runningPnl) ? trade.runningPnl : 0);
        const drawdownValue = Number.isFinite(trade.drawdownNetPL)
          ? trade.drawdownNetPL
          : (Number.isFinite(trade.drawdown) ? trade.drawdown : 0);
        tr.innerHTML = `
          <td class="px-3 py-2 whitespace-nowrap">${formatDateTime(trade.buyTime)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.buyPrice, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.buyQty, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.openQty ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatCurrency(trade.openEquity ?? 0)}</td>
          <td class="px-3 py-2 text-right">${openLevelsLabel}</td>
          <td class="px-3 py-2 whitespace-nowrap">${formatDateTime(trade.sellTime)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.sellPrice, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.sellQty, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.closeQty ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatCurrency(trade.closeEquity ?? 0)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.qtyRetained ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.cumQtyRetained ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.daysHeld ?? 0, 2)}</td>
          <td class="px-3 py-2 text-right ${trade.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(trade.profit)}</td>
          <td class="px-3 py-2 text-right ${trade.cumProfit >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(trade.cumProfit)}</td>
          <td class="px-3 py-2 text-right ${pnlValue >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(pnlValue)}</td>
          <td class="px-3 py-2 text-right ${drawdownValue >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(drawdownValue)}</td>
          <td class="px-3 py-2 text-right ${trade.roiPct >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatPercent(trade.roiPct)}</td>
        `;
        frag.appendChild(tr);
      }
      tbody.appendChild(frag);
      if (label) label.textContent = `${filtered.length} trade${filtered.length === 1 ? '' : 's'}`;
      updateTradePaginationControls(displayTrades.length, { start, end });
      updateTradeSortIndicators();
    }

    function updateMonthFilterLabel() {
      const lbl = document.getElementById('sumMonthMultiLabel');
      if (!lbl) return;
      if (!VIEW_MONTHS.size || VIEW_MONTHS.size === AVAILABLE_MONTHS.length) {
        lbl.textContent = 'All months';
        return;
      }
      if (VIEW_MONTHS.size <= 2) {
        lbl.textContent = Array.from(VIEW_MONTHS).sort().join(', ');
        return;
      }
      lbl.textContent = `${VIEW_MONTHS.size} selected`;
    }

    function buildMonthFilterOptions() {
      AVAILABLE_MONTHS = monthChoicesFromDays();
      const list = document.getElementById('sumMonthMultiList');
      if (!list) return;
      if (!AVAILABLE_MONTHS.length) {
        list.innerHTML = '<div class="px-2 py-1 text-xs text-slate-500">No data loaded.</div>';
      } else {
        list.innerHTML = AVAILABLE_MONTHS.map(key => `
          <label class="flex items-center gap-2 px-2 py-1 rounded hover:bg-slate-50 cursor-pointer">
            <input type="checkbox" class="h-4 w-4 rounded border-slate-300" data-month="${key}" ${VIEW_MONTHS.has(key) ? 'checked' : ''} />
            <span class="text-sm text-slate-800">${key}</span>
          </label>
        `).join('');
      }
      if (VIEW_MONTHS.size && VIEW_MONTHS.size >= AVAILABLE_MONTHS.length) {
        VIEW_MONTHS = new Set(AVAILABLE_MONTHS);
      } else {
        const valid = new Set();
        VIEW_MONTHS.forEach(key => { if (AVAILABLE_MONTHS.includes(key)) valid.add(key); });
        VIEW_MONTHS = valid;
      }
      document.querySelectorAll('#sumMonthMultiList input[data-month]').forEach(cb => {
        const key = cb.getAttribute('data-month');
        cb.checked = VIEW_MONTHS.has(key);
      });
      updateMonthFilterLabel();
    }

    document.addEventListener('click', (e) => {
      const menu = document.getElementById('sumMonthMultiMenu');
      if (!menu) return;
      const btn = e.target.closest('#sumMonthMultiBtn');
      if (btn) {
        menu.classList.toggle('hidden');
        return;
      }
      if (!menu.contains(e.target)) {
        menu.classList.add('hidden');
      }
    });

    document.addEventListener('click', (e) => {
      const selAll = e.target.closest('#sumMonthSelectAll');
      const clrAll = e.target.closest('#sumMonthClearAll');
      if (!selAll && !clrAll) return;
      if (selAll) VIEW_MONTHS = new Set(AVAILABLE_MONTHS);
      if (clrAll) VIEW_MONTHS = new Set();
      document.querySelectorAll('#sumMonthMultiList input[data-month]').forEach(cb => {
        const key = cb.getAttribute('data-month');
        cb.checked = VIEW_MONTHS.has(key);
      });
      updateMonthFilterLabel();
      renderGridTrades(GRID_STATE.trades || [], { resetPage: true });
      rerunBacktestIfDataLoaded();
    });

    document.addEventListener('change', (e) => {
      const cb = e.target.closest('#sumMonthMultiList input[data-month]');
      if (!cb) return;
      const key = cb.getAttribute('data-month');
      if (!key) return;
      if (cb.checked) VIEW_MONTHS.add(key); else VIEW_MONTHS.delete(key);
      updateMonthFilterLabel();
      renderGridTrades(GRID_STATE.trades || [], { resetPage: true });
      rerunBacktestIfDataLoaded();
    });

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#priceFillToggle button[data-view]');
      if (!btn) return;
      const view = btn.getAttribute('data-view');
      if (!view) return;
      setPriceDistributionView(view);
    });

    (function(){
      const toggle = document.getElementById('gridLevelsToggle');
      const body = document.getElementById('gridLevelsBody');
      const label = document.getElementById('gridLevelsToggleLabel');
      const chevron = document.getElementById('gridLevelsChevron');
      if (!toggle || !body) return;
      const setExpanded = (expanded) => {
        toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        body.classList.toggle('hidden', !expanded);
        if (label) label.textContent = expanded ? 'Hide Levels' : 'Show Levels';
        if (chevron) chevron.classList.toggle('rotate-180', expanded);
      };
      setExpanded(false);
      toggle.addEventListener('click', (e) => {
        e.preventDefault();
        const expanded = toggle.getAttribute('aria-expanded') === 'true';
        setExpanded(!expanded);
      });
    })();

    function renderGridLevels(buyLevels, sellLevels, baseLevel) {
      const buyEl = document.getElementById('gridBuyLevels');
      const sellEl = document.getElementById('gridSellLevels');
      const buyCountEl = document.getElementById('gridBuyLevelCount');
      const sellCountEl = document.getElementById('gridSellLevelCount');
      const summaryEl = document.getElementById('gridLevelsSummary');
      const defaultMsg = 'Run the backtest to list the ladder levels currently seeded for buys and sells.';
      const formatList = (values, order = 'desc') => {
        if (!Array.isArray(values) || !values.length) {
          return '<div class="text-xs text-slate-500">No levels generated yet.</div>';
        }
        const sorted = values.slice().sort(order === 'asc' ? ((a, b) => a - b) : ((a, b) => b - a));
        const items = sorted.map((price, idx) => `
          <li class="flex items-center justify-between gap-4">
            <span class="text-xs text-slate-500">#${idx + 1}</span>
            <span class="font-mono text-sm text-slate-800">$${formatNumber(price, 4)}</span>
          </li>
        `).join('');
        return `<ol class="space-y-1">${items}</ol>`;
      };
      const buyCount = Array.isArray(buyLevels) ? buyLevels.length : 0;
      const sellCount = Array.isArray(sellLevels) ? sellLevels.length : 0;
      if (buyEl) buyEl.innerHTML = formatList(buyLevels || [], 'desc');
      if (sellEl) sellEl.innerHTML = formatList(sellLevels || [], 'asc');
      if (buyCountEl) buyCountEl.textContent = `${buyCount.toLocaleString()} level${buyCount === 1 ? '' : 's'}`;
      if (sellCountEl) sellCountEl.textContent = `${sellCount.toLocaleString()} level${sellCount === 1 ? '' : 's'}`;
      if (summaryEl) {
        if (buyCount || sellCount) {
          const baseText = Number.isFinite(baseLevel) ? ` Base price: $${formatNumber(baseLevel, 4)}.` : '';
          summaryEl.textContent = `Tracking ${buyCount.toLocaleString()} buy level${buyCount === 1 ? '' : 's'} and ${sellCount.toLocaleString()} sell level${sellCount === 1 ? '' : 's'} from the latest run.${baseText}`;
        } else {
          summaryEl.textContent = defaultMsg;
        }
      }
    }

    function renderGridEquityChart(series) {
      const container = document.getElementById('gridEquityChart');
      const emptyState = document.getElementById('gridEquityEmpty');
      const label = document.getElementById('equitySummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!gridEquityChartInst) {
        gridEquityChartInst = echarts.init(container);
      }
      if (!Array.isArray(series) || !series.length) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        gridEquityChartInst.clear();
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const equityData = series.map(point => {
        const time = point.time instanceof Date ? point.time : new Date(point.time);
        return [time.getTime(), Number(point.equity) || 0];
      }).filter(item => Number.isFinite(item[0]) && Number.isFinite(item[1]));
      equityData.sort((a, b) => a[0] - b[0]);
      const cashData = series.map(point => {
        const time = point.time instanceof Date ? point.time : new Date(point.time);
        return [time.getTime(), Number(point.cash)];
      }).filter(item => Number.isFinite(item[0]) && Number.isFinite(item[1]));
      cashData.sort((a, b) => a[0] - b[0]);
      if (!equityData.length) {
        gridEquityChartInst.clear();
        if (label) label.textContent = '';
        if (emptyState) emptyState.classList.remove('hidden');
        return;
      }
      const first = equityData[0];
      const last = equityData[equityData.length - 1];
      if (label && first && last) {
        const start = new Date(first[0]);
        const end = new Date(last[0]);
        label.textContent = `${start.toISOString().slice(0, 10)} → ${end.toISOString().slice(0, 10)} (${equityData.length.toLocaleString()} points)`;
      }
      const gradient = (echarts.graphic && echarts.graphic.LinearGradient)
        ? new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: 'rgba(15, 118, 110, 0.25)' },
            { offset: 1, color: 'rgba(15, 118, 110, 0)' }
          ])
        : 'rgba(15, 118, 110, 0.1)';
      gridEquityChartInst.setOption({
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        legend: {
          data: ['Equity', 'Cash Balance'],
          textStyle: { color: '#475569' },
          selected: {
            Equity: true,
            'Cash Balance': true
          }
        },
        dataZoom: [
          {
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'filter'
          },
          {
            type: 'inside',
            yAxisIndex: 0,
            filterMode: 'weakFilter'
          }
        ],
        visualMap: undefined,
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'cross' },
          valueFormatter: (val) => formatCurrency(val)
        },
        xAxis: {
          type: 'time',
          boundaryGap: false,
          axisLabel: { color: '#64748b' }
        },
        yAxis: {
          type: 'value',
          scale: true,
          axisLabel: {
            formatter: (val) => formatCurrency(val).replace('$', ''),
            color: '#64748b'
          },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Equity',
            type: 'line',
            smooth: true,
            showSymbol: false,
            lineStyle: { color: '#0f766e', width: 2 },
            areaStyle: gradient ? { color: gradient } : undefined,
            data: equityData
          },
          {
            name: 'Cash Balance',
            type: 'line',
            smooth: true,
            showSymbol: false,
            lineStyle: { color: '#64748b', width: 1.5, type: 'dashed' },
            data: cashData
          }
        ]
      }, true);
    }

    function renderLadderChart(trades) {
      const container = document.getElementById('gridLadderChart');
      const emptyState = document.getElementById('gridLadderEmpty');
      const label = document.getElementById('ladderSummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!gridLadderChartInst) {
        gridLadderChartInst = echarts.init(container);
      }
      if (!Array.isArray(trades) || !trades.length) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        gridLadderChartInst.clear();
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const buyPoints = [];
      const sellPoints = [];
      trades.forEach((trade) => {
        if (trade?.buyTime) {
          const time = trade.buyTime instanceof Date ? trade.buyTime : new Date(trade.buyTime);
          if (time instanceof Date && !isNaN(time)) {
            buyPoints.push([
              time.getTime(),
              Number(trade.buyPrice) || 0,
              Number(trade.buyQty) || 0
            ]);
          }
        }
        if (trade?.sellTime) {
          const time = trade.sellTime instanceof Date ? trade.sellTime : new Date(trade.sellTime);
          if (time instanceof Date && !isNaN(time)) {
            sellPoints.push([
              time.getTime(),
              Number(trade.sellPrice) || 0,
              Number(trade.sellQty) || 0
            ]);
          }
        }
      });
      buyPoints.sort((a, b) => a[0] - b[0]);
      sellPoints.sort((a, b) => a[0] - b[0]);
      if (!buyPoints.length && !sellPoints.length) {
        gridLadderChartInst.clear();
        if (label) label.textContent = '';
        if (emptyState) emptyState.classList.remove('hidden');
        return;
      }
      if (label) {
        const totalPoints = buyPoints.length + sellPoints.length;
        label.textContent = `${totalPoints.toLocaleString()} fills (${buyPoints.length.toLocaleString()} buys · ${sellPoints.length.toLocaleString()} sells)`;
      }
      const formatter = (params) => {
        if (!params || !params.value) return '';
        const [ts, price, qty] = params.value;
        const date = new Date(ts);
        const timeStr = Number.isFinite(ts) ? formatDateTime(date) : '';
        return `
          <div class="text-xs">
            <div class="font-semibold">${params.seriesName}</div>
            <div>${timeStr}</div>
            <div>Price: ${formatNumber(price, 4)}</div>
            <div>Qty: ${formatNumber(qty, 4)}</div>
          </div>
        `;
      };
      gridLadderChartInst.setOption({
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        legend: {
          data: ['Buy fills', 'Sell fills'],
          textStyle: { color: '#475569' }
        },
        tooltip: {
          trigger: 'item',
          formatter
        },
        dataZoom: [
          {
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'filter'
          },
          {
            type: 'inside',
            yAxisIndex: 0,
            filterMode: 'weakFilter'
          }
        ],
        xAxis: {
          type: 'time',
          axisLabel: { color: '#64748b' }
        },
        yAxis: {
          type: 'value',
          scale: true,
          axisLabel: {
            formatter: (val) => formatNumber(val, 4),
            color: '#64748b'
          },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Buy fills',
            type: 'scatter',
            symbolSize: 4,
            itemStyle: { color: '#0f766e' },
            data: buyPoints
          },
          {
            name: 'Sell fills',
            type: 'scatter',
            symbolSize: 4,
            itemStyle: { color: '#dc2626' },
            data: sellPoints
          }
        ]
      }, true);
    }

    function computeDailyFillEntries(trades) {
      const source = Array.isArray(trades) ? trades : [];
      const counts = new Map();
      const addCount = (key, type) => {
        if (!key) return;
        if (!counts.has(key)) counts.set(key, { key, buy: 0, sell: 0 });
        const entry = counts.get(key);
        if (type === 'buy') entry.buy += 1;
        if (type === 'sell') entry.sell += 1;
      };
      for (const trade of source) {
        addCount(dateKeyFromStr(trade?.buyTime), 'buy');
        addCount(dateKeyFromStr(trade?.sellTime), 'sell');
      }
      const entries = Array.from(counts.values()).sort((a, b) => (a.key || '').localeCompare(b.key || ''));
      const totals = entries.reduce((acc, entry) => {
        acc.buys += Number(entry.buy) || 0;
        acc.sells += Number(entry.sell) || 0;
        return acc;
      }, { buys: 0, sells: 0 });
      return { entries, totals };
    }

    function computeQuantile(values, quantile) {
      if (!Array.isArray(values) || !values.length) return NaN;
      const sorted = values.slice().sort((a, b) => a - b);
      const clamped = Math.min(Math.max(quantile, 0), 1);
      const pos = (sorted.length - 1) * clamped;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base + 1] === undefined) return sorted[base];
      return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
    }

    function computeTrimmedMean(values, trimPct) {
      if (!Array.isArray(values) || !values.length) return NaN;
      const sorted = values.slice().sort((a, b) => a - b);
      const trimCount = Math.floor(sorted.length * trimPct);
      const trimmed = sorted.slice(trimCount, sorted.length - trimCount);
      const sample = trimmed.length ? trimmed : sorted;
      const sum = sample.reduce((acc, val) => acc + val, 0);
      return sample.length ? sum / sample.length : NaN;
    }

    function computeSellFillStats(entries) {
      const values = Array.isArray(entries)
        ? entries.map(entry => Number(entry?.sell) || 0)
        : [];
      if (!values.length) {
        return { median: 0, trimmedMean: 0, pct95: 0 };
      }
      return {
        median: computeQuantile(values, 0.5),
        trimmedMean: computeTrimmedMean(values, 0.05),
        pct95: computeQuantile(values, 0.95)
      };
    }

    function updateSellFillSummaryTiles(stats) {
      const calmEl = document.getElementById('summaryCalmDaySells');
      const normalEl = document.getElementById('summaryNormalMarketSells');
      const volEl = document.getElementById('summaryVolatilityDaySells');
      if (!calmEl && !normalEl && !volEl) return;
      const formatter = new Intl.NumberFormat(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
      const formatCount = (value) => (Number.isFinite(value) ? formatter.format(value) : '0');
      const median = Number.isFinite(stats?.median) ? stats.median : 0;
      const trimmedMean = Number.isFinite(stats?.trimmedMean) ? stats.trimmedMean : 0;
      const pct95 = Number.isFinite(stats?.pct95) ? stats.pct95 : 0;
      if (calmEl) calmEl.textContent = formatCount(median);
      if (normalEl) normalEl.textContent = formatCount(trimmedMean);
      if (volEl) volEl.textContent = formatCount(pct95);
    }

    function computeDailyOpenLevels(history) {
      const source = Array.isArray(history) ? history : [];
      const perDay = new Map();
      for (const entry of source) {
        if (!entry) continue;
        const dateKey = dateKeyFromStr(entry.time);
        if (!dateKey) continue;
        const ts = entry.time instanceof Date ? entry.time.getTime() : NaN;
        const levelsRaw = Number.isFinite(entry?.sells) ? Number(entry.sells) : Number(entry?.buys);
        const levels = Number.isFinite(levelsRaw) ? Math.max(0, levelsRaw) : 0;
        const existing = perDay.get(dateKey);
        if (!existing || (Number.isFinite(ts) && ts > existing.ts)) {
          perDay.set(dateKey, { key: dateKey, levels, ts });
        }
      }
      const entries = Array.from(perDay.values()).sort((a, b) => (a.key || '').localeCompare(b.key || ''));
      const stats = entries.reduce((acc, entry) => {
        if (entry && Number.isFinite(entry.levels)) {
          acc.max = Math.max(acc.max, entry.levels);
          acc.last = entry.levels;
        }
        return acc;
      }, { max: 0, last: 0 });
      return { entries, stats };
    }

    function renderFillsPerDayChart(trades) {
      const container = document.getElementById('dailyFillsChart');
      const emptyState = document.getElementById('dailyFillsEmpty');
      const label = document.getElementById('fillsDaySummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!fillsPerDayChartInst) {
        fillsPerDayChartInst = echarts.init(container);
      }
      const { entries, totals } = computeDailyFillEntries(trades);
      updateSellFillSummaryTiles(computeSellFillStats(entries));
      if (!entries.length) {
        fillsPerDayChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      const categories = entries.map(entry => entry.key);
      const buyCounts = entries.map(entry => {
        const val = Number(entry.buy) || 0;
        return val ? -val : 0;
      });
      const sellCounts = entries.map(entry => Number(entry.sell) || 0);
      const totalBuys = totals?.buys || 0;
      const totalSells = totals?.sells || 0;
      const totalFills = totalBuys + totalSells;
      if (label) {
        label.textContent = `${totalFills.toLocaleString()} fills across ${entries.length.toLocaleString()} day${entries.length === 1 ? '' : 's'} (${totalBuys.toLocaleString()} buys · ${totalSells.toLocaleString()} sells)`;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const tooltipFormatter = (params) => {
        if (!Array.isArray(params) || !params.length) return '';
        const date = params[0]?.axisValueLabel || '';
        const rows = params.map((p) => {
          const val = Math.abs(Number(p.value) || 0);
          return `
            <div style="display:flex;align-items:center;gap:6px;">
              <span style="display:inline-block;width:10px;height:10px;border-radius:999px;background:${p.color};"></span>
              <span>${p.seriesName}: ${val.toLocaleString()}</span>
            </div>
          `;
        }).join('');
        return `<div><div class="font-semibold mb-1">${date}</div>${rows}</div>`;
      };
      fillsPerDayChartInst.setOption({
        color: ['#0f766e', '#dc2626', '#2563eb'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 55, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'shadow' },
          formatter: tooltipFormatter
        },
        legend: {
          data: ['Buy fills (shown negative)', 'Sell fills', 'Net Sell Fills'],
          selected: { 'Net Sell Fills': false },
          textStyle: { color: '#475569' }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b', rotate: 45 },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Buy fills (shown negative)',
            type: 'bar',
            barGap: '25%',
            barCategoryGap: '45%',
            itemStyle: { color: '#0f766e' },
            data: buyCounts
          },
          {
            name: 'Sell fills',
            type: 'bar',
            barGap: '25%',
            barCategoryGap: '45%',
            itemStyle: { color: '#dc2626' },
            data: sellCounts
          },
          {
            name: 'Net Sell Fills',
            type: 'bar',
            barGap: '25%',
            barCategoryGap: '45%',
            itemStyle: { color: '#2563eb' },
            data: entries.map(entry => (Number(entry.sell) || 0) - (Number(entry.buy) || 0))
          }
        ]
      }, true);
    }

    function renderOpenLevelsChart(ladderHistory) {
      const container = document.getElementById('openLevelsChart');
      const emptyState = document.getElementById('openLevelsEmpty');
      const label = document.getElementById('openLevelsSummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!openLevelsChartInst) {
        openLevelsChartInst = echarts.init(container);
      }
      const { entries, stats } = computeDailyOpenLevels(ladderHistory);
      if (!entries.length) {
        openLevelsChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      const categories = entries.map(entry => entry.key);
      const levels = entries.map(entry => Number(entry.levels) || 0);
      const maxLevels = Number.isFinite(stats?.max) ? stats.max : 0;
      const lastLevels = Number.isFinite(stats?.last) ? stats.last : 0;
      if (label) {
        label.textContent = `${entries.length.toLocaleString()} day${entries.length === 1 ? '' : 's'} · last: ${lastLevels.toLocaleString()} open level${lastLevels === 1 ? '' : 's'} · max: ${maxLevels.toLocaleString()}`;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const tooltipFormatter = (params) => {
        if (!Array.isArray(params) || !params.length) return '';
        const date = params[0]?.axisValueLabel || '';
        const rows = params.map((p) => {
          const val = Number(p.value) || 0;
          return `
            <div style="display:flex;align-items:center;gap:6px;">
              <span style="display:inline-block;width:10px;height:10px;border-radius:999px;background:${p.color};"></span>
              <span>${p.seriesName}: ${val.toLocaleString()}</span>
            </div>
          `;
        }).join('');
        return `<div><div class="font-semibold mb-1">${date}</div>${rows}</div>`;
      };
      openLevelsChartInst.setOption({
        color: ['#2563eb'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 55, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'line' },
          formatter: tooltipFormatter
        },
        legend: {
          data: ['Open Levels (end of day)'],
          textStyle: { color: '#475569' }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b', rotate: 45 },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Open Levels (end of day)',
            type: 'bar',
            barGap: '30%',
            barCategoryGap: '45%',
            itemStyle: { color: '#2563eb' },
            data: levels
          }
        ]
      }, true);
    }

    function renderFillsPerMonthChart(trades) {
      const container = document.getElementById('monthlyFillsChart');
      const emptyState = document.getElementById('monthlyFillsEmpty');
      const label = document.getElementById('fillsMonthSummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!fillsPerMonthChartInst) {
        fillsPerMonthChartInst = echarts.init(container);
      }
      const source = Array.isArray(trades) ? trades : [];
      const counts = new Map();
      const addCount = (key, type) => {
        if (!key) return;
        if (!counts.has(key)) counts.set(key, { key, buy: 0, sell: 0 });
        const entry = counts.get(key);
        if (type === 'buy') entry.buy += 1;
        if (type === 'sell') entry.sell += 1;
      };
      for (const trade of source) {
        addCount(formatMonthKeyFromDate(trade?.buyTime), 'buy');
        addCount(formatMonthKeyFromDate(trade?.sellTime), 'sell');
      }
      const entries = Array.from(counts.values());
      if (!entries.length) {
        fillsPerMonthChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      entries.sort((a, b) => {
        const [am, ay] = a.key.split('/').map(Number);
        const [bm, by] = b.key.split('/').map(Number);
        if (ay !== by) return ay - by;
        return am - bm;
      });
      const categories = entries.map(entry => entry.key);
      const buyCounts = entries.map(entry => entry.buy);
      const sellCounts = entries.map(entry => entry.sell);
      const totalBuys = buyCounts.reduce((sum, val) => sum + val, 0);
      const totalSells = sellCounts.reduce((sum, val) => sum + val, 0);
      const totalFills = totalBuys + totalSells;
      if (label) {
        label.textContent = `${totalFills.toLocaleString()} fills (${totalBuys.toLocaleString()} buys · ${totalSells.toLocaleString()} sells)`;
      }
      if (emptyState) emptyState.classList.add('hidden');
      fillsPerMonthChartInst.setOption({
        color: ['#0f766e', '#dc2626'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'shadow' }
        },
        legend: {
          data: ['Buy fills', 'Sell fills'],
          textStyle: { color: '#475569' }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b' },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Buy fills',
            type: 'bar',
            barGap: '30%',
            barCategoryGap: '40%',
            itemStyle: { color: '#0f766e' },
            data: buyCounts
          },
          {
            name: 'Sell fills',
            type: 'bar',
            barGap: '30%',
            barCategoryGap: '40%',
            itemStyle: { color: '#dc2626' },
            data: sellCounts
          }
        ]
      }, true);
    }

    function updatePriceDistributionToggle() {
      const toggle = document.getElementById('priceFillToggle');
      if (!toggle) return;
      toggle.querySelectorAll('button[data-view]').forEach(btn => {
        const view = btn.getAttribute('data-view');
        const active = view === PRICE_DISTRIBUTION_VIEW;
        btn.setAttribute('aria-pressed', active ? 'true' : 'false');
        btn.classList.toggle('text-white', active);
        btn.classList.toggle('text-slate-600', !active);
        btn.classList.toggle('bg-emerald-600', active && view === 'buy');
        btn.classList.toggle('bg-rose-600', active && view === 'sell');
        btn.classList.toggle('bg-transparent', !active);
      });
    }

    function setPriceDistributionView(view) {
      const next = view === 'sell' ? 'sell' : 'buy';
      if (PRICE_DISTRIBUTION_VIEW === next) return;
      PRICE_DISTRIBUTION_VIEW = next;
      updatePriceDistributionToggle();
      renderPriceDistributionChart(GRID_STATE.trades || []);
    }

    function computePriceFillCounts(trades) {
      const source = Array.isArray(trades) ? trades : [];
      const precision = getActivePricePrecision();
      const buyMap = new Map();
      const sellMap = new Map();
      const addPrice = (map, value) => {
        const rounded = roundToPrecision(value, precision);
        if (!Number.isFinite(rounded)) return;
        map.set(rounded, (map.get(rounded) || 0) + 1);
      };
      for (const trade of source) {
        const buyPrice = Number(trade?.buyPrice);
        const sellPrice = Number(trade?.sellPrice);
        if (Number.isFinite(buyPrice)) addPrice(buyMap, buyPrice);
        if (Number.isFinite(sellPrice)) addPrice(sellMap, sellPrice);
      }
      const toEntries = (map) => {
        const entries = Array.from(map.entries()).map(([price, count]) => ({ price, count }));
        entries.sort((a, b) => a.price - b.price);
        return entries;
      };
      return {
        buyEntries: toEntries(buyMap),
        sellEntries: toEntries(sellMap),
        precision
      };
    }

    function renderPriceDistributionChart(trades) {
      const container = document.getElementById('priceDistributionChart');
      const emptyState = document.getElementById('priceDistributionEmpty');
      const label = document.getElementById('priceDistributionLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!priceDistributionChartInst) {
        priceDistributionChartInst = echarts.init(container);
      }
      updatePriceDistributionToggle();
      const { buyEntries, sellEntries, precision } = computePriceFillCounts(trades);
      const totalBuys = buyEntries.reduce((sum, entry) => sum + entry.count, 0);
      const totalSells = sellEntries.reduce((sum, entry) => sum + entry.count, 0);
      const hasAny = totalBuys + totalSells > 0;
      if (label) {
        if (hasAny) {
          const buyLabel = `${totalBuys.toLocaleString()} buy fill${totalBuys === 1 ? '' : 's'}`;
          const sellLabel = `${totalSells.toLocaleString()} sell fill${totalSells === 1 ? '' : 's'}`;
          label.textContent = `${buyLabel} · ${sellLabel}`;
        } else {
          label.textContent = '';
        }
      }
      const view = PRICE_DISTRIBUTION_VIEW === 'sell' ? 'sell' : 'buy';
      const entries = view === 'sell' ? sellEntries : buyEntries;
      if (!entries.length) {
        priceDistributionChartInst.clear();
        if (emptyState) {
          if (hasAny) {
            emptyState.textContent = view === 'sell'
              ? 'No sell fills to chart for this run.'
              : 'No buy fills to chart for this run.';
          } else {
            emptyState.textContent = view === 'sell'
              ? 'Run the backtest to chart sell fill counts by price.'
              : 'Run the backtest to chart buy fill counts by price.';
          }
          emptyState.classList.remove('hidden');
        }
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const categories = entries.map(entry => `$${formatPrice(entry.price, precision)}`);
      const values = entries.map(entry => entry.count);
      const seriesName = view === 'sell' ? 'Sell fills' : 'Buy fills';
      const barColor = view === 'sell' ? '#dc2626' : '#0f766e';
      priceDistributionChartInst.setOption({
        color: [barColor],
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'shadow' },
          formatter: (params) => {
            if (!Array.isArray(params) || !params.length) return '';
            const item = params[0];
            const value = Number(item?.value) || 0;
            return `${item?.name || 'Price'}<br/>${seriesName}: ${value.toLocaleString()}`;
          }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b' },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: seriesName,
            type: 'bar',
            barCategoryGap: '35%',
            itemStyle: { color: barColor },
            data: values
          }
        ]
      }, true);
    }

    function computeLevelFillCounts(trades) {
      const source = Array.isArray(trades) ? trades : [];
      const counts = new Map();
      for (const trade of source) {
        const level = Number(trade?.openLevels);
        if (!Number.isFinite(level) || level <= 0) continue;
        counts.set(level, (counts.get(level) || 0) + 1);
      }
      const entries = Array.from(counts.entries()).map(([level, count]) => ({ level, count }));
      entries.sort((a, b) => a.level - b.level);
      const total = entries.reduce((sum, entry) => sum + entry.count, 0);
      return { entries, total };
    }

    function renderLevelDistributionChart(trades) {
      const container = document.getElementById('levelDistributionChart');
      const emptyState = document.getElementById('levelDistributionEmpty');
      const label = document.getElementById('levelDistributionLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!levelDistributionChartInst) {
        levelDistributionChartInst = echarts.init(container);
      }
      const { entries, total } = computeLevelFillCounts(trades);
      if (!entries.length) {
        levelDistributionChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      const categories = entries.map(entry => `Level ${entry.level}`);
      const values = entries.map(entry => entry.count);
      const totalSells = total;
      if (label) {
        label.textContent = `${totalSells.toLocaleString()} sell fills across ${entries.length} level${entries.length === 1 ? '' : 's'}`;
      }
      if (emptyState) emptyState.classList.add('hidden');
      levelDistributionChartInst.setOption({
        color: ['#6366f1'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'shadow' },
          formatter: (params) => {
            if (!params || !params.length) return '';
            const item = params[0];
            const value = Number(item?.value) || 0;
            return `${item?.name || 'Level'}<br/>Sell fills: ${value.toLocaleString()}`;
          }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b' },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Sell fills',
            type: 'bar',
            barCategoryGap: '35%',
            itemStyle: { color: '#6366f1' },
            data: values
          }
        ]
      }, true);
    }

    function renderCumulativeLevelDistributionChart(trades) {
      const container = document.getElementById('cumulativeLevelDistributionChart');
      const emptyState = document.getElementById('cumulativeLevelDistributionEmpty');
      const label = document.getElementById('cumulativeLevelDistributionLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!cumulativeLevelDistributionChartInst) {
        cumulativeLevelDistributionChartInst = echarts.init(container);
      }
      const { entries, total } = computeLevelFillCounts(trades);
      if (!entries.length || !total) {
        cumulativeLevelDistributionChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      let running = 0;
      const cumulative = entries.map(entry => {
        running += entry.count;
        const pct = total > 0 ? (running / total) * 100 : 0;
        return { ...entry, running, pct };
      });
      const categories = cumulative.map(entry => `Level ${entry.level}`);
      const pctValues = cumulative.map(entry => Number(entry.pct.toFixed(2)));
      const findThresholdLevel = (thresholdPct) => {
        const hit = cumulative.find(entry => entry.pct >= thresholdPct);
        return hit ? hit.level : null;
      };
      const p50Level = findThresholdLevel(50);
      const p75Level = findThresholdLevel(75);
      const labelParts = [`${total.toLocaleString()} sell fill${total === 1 ? '' : 's'}`];
      labelParts.push(`${entries.length.toLocaleString()} level${entries.length === 1 ? '' : 's'}`);
      if (p50Level != null) labelParts.push(`50% reached by level ${p50Level}`);
      if (p75Level != null) labelParts.push(`75% by level ${p75Level}`);
      if (label) label.textContent = labelParts.join(' · ');
      if (emptyState) emptyState.classList.add('hidden');
      const tooltipFormatter = (params) => {
        if (!Array.isArray(params) || !params.length) return '';
        const idx = Number(params[0]?.dataIndex);
        const entry = Number.isInteger(idx) && idx >= 0 ? cumulative[idx] : null;
        if (!entry) return '';
        const pctLabel = formatNumber(entry.pct, 2);
        return `
          <div class="text-xs">
            <div class="font-semibold">${params[0]?.name || 'Level'}</div>
            <div>Level fills: ${entry.count.toLocaleString()}</div>
            <div>Cumulative: ${entry.running.toLocaleString()} (${pctLabel}%)</div>
          </div>
        `;
      };
      cumulativeLevelDistributionChartInst.setOption({
        color: ['#0ea5e9'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'line' },
          formatter: tooltipFormatter
        },
        legend: {
          data: ['Cumulative % of Sell Fills'],
          textStyle: { color: '#475569' }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b' },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          min: 0,
          max: 100,
          axisLabel: {
            color: '#64748b',
            formatter: (val) => `${val.toFixed(0)}%`
          },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Cumulative % of Sell Fills',
            type: 'line',
            smooth: true,
            symbol: 'circle',
            symbolSize: 6,
            lineStyle: { width: 2 },
            areaStyle: { color: 'rgba(14, 165, 233, 0.12)' },
            markLine: {
              symbol: 'none',
              lineStyle: { color: 'rgba(100, 116, 139, 0.5)', type: 'dashed' },
              label: { color: '#475569', formatter: (params) => `${params.value}%` },
              data: [
                { yAxis: 50, name: '50%' },
                { yAxis: 75, name: '75%' }
              ]
            },
            data: pctValues
          }
        ]
      }, true);
    }

    function highlightTickerButton(symbol) {
      const seg = document.getElementById('tickerSegment');
      if (!seg) return;
      const upper = (symbol || '').toUpperCase();
      seg.querySelectorAll('button[data-symbol]').forEach(btn => {
        const active = (btn.getAttribute('data-symbol') || '').toUpperCase() === upper;
        btn.classList.toggle('bg-emerald-600', active);
        btn.classList.toggle('text-white', active);
        btn.classList.toggle('hover:bg-emerald-600', active);
        btn.classList.toggle('bg-white', !active);
        btn.classList.toggle('hover:bg-emerald-50', !active);
        const nameSpan = btn.querySelector('[data-symbol-name]');
        if (nameSpan) {
          nameSpan.classList.toggle('text-emerald-100', active);
          nameSpan.classList.toggle('text-slate-500', !active);
        }
      });
    }

    function renderDataSummary() {
      const summaryEl = document.getElementById('dataSummary');
      if (!summaryEl) return;
      if (!currentTicker) {
        summaryEl.textContent = 'Select a symbol to load intraday data.';
        return;
      }
      if (!ROWS.length) {
        summaryEl.innerHTML = `<span class="font-semibold">${currentTicker}</span> selected. Choose another symbol or verify data files exist in the <code>data/</code> folder.`;
        return;
      }
      const firstDay = DAYS[0];
      const lastDay = DAYS[DAYS.length - 1];
      summaryEl.innerHTML = `
        <span class="font-semibold">${currentTicker}</span> loaded
        <span class="font-medium">${ROWS.length.toLocaleString()}</span> bars across
        <span class="font-medium">${DAYS.length.toLocaleString()}</span> trading day(s)
        (${firstDay || 'n/a'} → ${lastDay || 'n/a'}).
      `;
    }

    function getSymbolExchange(symbol) {
      const sym = (symbol || '').trim().toUpperCase();
      if (!sym) return DEFAULT_EXCHANGE;
      const metaOverride = WATCHLIST_STATE.symbol_meta ? WATCHLIST_STATE.symbol_meta[sym] : null;
      const overrideExchange = normalizeExchange(metaOverride && metaOverride.exchange);
      if (overrideExchange) return overrideExchange;
      const meta = ensureSymbolMetaEntry(sym);
      const metaExchange = normalizeExchange(meta && meta.exchange);
      return metaExchange || DEFAULT_EXCHANGE;
    }

    function getTradingViewSymbol(symbol, exchange) {
      const raw = (symbol || '').trim().toUpperCase();
      if (!raw) return '';
      if (raw.includes(':')) return raw;
      const normalizedExchange = normalizeExchange(exchange) || DEFAULT_EXCHANGE;
      return `${normalizedExchange}:${raw}`;
    }

    function renderTradingViewProfile(symbol) {
      const container = document.getElementById('tvSymbolProfile');
      const label = document.getElementById('symbolProfileLabel');
      if (!container) return;
      const sym = (symbol || '').trim().toUpperCase();
      if (!sym) {
        container.innerHTML = '<div class="text-sm text-slate-500">Select a symbol to load key facts.</div>';
        if (label) label.textContent = '';
        return;
      }
      const exchange = getSymbolExchange(sym);
      const tvSymbol = getTradingViewSymbol(sym, exchange);
      const linkSymbol = tvSymbol.replace(':', '-');
      container.innerHTML = `
        <div class="tradingview-widget-container">
          <div class="tradingview-widget-container__widget"></div>
          <div class="tradingview-widget-copyright">
            <a href="https://www.tradingview.com/symbols/${linkSymbol}/" rel="noopener nofollow" target="_blank">
              <span class="blue-text">${sym} key facts</span>
            </a>
            <span class="trademark"> by TradingView</span>
          </div>
        </div>
      `;
      const widgetContainer = container.querySelector('.tradingview-widget-container');
      if (!widgetContainer) return;
      const script = document.createElement('script');
      script.type = 'text/javascript';
      script.src = 'https://s3.tradingview.com/external-embedding/embed-widget-symbol-profile.js';
      script.async = true;
      script.textContent = JSON.stringify({
        symbol: tvSymbol,
        colorTheme: 'light',
        isTransparent: true,
        locale: 'en',
        width: '100%',
        height: 300
      });
      widgetContainer.appendChild(script);
      if (label) label.textContent = tvSymbol;
    }

    function setTicker(sym) {
      currentTicker = (sym || '').toUpperCase();
      const titleEl = document.getElementById('mainTitle');
      const meta = ensureSymbolMetaEntry(currentTicker);
      const friendlyName = meta && meta.name && meta.name.toUpperCase() !== currentTicker ? ` · ${meta.name}` : '';
      const fullTitle = currentTicker ? `${currentTicker}${friendlyName} - Buy the Dip Backtest` : 'Buy the Dip Backtest';
      if (titleEl) titleEl.textContent = fullTitle;
      document.title = fullTitle;
      highlightTickerButton(currentTicker);
      updateBasePriceInput(currentTicker);
      renderTradingViewProfile(currentTicker);
      const loadingMsg = currentTicker ? `Loading data for ${currentTicker}…` : 'Load data and run the backtest to populate results.';
      resetGridOutputs(loadingMsg);
      setRunButtonEnabled(false);
      renderDataSummary();
    }

    function resetGridOutputs(message) {
      GRID_STATE = { trades: [], summary: null, equitySeries: [], ladderHistory: [], buyLevels: [], sellLevels: [], baseLevel: null, gridLevels: [] };
      renderGridSummary(null);
      renderGridTrades([], { resetPage: true });
      setGridStatus(message || 'Load data and run the backtest to populate results.');
      setSaveButtonEnabled(false);
      renderGridEquityChart(null);
      renderLadderChart([]);
      renderFillsPerDayChart([]);
      renderOpenLevelsChart([]);
      renderFillsPerMonthChart([]);
      renderPriceDistributionChart([]);
      renderLevelDistributionChart([]);
      renderCumulativeLevelDistributionChart([]);
      renderGridLevels([], [], null);
      buildMonthFilterOptions();
    }

    function applyResamplingFromBase() {
      if (!Array.isArray(BASE_ROWS) || !BASE_ROWS.length) {
        ROWS = [];
        DAY_GROUPS = new Map();
        DAYS = [];
        buildMonthFilterOptions();
        return;
      }
      ROWS = resampleIntradayRows(BASE_ROWS, RESAMPLE_INTERVAL_MINUTES);
      DAY_GROUPS = new Map();
      for (const row of ROWS) {
        if (!DAY_GROUPS.has(row.dayKey)) DAY_GROUPS.set(row.dayKey, []);
        DAY_GROUPS.get(row.dayKey).push(row);
      }
      for (const [, arr] of DAY_GROUPS.entries()) arr.sort((a, b) => a.caldt - b.caldt);
      DAYS = Array.from(DAY_GROUPS.keys()).sort();
      computeDailySmaMaps();
      buildMonthFilterOptions();
    }

    function normalizeAndIndex(rows) {
      if (!rows || !rows.length) {
        BASE_ROWS = [];
        applyResamplingFromBase();
        return;
      }
      const required = ['caldt', 'day', 'open', 'high', 'low', 'close'];
      const missing = required.filter(c => !(c in rows[0]));
      if (missing.length) throw new Error('Missing columns: ' + missing.join(', '));

      const cleanRows = rows.map(r => {
        const caldt = new Date(r.caldt);
        const dayKey = dateKeyFromStr(r.day);
        const open = Number(r.open), high = Number(r.high), low = Number(r.low), close = Number(r.close);
        if (!dayKey || isNaN(caldt)) return null;
        if ([open, high, low, close].some(v => !Number.isFinite(v))) return null;
        return { caldt, dayKey, open, high, low, close, sma10: null, sma20: null, sma50: null, sma100: null };
      }).filter(Boolean);
      cleanRows.sort((a, b) => a.caldt - b.caldt);
      BASE_ROWS = cleanRows;
      applyResamplingFromBase();
    }

    function resampleIntradayRows(rows, minutes) {
      if (!Array.isArray(rows) || !rows.length) return [];
      const interval = Number(minutes);
      if (!Number.isFinite(interval) || interval <= 1) {
        return [...rows];
      }
      const intervalMs = Math.max(1, Math.floor(interval)) * 60000;
      const aggregated = [];
      let current = null;

      const flush = () => {
        if (!current) return;
        const caldt = current.lastTimeMs != null ? new Date(current.lastTimeMs) : new Date(current.bucketStartMs);
        aggregated.push({
          caldt,
          dayKey: current.dayKey,
          open: current.open,
          high: current.high,
          low: current.low,
          close: current.close,
          sma10: null,
          sma20: null,
          sma50: null,
          sma100: null
        });
        current = null;
      };

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const timeMs = row.caldt.getTime();
        const bucketStartMs = Math.floor(timeMs / intervalMs) * intervalMs;
        if (!current || current.dayKey !== row.dayKey || current.bucketStartMs !== bucketStartMs) {
          flush();
          current = {
            dayKey: row.dayKey,
            bucketStartMs,
            open: row.open,
            high: row.high,
            low: row.low,
            close: row.close,
            lastTimeMs: timeMs
          };
          continue;
        }
        if (row.high > current.high) current.high = row.high;
        if (row.low < current.low) current.low = row.low;
        current.close = row.close;
        current.lastTimeMs = timeMs;
      }
      flush();
      aggregated.sort((a, b) => a.caldt - b.caldt);
      return aggregated;
    }

    function computeDailySmaMaps() {
      DAY_SMA_MAPS = new Map();
      SMA_METADATA = new Map();
      if (!Array.isArray(DAYS) || !DAYS.length) return;
      const windows = Array.isArray(DAILY_SMA_WINDOWS) && DAILY_SMA_WINDOWS.length ? DAILY_SMA_WINDOWS : [];
      if (!windows.length) return;
      windows.forEach(win => DAY_SMA_MAPS.set(win, new Map()));
      const dailyCloses = [];
      for (const dayKey of DAYS) {
        const rows = DAY_GROUPS.get(dayKey);
        if (!Array.isArray(rows) || !rows.length) continue;
        const lastRow = rows[rows.length - 1];
        if (!lastRow) continue;
        const close = Number(lastRow.close);
        if (!Number.isFinite(close)) continue;
        dailyCloses.push({ dayKey, close });
      }
      for (const window of windows) {
        const target = DAY_SMA_MAPS.get(window);
        if (!target) continue;
        let firstIdx = null;
        for (let i = 0; i < dailyCloses.length; i++) {
          if (i + 1 < window) continue;
          let sum = 0;
          for (let j = i - window + 1; j <= i; j++) {
            sum += dailyCloses[j].close;
          }
          const avg = sum / window;
          target.set(dailyCloses[i].dayKey, avg);
          if (firstIdx == null) firstIdx = i;
        }
        const totalDays = dailyCloses.length;
        const availableDays = firstIdx == null ? 0 : (totalDays - firstIdx);
        SMA_METADATA.set(window, {
          totalDays,
          availableDays,
          firstDay: firstIdx != null ? dailyCloses[firstIdx].dayKey : null,
          required: window
        });
      }
      for (const row of ROWS) {
        if (!row) continue;
        const dayKey = row.dayKey;
        for (const prop of SMA_PROPERTIES) {
          row[prop] = null;
        }
        for (const window of windows) {
          const map = DAY_SMA_MAPS.get(window);
          if (!map) continue;
          const value = map.get(dayKey);
          const prop = SMA_PROPERTY_BY_WINDOW[window];
          if (prop) row[prop] = Number.isFinite(value) ? value : null;
        }
      }
    }

    function collectOrdersInRange(map, minVal, maxVal, ascending) {
      const out = [];
      if (!map || !map.size) return out;
      const lower = Math.min(minVal, maxVal);
      const upper = Math.max(minVal, maxVal);
      for (const arr of map.values()) {
        if (!Array.isArray(arr) || !arr.length) continue;
        for (const order of arr) {
          if (!order || !Number.isFinite(order.level)) continue;
          const tolerance = 1e-9 * Math.max(1, Math.abs(order.level), Math.abs(lower), Math.abs(upper));
          if (order.level >= (lower - tolerance) && order.level <= (upper + tolerance)) {
            out.push(order);
          }
        }
      }
      out.sort((a, b) => ascending ? (a.level - b.level) : (b.level - a.level));
      return out;
    }

    function runBuyTheGridSimulation(rows, params) {
      const trades = [];
      const equitySeries = [];
      const ladderHistory = [];
      const summary = {
        totalTrades: 0,
        netProfit: 0,
        profitPerLevel: 0,
        finalEquity: 0,
        totalRetainedShares: 0,
        cash: 0,
        minCash: 0,
        shares: 0,
        maxDrawdown: 0,
        maxSharesHeld: 0,
        maxOpenLevels: 0,
        maxDeployedCapital: 0,
        cagr: 0
      };
      const buyLevelSet = new Set();
      const sellLevelSet = new Set();
      let gridLevels = [];
      let resolveBaseLevel = () => NaN;
      const finalizeResult = () => ({
        trades,
        summary,
        equitySeries,
        ladderHistory,
        buyLevels: Array.from(buyLevelSet).sort((a, b) => b - a),
        sellLevels: Array.from(sellLevelSet).sort((a, b) => a - b),
        gridLevels: Array.isArray(gridLevels) ? gridLevels : [],
        baseLevel: (() => {
          const val = resolveBaseLevel();
          return Number.isFinite(val) ? val : null;
        })()
      });
      if (!Array.isArray(rows) || !rows.length) {
        return finalizeResult();
      }
      const rawGridSize = Number(params?.gridSize);
      const rawBasePrice = Number(params?.basePrice);
      const gridSpacingType = (params?.gridSpacingType || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const tradeValue = Number(params?.tradeValue);
      const tickSize = Number(params?.tickSize);
      const resolvedTickSize = Number.isFinite(tickSize) && tickSize > 0 ? tickSize : 0.01;
      const fractional = !!params?.fractionalShares;
      const retentionMode = (params?.retentionMode || 'profit').toLowerCase();
      const entryFilter = (params?.entryFilter || 'none').toLowerCase();
      if (!Number.isFinite(rawGridSize) || rawGridSize <= 0 || !Number.isFinite(tradeValue) || tradeValue <= 0) {
        return finalizeResult();
      }
      let firstPrice = [rows[0]?.open, rows[0]?.close, rows[0]?.high, rows[0]?.low].map(Number).find(Number.isFinite);
      if (!Number.isFinite(firstPrice) || firstPrice <= 0) {
        return finalizeResult();
      }
      const basePrice = Number.isFinite(rawBasePrice) && rawBasePrice > 0 ? rawBasePrice : firstPrice;
      let minPrice = firstPrice;
      let maxPrice = firstPrice;
      for (const row of rows) {
        if (!row) continue;
        const low = Number(row.low);
        const high = Number(row.high);
        if (Number.isFinite(low)) minPrice = Math.min(minPrice, low);
        if (Number.isFinite(high)) maxPrice = Math.max(maxPrice, high);
      }
      if (!Number.isFinite(minPrice) || !Number.isFinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) {
        return finalizeResult();
      }

      const spacing = createGridSpacingHelpers({
        spacingType: gridSpacingType,
        gridSize: rawGridSize,
        basePrice,
        firstPrice,
        minPrice,
        maxPrice,
        tickSize: resolvedTickSize
      });
      if (spacing.error) {
        console.warn('Grid spacing configuration invalid:', spacing.error);
        return finalizeResult();
      }
      gridLevels = Array.isArray(spacing.gridLevels) ? spacing.gridLevels : [];
      gridLevels = Array.isArray(spacing.gridLevels) ? spacing.gridLevels : [];
      const snapLevel = spacing.snap;
      const keyFor = spacing.key;
      const nextUpLevel = spacing.nextUp;
      const nextDownLevel = spacing.nextDown;
      const stepsBetween = spacing.stepsBetween;
      const priceTolerance = spacing.priceTolerance ?? 1e-9;
      const usePercentSpacing = spacing.type === 'percent';
      const initialBaseLevel = snapLevel(basePrice);
      resolveBaseLevel = () => {
        if (usePercentSpacing && typeof spacing.getAnchor === 'function') {
          const anchor = spacing.getAnchor();
          if (Number.isFinite(anchor)) return anchor;
        }
        return initialBaseLevel;
      };
      const currentBaseLevel = () => {
        if (usePercentSpacing && typeof spacing.getAnchor === 'function') {
          const anchor = spacing.getAnchor();
          if (Number.isFinite(anchor)) return anchor;
        }
        return initialBaseLevel;
      };
      const computeRungIndex = (level) => {
        const anchor = currentBaseLevel();
        if (!Number.isFinite(level) || !Number.isFinite(anchor)) return 0;
        const diff = stepsBetween(anchor, level);
        if (!Number.isFinite(diff)) return 0;
        return Math.round(diff);
      };

      const activeBuys = new Map();
      const activeSells = new Map();
      const queuedBuyActivations = [];
      let orderSeq = 1;
      let highestSeededBuyLevel = Number.NEGATIVE_INFINITY;

      const removeOrder = (map, order) => {
        if (!order || !Number.isFinite(order.level)) return;
        const key = keyFor(order.level);
        const arr = map.get(key);
        if (!arr) return;
        const idx = arr.indexOf(order);
        if (idx >= 0) arr.splice(idx, 1);
        if (!arr.length) map.delete(key);
      };

      const addBuyOrder = (level) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price) || price <= 0) return null;
        buyLevelSet.add(price);
        const key = keyFor(price);
        const existing = activeBuys.get(key);
        if (existing && existing.length) return existing[0];
        const order = { id: orderSeq++, level: price, rungIndex: computeRungIndex(price) };
        activeBuys.set(key, [order]);
        if (!Number.isFinite(highestSeededBuyLevel) || price > highestSeededBuyLevel) {
          highestSeededBuyLevel = price;
        }
        return order;
      };

      const addSellOrder = (level, buyInfo) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price) || price <= 0) return null;
        const key = keyFor(price);
        if (!activeSells.has(key)) activeSells.set(key, []);
        const order = {
          id: orderSeq++,
          level: price,
          buyPrice: Number(buyInfo?.price),
          buyQty: Number(buyInfo?.qty),
          buyTime: buyInfo?.time instanceof Date ? new Date(buyInfo.time.getTime()) : new Date(),
          buyRung: Number.isFinite(buyInfo?.rungIndex) ? buyInfo.rungIndex : computeRungIndex(price)
        };
        activeSells.get(key).push(order);
        return order;
      };

      const applyBaseAnchor = (basePrice) => {
        if (!usePercentSpacing || typeof spacing.setAnchor !== 'function') return;
        const snapped = snapLevel(basePrice);
        if (Number.isFinite(snapped) && snapped > 0) {
          spacing.setAnchor(snapped);
        }
      };

      const seedDownLadderFromBase = (basePrice) => {
        const snappedBase = snapLevel(basePrice);
        if (!Number.isFinite(snappedBase) || snappedBase <= 0) return;
        let level = nextDownLevel(snappedBase);
        let safety = 0;
        const coverageFloor = Math.max(minPrice, priceTolerance);
        while (
          Number.isFinite(level) &&
          level > 0 &&
          level >= coverageFloor - priceTolerance * Math.max(1, level) &&
          safety < 5000
        ) {
          addBuyOrder(level);
          const nextLevel = nextDownLevel(level);
          if (!Number.isFinite(nextLevel) || Math.abs(nextLevel - level) <= priceTolerance * Math.max(1, level)) break;
          level = nextLevel;
          safety += 1;
        }
        if (!Number.isFinite(highestSeededBuyLevel) || highestSeededBuyLevel === Number.NEGATIVE_INFINITY) {
          const fallback = nextDownLevel(snappedBase);
          if (Number.isFinite(fallback) && fallback > 0) {
            const order = addBuyOrder(fallback);
            if (order) highestSeededBuyLevel = order.level;
          }
        }
      };

      applyBaseAnchor(basePrice);
      seedDownLadderFromBase(basePrice);

      let cash = 0;
      let minCashBalance = cash;
      let capitalContributed = 0;
      let netCashflowTrades = 0;
      let requiredCapital = 0;
      const initialEquity = cash;
      let fundedLevels = 0;
      let openPositions = 0;
      const firstEquityTime = rows[0]?.caldt instanceof Date ? new Date(rows[0].caldt.getTime()) : null;
      let lastEquityTime = firstEquityTime;
      let shares = 0;
      let realizedProfit = 0;
      let cumulativeRetained = 0;
      let prevPrice = firstPrice;
      let peakEquity = cash + shares * firstPrice;
      let maxDrawdown = 0;
      let maxDrawdownPct = 0;
      let maxSharesHeld = shares;

      const updateRequiredCapital = () => {
        requiredCapital = Math.max(requiredCapital, -netCashflowTrades);
      };

      const hasActiveBuy = (level) => {
        const price = snapLevel(level);
        const key = keyFor(price);
        const arr = activeBuys.get(key);
        return Array.isArray(arr) && arr.length > 0;
      };

      const hasQueuedBuyActivation = (level) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price)) return false;
        return queuedBuyActivations.some(entry => {
          const diff = Math.abs(entry.buyLevel - price);
          return diff <= priceTolerance * Math.max(1, entry.buyLevel);
        });
      };

      const queueDelayedBuy = (sellPrice) => {
        const buyPrice = snapLevel(sellPrice);
        if (!Number.isFinite(buyPrice) || buyPrice <= 0) return;
        if (hasActiveBuy(buyPrice) || hasQueuedBuyActivation(buyPrice)) return;
        const triggerLevel = nextUpLevel(buyPrice);
        if (!Number.isFinite(triggerLevel) || triggerLevel <= 0) return;
        if (Math.abs(triggerLevel - buyPrice) <= priceTolerance * Math.max(1, triggerLevel)) return;
        queuedBuyActivations.push({ buyLevel: buyPrice, trigger: triggerLevel });
      };

      const ensureRunupBuys = (maxPrice) => {
        if (!Number.isFinite(maxPrice)) return;
        if (!Number.isFinite(highestSeededBuyLevel)) return;
        let safety = 0;
        while (stepsBetween(highestSeededBuyLevel, Math.max(maxPrice, highestSeededBuyLevel)) >= 2 - 1e-9 && safety < 1000) {
          const nextLevel = nextUpLevel(highestSeededBuyLevel);
          if (!Number.isFinite(nextLevel) || nextLevel <= 0) break;
          if (!hasActiveBuy(nextLevel) && !hasQueuedBuyActivation(nextLevel)) {
            addBuyOrder(nextLevel);
          }
          if (Math.abs(nextLevel - highestSeededBuyLevel) <= priceTolerance * Math.max(1, nextLevel)) break;
          highestSeededBuyLevel = nextLevel;
          safety += 1;
        }
      };

      const activateQueuedBuys = (maxPrice) => {
        if (!Number.isFinite(maxPrice) || !queuedBuyActivations.length) return;
        for (let i = queuedBuyActivations.length - 1; i >= 0; i--) {
          const entry = queuedBuyActivations[i];
          if (!entry) continue;
          const tolerance = priceTolerance * Math.max(1, entry.trigger);
          if (maxPrice >= entry.trigger - tolerance) {
            addBuyOrder(entry.buyLevel);
            queuedBuyActivations.splice(i, 1);
          }
        }
      };

      const executeBuy = (order, timestamp, contextRow) => {
        if (!order) return false;
        const price = order.level;
        if (!passesEntryFilter(price, contextRow, entryFilter)) {
          return false;
        }
        const qtyRaw = tradeValue / price;
        let qty = fractional ? qtyRaw : Math.floor(qtyRaw);
        if (!Number.isFinite(qty) || qty <= 0) {
          removeOrder(activeBuys, order);
          return false;
        }
        const neededPositions = openPositions + 1;
        if (neededPositions > fundedLevels) {
          const levelsToAdd = neededPositions - fundedLevels;
          const deposit = levelsToAdd * tradeValue;
          cash += deposit;
          capitalContributed += deposit;
          fundedLevels += levelsToAdd;
          const deployed = fundedLevels * tradeValue;
          if (deployed > summary.maxDeployedCapital) {
            summary.maxDeployedCapital = deployed;
          }
        }
        const cost = qty * price;
        cash -= cost;
        netCashflowTrades -= cost;
        updateRequiredCapital();
        if (cash < minCashBalance) minCashBalance = cash;
        shares += qty;
        if (shares > maxSharesHeld) maxSharesHeld = shares;
        openPositions += 1;
        if (openPositions > summary.maxOpenLevels) summary.maxOpenLevels = openPositions;
        removeOrder(activeBuys, order);
        const sellLevel = nextUpLevel(price);
        if (Number.isFinite(sellLevel) && sellLevel > 0) {
          addSellOrder(sellLevel, { price, qty, time: timestamp, rungIndex: Number.isFinite(order?.rungIndex) ? order.rungIndex : computeRungIndex(price) });
        }
        return true;
      };

      const executeSell = (order, timestamp) => {
        if (!order) return false;
        const price = order.level;
        const openQty = shares;
        const desiredRaw = tradeValue / price;
        let desired = fractional ? desiredRaw : Math.floor(desiredRaw);
        const exec = computeSellExecution({
          baseQty: order.buyQty,
          desiredQty: desired,
          sharesAvailable: shares,
          mode: retentionMode,
          fractional
        });
        let qty = exec.qty;
        if (!Number.isFinite(qty) || qty <= 0) {
          removeOrder(activeSells, order);
          return false;
        }
        const revenue = qty * price;
        const costBasis = qty * order.buyPrice;
        cash += revenue;
        netCashflowTrades += revenue;
        updateRequiredCapital();
        shares -= qty;
        if (openPositions > 0) openPositions -= 1;
        removeOrder(activeSells, order);
        const profit = revenue - costBasis;
        realizedProfit += profit;
        const qtyRetained = Math.max(0, exec.retained);
        cumulativeRetained += qtyRetained;
        const closeQty = shares;
        const closeEquity = cash + shares * price;
        const totalContributed = Math.max(0, openPositions) * tradeValue;
        const runningPnl = closeEquity - totalContributed;
        const nextPeak = Math.max(peakEquity, closeEquity);
        const drawdown = closeEquity - nextPeak;
        peakEquity = nextPeak;
        const sellTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const buyTime = order.buyTime instanceof Date ? new Date(order.buyTime.getTime()) : new Date();
        const msHeld = sellTime.getTime() - buyTime.getTime();
        const daysHeld = Number.isFinite(msHeld) ? Math.max(0, msHeld / 86400000) : 0;
        const openTradesCount = Array.from(activeSells.values()).reduce((acc, arr) => acc + (Array.isArray(arr) ? arr.length : 0), 0);
        const openLevelSnapshot = openTradesCount + 1;
        if (openLevelSnapshot > summary.maxOpenLevels) {
          summary.maxOpenLevels = openLevelSnapshot;
        }
        const openEquity = openLevelSnapshot * tradeValue;
        trades.push({
          buyTime,
          buyPrice: order.buyPrice,
          buyQty: order.buyQty,
          gridLevel: Number.isFinite(order.buyRung) ? order.buyRung : computeRungIndex(order.buyPrice),
          openLevels: openLevelSnapshot,
          openQty,
          openEquity,
          sellTime,
          sellPrice: price,
          sellQty: qty,
          closeQty,
          closeEquity,
          qtyRetained,
          cumQtyRetained: cumulativeRetained,
          daysHeld,
          profit,
          cumProfit: realizedProfit,
          runningPnl,
          drawdown,
          roiPct: costBasis > 0 ? (profit / costBasis) * 100 : 0
        });
        const buyLevel = nextDownLevel(price);
        if (Number.isFinite(buyLevel) && buyLevel > 0) {
          addBuyOrder(buyLevel);
        }
        queueDelayedBuy(price);
        return true;
      };

      const processMove = (start, end, timestamp, contextRow) => {
        if (!Number.isFinite(start) || !Number.isFinite(end)) return;
        const scale = Math.max(1, Math.abs(start), Math.abs(end));
        const threshold = priceTolerance * scale;
        if (end > start + threshold) {
          const sells = collectOrdersInRange(activeSells, start, end, true);
          for (const order of sells) executeSell(order, timestamp);
        } else if (end < start - threshold) {
          const buys = collectOrdersInRange(activeBuys, end, start, false);
          for (const order of buys) executeBuy(order, timestamp, contextRow);
        }
      const maxVal = Math.max(start, end);
      ensureRunupBuys(maxVal);
      activateQueuedBuys(maxVal);
      if (timestamp instanceof Date) {
        ladderHistory.push({
            time: new Date(timestamp.getTime()),
            buys: activeBuys.size,
            sells: activeSells.size,
            queued: queuedBuyActivations.length
          });
        }
      };

      const buildPath = (fromPrice, row) => {
        const path = [];
        let start = Number(fromPrice);
        if (!Number.isFinite(start)) start = Number(row.open) || Number(row.close) || 0;
        path.push(start);
        const addPoint = (value) => {
          const num = Number(value);
          if (!Number.isFinite(num)) return;
          if (Math.abs(num - path[path.length - 1]) < priceTolerance * Math.max(1, num)) return;
          path.push(num);
        };
        const open = Number(row.open);
        const high = Number(row.high);
        const low = Number(row.low);
        const close = Number(row.close);
        if (Number.isFinite(open)) addPoint(open);
        const upBar = Number.isFinite(close) && Number.isFinite(open) ? (close >= open) : true;
        if (upBar) {
          if (Number.isFinite(high)) addPoint(high);
          if (Number.isFinite(low)) addPoint(low);
        } else {
          if (Number.isFinite(low)) addPoint(low);
          if (Number.isFinite(high)) addPoint(high);
        }
        if (Number.isFinite(close)) addPoint(close);
        return path;
      };

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const path = buildPath(prevPrice, row);
        for (let i = 1; i < path.length; i++) {
          const from = path[i - 1];
          const to = path[i];
          processMove(from, to, row.caldt, row);
        }
        prevPrice = path[path.length - 1];
        const equity = cash + shares * prevPrice;
        const openBuyOrders = Array.from(activeBuys.values()).reduce((acc, arr) => acc + (Array.isArray(arr) ? arr.length : 0), 0);
        if (equity > peakEquity) peakEquity = equity;
        const drawdown = equity - peakEquity;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
        const equityPct = peakEquity > 0 ? (equity - peakEquity) / peakEquity : 0;
        if (equityPct < maxDrawdownPct) maxDrawdownPct = equityPct;
        lastEquityTime = new Date(row.caldt.getTime());
        equitySeries.push({
          time: new Date(row.caldt.getTime()),
          equity,
          cash: cash,
          cashDeployed: openBuyOrders * tradeValue,
          capitalBudget: fundedLevels * tradeValue
        });
      }

      const finalHoldings = shares * prevPrice;
      const netPLFinal = netCashflowTrades + finalHoldings;
      const finalEquity = cash + finalHoldings;
      const millis = firstEquityTime && lastEquityTime ? (lastEquityTime.getTime() - firstEquityTime.getTime()) : 0;
      const years = millis > 0 ? (millis / (365.25 * 24 * 60 * 60 * 1000)) : 0;
      const maxLevelsUsed = Number.isFinite(summary.maxOpenLevels) ? summary.maxOpenLevels : 0;
      const derivedMaxCapital = (tradeValue > 0 && maxLevelsUsed > 0)
        ? tradeValue * maxLevelsUsed
        : 0;
      const trackedCapital = summary.maxDeployedCapital > 0 ? summary.maxDeployedCapital : (fundedLevels * tradeValue);
      const maxDeployedCapital = Math.max(derivedMaxCapital, trackedCapital);
      const cagrBaseEquity = maxDeployedCapital > 0 ? maxDeployedCapital : initialEquity;
      const cagr = (years > 0 && cagrBaseEquity > 0 && finalEquity > 0)
        ? Math.pow(finalEquity / cagrBaseEquity, 1 / years) - 1
        : 0;
      summary.totalTrades = trades.length;
      summary.netProfit = netPLFinal;
      summary.profitPerLevel = maxLevelsUsed > 0 ? netPLFinal / maxLevelsUsed : 0;
      summary.finalEquity = finalEquity;
      summary.totalRetainedShares = cumulativeRetained;
      summary.cash = cash;
      summary.minCash = minCashBalance;
      summary.minCashBalance = minCashBalance;
      summary.shares = shares;
      summary.lastPrice = prevPrice;
      summary.openLevelsFinal = openPositions;
      summary.maxDrawdown = maxDrawdown;
      summary.maxDrawdownPct = maxDrawdownPct * 100;
      summary.maxSharesHeld = maxSharesHeld;
      summary.cagr = cagr;
      summary.maxDeployedCapital = maxDeployedCapital;
      summary.requiredCapital = requiredCapital;
      summary.netPLFinal = netPLFinal;
      summary.realizedProfit = realizedProfit;
      summary.capitalContributed = capitalContributed;
      summary.netCashflowTrades = netCashflowTrades;
      summary.capitalContributedFinal = capitalContributed;
      summary.netCashflowTradesFinal = netCashflowTrades;
      summary.holdingsValueFinal = finalHoldings;
      summary.accountEquityFinal = finalEquity;
      return finalizeResult();
    }

    function runGridBacktest() {
      if (!Array.isArray(ROWS) || !ROWS.length) {
        setGridStatus('Load symbol data before running the backtest.');
        return;
      }
      const params = getGridParamsFromUI();
      const rowsForRun = filterRowsBySelectedMonths(ROWS);
      if (!rowsForRun.length) {
        setGridStatus('No data available for the selected month filter. Clear the filter or load more data.');
        renderGridSummary(null);
        renderGridTrades([], { resetPage: true });
        renderGridEquityChart(null);
        renderLadderChart([]);
        renderFillsPerDayChart([]);
        renderOpenLevelsChart([]);
        renderFillsPerMonthChart([]);
        renderPriceDistributionChart([]);
        renderLevelDistributionChart([]);
        renderCumulativeLevelDistributionChart([]);
        renderGridLevels([], [], null);
        return;
      }
      const uniqueFilteredDays = new Set(rowsForRun.map(row => row?.dayKey).filter(Boolean));
      const entryFilter = params?.entryFilter || 'none';
      const window = getEntryFilterWindow(entryFilter);
      if (window) {
        const info = describeSmaAvailability(entryFilter);
        const available = info?.availableDays || 0;
        if (available <= 0) {
          const totalDays = info?.totalDays ?? DAYS.length;
          setGridStatus(`Entry filter (${window}-day SMA) needs ${window} completed days. Dataset has ${totalDays.toLocaleString()} day${totalDays === 1 ? '' : 's'} — insufficient for this filter.`);
          renderGridSummary(null);
          renderGridTrades([], { resetPage: true });
          renderGridEquityChart(null);
          renderLadderChart([]);
          renderFillsPerDayChart([]);
          renderOpenLevelsChart([]);
          renderFillsPerMonthChart([]);
          renderPriceDistributionChart([]);
          renderLevelDistributionChart([]);
          renderCumulativeLevelDistributionChart([]);
          renderGridLevels([], [], null);
          return;
        }
        if (uniqueFilteredDays.size < window) {
          setGridStatus(`Entry filter (${window}-day SMA) needs ${window} completed day(s), but the current month filter only leaves ${uniqueFilteredDays.size.toLocaleString()} day${uniqueFilteredDays.size === 1 ? '' : 's'}. Adjust the filter or load additional data.`);
          renderGridSummary(null);
          renderGridTrades([], { resetPage: true });
          renderGridEquityChart(null);
          renderLadderChart([]);
          renderFillsPerDayChart([]);
          renderOpenLevelsChart([]);
          renderFillsPerMonthChart([]);
          renderPriceDistributionChart([]);
          renderLevelDistributionChart([]);
          renderCumulativeLevelDistributionChart([]);
          renderGridLevels([], [], null);
          return;
        }
      }
      setGridStatus('Running backtest…');
      try {
        const result = runBuyTheGridSimulation(rowsForRun, params) || {};
        const safeResult = {
          trades: Array.isArray(result.trades) ? result.trades : [],
          summary: result.summary || null,
          equitySeries: Array.isArray(result.equitySeries) ? result.equitySeries : [],
          ladderHistory: Array.isArray(result.ladderHistory) ? result.ladderHistory : [],
          buyLevels: Array.isArray(result.buyLevels) ? result.buyLevels : [],
          sellLevels: Array.isArray(result.sellLevels) ? result.sellLevels : [],
          baseLevel: Number.isFinite(result.baseLevel) ? result.baseLevel : null,
          gridLevels: Array.isArray(result.gridLevels) ? result.gridLevels : []
        };
        GRID_STATE = safeResult;
        const backtestOutput = {
          generated_at: new Date().toISOString(),
          symbol: currentTicker || null,
          params: params || null,
          meta: collectGridBacktestPayload(),
          results: {
            summary: safeResult.summary || null
          }
        };
        console.log('GRID_BACKTEST_OUTPUT');
        console.log(JSON.stringify(backtestOutput, null, 2));
        renderGridSummary(safeResult.summary);
        renderGridTrades(safeResult.trades, { resetPage: true });
        renderGridEquityChart(safeResult.equitySeries);
        renderLadderChart(safeResult.trades);
        renderFillsPerDayChart(safeResult.trades);
        renderOpenLevelsChart(safeResult.ladderHistory);
        renderFillsPerMonthChart(safeResult.trades);
        renderPriceDistributionChart(safeResult.trades);
        renderLevelDistributionChart(safeResult.trades);
        renderCumulativeLevelDistributionChart(safeResult.trades);
        renderGridLevels(safeResult.buyLevels, safeResult.sellLevels, safeResult.baseLevel ?? null);
        setSaveButtonEnabled(!!safeResult.summary);
        if (safeResult.trades.length) {
          const profitLabel = formatCurrency(safeResult.summary?.netProfit ?? 0);
          setGridStatus(`Backtest completed with ${safeResult.trades.length} trade${safeResult.trades.length === 1 ? '' : 's'}. Net profit ${profitLabel}.`);
        } else {
          setGridStatus('No completed trades for the selected parameters.');
        }
      } catch (err) {
        console.error('Buy the Dip backtest error', err);
        setGridStatus('Failed to run backtest. See console for details.');
        renderLadderChart([]);
        renderFillsPerDayChart([]);
        renderOpenLevelsChart([]);
        renderFillsPerMonthChart([]);
        renderPriceDistributionChart([]);
        renderLevelDistributionChart([]);
        renderCumulativeLevelDistributionChart([]);
        renderGridLevels([], [], null);
      }
    }

    function initGridControls() {
      const btn = document.getElementById('btnRunGridBacktest');
      if (btn) {
        btn.addEventListener('click', () => runGridBacktest());
      }
      const saveBtn = document.getElementById('btnSaveGridBacktest');
      if (saveBtn) {
        saveBtn.addEventListener('click', async () => {
          const payload = collectGridBacktestPayload();
          if (!payload || !payload.symbol) {
            setGridStatus('Run a backtest before saving.');
            return;
          }
          setGridStatus('Saving backtest…');
          setSaveButtonEnabled(false);
          try {
            await requestSaveGridBacktest(payload);
            setGridStatus('Backtest saved.');
          } catch (err) {
            const msg = err && err.message ? err.message : String(err);
            setGridStatus(`Save failed: ${msg}`);
          } finally {
            setSaveButtonEnabled(!!GRID_STATE?.summary);
          }
        });
      }
      const downsampleToggle = document.getElementById('toggleDownsample');
      if (downsampleToggle) {
        downsampleToggle.checked = RESAMPLE_INTERVAL_MINUTES > 1;
        downsampleToggle.addEventListener('change', () => {
          RESAMPLE_INTERVAL_MINUTES = downsampleToggle.checked ? DEFAULT_RESAMPLE_INTERVAL_MINUTES : 1;
          applyResamplingFromBase();
          updateLoadedStatus();
          renderDataSummary();
          if (Array.isArray(ROWS) && ROWS.length) {
            updateLoadedGridStatus('Running backtest…');
            runGridBacktest();
          }
        });
      }
      const adhocInput = document.getElementById('inpAdhocSymbol');
      const adhocButton = document.getElementById('btnAdhocGetData');
      if (adhocInput && adhocButton) {
        adhocInput.addEventListener('input', () => {
          const raw = adhocInput.value || '';
          const next = raw.toUpperCase();
          if (next !== raw) adhocInput.value = next;
        });
        const kick = async () => {
          const symbol = normalizeSymbolInput(adhocInput.value);
          if (!symbol) {
            setStatus('Enter a symbol (e.g., TSLA) to download data.');
            return;
          }
          setStatus(`Requesting data for ${symbol}…`);
          setGridStatus(`Requesting data for ${symbol}…`);
          setAdhocDownloadBusy(true);
          startAdhocStatusPolling(symbol);
          try {
            const result = await requestAdhocDownload(symbol);
            const rows = Number(result?.rows);
            const note = result?.note;
            if (note === 'up-to-date' || rows === 0) {
              setStatus(`Data up to date for ${symbol}. Loading…`);
            } else {
              const rowLabel = Number.isFinite(rows) && rows > 0 ? `${rows.toLocaleString()} rows` : 'data';
              setStatus(`Downloaded ${rowLabel} for ${symbol}. Loading…`);
            }
            setTicker(symbol);
            await loadSymbolData(symbol);
            populateTickerSegment();
            setAdhocWatchlistSymbol(symbol);
          } catch (err) {
            const msg = err && err.message ? err.message : String(err);
            setStatus(`Download failed for ${symbol}: ${msg}`);
            setGridStatus(`Download failed for ${symbol}: ${msg}`);
            setAdhocWatchlistSymbol('');
          } finally {
            stopAdhocStatusPolling();
            setAdhocDownloadBusy(false);
          }
        };
        adhocButton.addEventListener('click', kick);
        adhocInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') kick();
        });
      }
      const addWatchBtn = document.getElementById('watchlistAddAdhocBtn');
      if (addWatchBtn) {
        addWatchBtn.addEventListener('click', () => {
          const symbol = LAST_ADHOC_SYMBOL || normalizeSymbolInput(adhocInput?.value);
          if (!symbol) return;
          addSymbolToActiveWatchlist(symbol);
        });
      }
      const inputs = [
        document.getElementById('selGridSpacing'),
        document.getElementById('selEntryFilter'),
        document.getElementById('selRetentionMode'),
        document.getElementById('inpGridSize'),
        document.getElementById('inpBasePrice'),
        document.getElementById('inpTradeValue'),
        document.getElementById('inpFractionalShares')
      ];
      inputs.forEach(el => {
        if (!el) return;
        const handler = () => {
          if (el.id === 'selGridSpacing') updateGridSizeLabel();
          if (!Array.isArray(ROWS) || !ROWS.length) return;
          runGridBacktest();
        };
        const eventName = el.tagName === 'SELECT' || el.type === 'checkbox' ? 'change' : 'input';
        el.addEventListener(eventName, handler);
      });
      updateGridSizeLabel();
      resetGridOutputs('Load data and run the backtest to populate results.');
      setRunButtonEnabled(false);
      document.querySelectorAll('th[data-sort-key] button').forEach((btn) => {
        btn.addEventListener('click', () => {
          const th = btn.closest('th[data-sort-key]');
          if (!th) return;
          const key = th.getAttribute('data-sort-key');
          if (!key) return;
          if (TRADE_SORT_STATE.key === key) {
            TRADE_SORT_STATE.dir = TRADE_SORT_STATE.dir === 'asc' ? 'desc' : 'asc';
          } else {
            TRADE_SORT_STATE.key = key;
            TRADE_SORT_STATE.dir = 'asc';
          }
          renderGridTrades(GRID_STATE.trades || []);
        });
      });
      updateTradeSortIndicators();
    }

    function initTradeTableControls() {
      const sizeSelect = document.getElementById('tradePageSize');
      if (sizeSelect) {
        sizeSelect.value = String(TRADE_TABLE_STATE.pageSize);
        sizeSelect.addEventListener('change', () => {
          const val = Number(sizeSelect.value);
          if (!Number.isFinite(val)) return;
          TRADE_TABLE_STATE.pageSize = Math.max(25, Math.min(1000, Math.round(val) || 250));
          TRADE_TABLE_STATE.page = 1;
          renderGridTrades(GRID_STATE.trades || []);
        });
      }
      const prev = document.getElementById('tradePagePrev');
      if (prev) {
        prev.addEventListener('click', () => {
          if (TRADE_TABLE_STATE.page <= 1) return;
          TRADE_TABLE_STATE.page -= 1;
          renderGridTrades(GRID_STATE.trades || []);
        });
      }
      const next = document.getElementById('tradePageNext');
      if (next) {
        next.addEventListener('click', () => {
          const trades = GRID_STATE.trades || [];
          const filtered = applyMonthFilter(trades);
          const { totalPages } = clampTradePage(filtered.length);
          if (TRADE_TABLE_STATE.page >= totalPages) return;
          TRADE_TABLE_STATE.page += 1;
          renderGridTrades(trades);
        });
      }
      updateTradePaginationControls(0);
    }


    async function loadSymbolData(sym) {
      const baseSymbol = (sym || '').trim();
      if (!baseSymbol) return false;
      setStatus(`Loading data for ${baseSymbol}…`);
      setGridStatus(`Loading data for ${baseSymbol}…`);
      setRunButtonEnabled(false);
      const candidates = Array.from(new Set([
        baseSymbol,
        baseSymbol.toUpperCase(),
        baseSymbol.toLowerCase()
      ])).filter(Boolean);
      let lastError = null;
      for (const candidate of candidates) {
        const path = `data/${candidate}_1m.csv`;
        try {
          const res = await fetch(path, { cache: 'no-cache' });
          if (!res.ok) {
            lastError = `HTTP ${res.status} loading ${path}`;
            continue;
          }
          const text = await res.text();
          const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
          if (parsed.errors && parsed.errors.length) {
            console.warn('CSV parse warnings:', parsed.errors.slice(0, 3));
          }
          normalizeAndIndex(parsed.data);
          if (!ROWS.length) {
            lastError = 'No valid rows in dataset.';
            continue;
          }
          updateSymbolPrecisionFromRows(baseSymbol, parsed.data);
          updateSymbolBasePriceFromRows(baseSymbol);
          updateLoadedStatus();
          renderGridSummary(null);
          renderGridTrades([], { resetPage: true });
          renderGridEquityChart(null);
          renderLadderChart([]);
          renderFillsPerDayChart([]);
          renderOpenLevelsChart([]);
          renderFillsPerMonthChart([]);
          renderPriceDistributionChart([]);
          renderLevelDistributionChart([]);
          renderCumulativeLevelDistributionChart([]);
          renderDataSummary();
          updateLoadedGridStatus('Running backtest…');
          setRunButtonEnabled(true);
          runGridBacktest();
          return true;
        } catch (err) {
          lastError = err && err.message ? err.message : String(err);
        }
      }
      console.error(`Failed to load ${baseSymbol}: ${lastError || 'not found'}`);
      setStatus(`Error loading ${baseSymbol}: ${lastError || 'File not found.'}`);
      setGridStatus(`Error loading ${baseSymbol}: ${lastError || 'File not found.'}`);
      BASE_ROWS = [];
      ROWS = [];
      DAY_GROUPS = new Map();
      DAYS = [];
      renderGridSummary(null);
      renderGridTrades([], { resetPage: true });
      renderGridEquityChart(null);
      renderLadderChart([]);
      renderFillsPerDayChart([]);
      renderOpenLevelsChart([]);
      renderFillsPerMonthChart([]);
      renderPriceDistributionChart([]);
      renderLevelDistributionChart([]);
      renderCumulativeLevelDistributionChart([]);
      renderGridLevels([], [], null);
      buildMonthFilterOptions();
      setRunButtonEnabled(false);
      renderDataSummary();
      return false;
    }

    function normalizeSymbolEntries(entries) {
      const map = new Map();
      const ordered = [];
      if (!Array.isArray(entries)) return { list: ordered, map };
      for (const entry of entries) {
        let symbol = '';
        let name = '';
        let multiplier = null;
        let basePrice = null;
        let tickSize = null;
        let exchange = null;
        if (typeof entry === 'string') {
          symbol = entry;
          name = entry;
        } else if (entry && typeof entry === 'object') {
          symbol = entry.symbol;
          name = entry.name || entry.symbol || '';
          multiplier = entry.multiplier;
          basePrice = entry.base_price ?? entry.basePrice;
          tickSize = entry.tick_size ?? entry.tickSize;
          exchange = entry.exchange ?? entry.exchange_code ?? entry.exchangeCode;
        } else {
          continue;
        }
        symbol = (symbol || '').toUpperCase().trim();
        if (!symbol || map.has(symbol)) continue;
        const existing = SYMBOL_META.get(symbol) || null;
        const parsedMultiplier = Number(multiplier);
        const finalMultiplier = Number.isFinite(parsedMultiplier) && parsedMultiplier > 0
          ? parsedMultiplier
          : (existing && Number.isFinite(existing.multiplier) ? existing.multiplier : 1);
        const parsedBase = Number(basePrice);
        const finalBasePrice = Number.isFinite(parsedBase) && parsedBase > 0
          ? parsedBase
          : (existing && Number.isFinite(existing.basePrice) ? existing.basePrice : 100);
        const parsedTick = Number(tickSize);
        const finalTickSize = Number.isFinite(parsedTick) && parsedTick > 0
          ? parsedTick
          : (existing && Number.isFinite(existing.tickSize) ? existing.tickSize : 0.01);
        const parsedExchange = normalizeExchange(exchange);
        const finalExchange = parsedExchange
          || (existing && normalizeExchange(existing.exchange))
          || DEFAULT_EXCHANGE;
        const providedPrecision = entry && typeof entry === 'object' && Number.isInteger(entry.precision) && entry.precision >= 0
          ? Math.min(entry.precision, 8)
          : null;
        const meta = {
          symbol,
          name: (typeof name === 'string' && name.trim()) ? name.trim() : (existing && existing.name ? existing.name : symbol),
          sector: (typeof entry?.sector === 'string' && entry.sector.trim())
            ? entry.sector.trim()
            : (existing && typeof existing.sector === 'string' ? existing.sector : ''),
          exchange: finalExchange,
          multiplier: finalMultiplier,
          basePrice: finalBasePrice,
          tickSize: finalTickSize,
          precision: providedPrecision != null
            ? providedPrecision
            : (existing && Number.isInteger(existing.precision) ? existing.precision : null)
        };
        map.set(symbol, meta);
        ordered.push(meta);
      }
      return { list: ordered, map };
    }

    function normalizeWatchlistState(payload) {
      const raw = payload && typeof payload === 'object' ? payload : {};
      const rawLists = raw.watchlists && typeof raw.watchlists === 'object' ? raw.watchlists : {};
      const rawMeta = raw.symbol_meta || raw.symbolMeta;
      const watchlists = {};
      for (const [name, symbols] of Object.entries(rawLists)) {
        const key = String(name || '').trim();
        if (!key) continue;
        const list = Array.isArray(symbols) ? symbols : [];
        const seen = new Set();
        const cleaned = [];
        for (const entry of list) {
          if (typeof entry !== 'string') continue;
          const sym = entry.trim().toUpperCase();
          if (!sym || seen.has(sym)) continue;
          seen.add(sym);
          cleaned.push(sym);
        }
        watchlists[key] = cleaned;
      }
      if (!Object.keys(watchlists).length) {
        watchlists.Default = [];
      }
      const symbolMeta = {};
      if (rawMeta && typeof rawMeta === 'object') {
        Object.entries(rawMeta).forEach(([sym, meta]) => {
          const key = String(sym || '').trim().toUpperCase();
          if (!key || !meta || typeof meta !== 'object') return;
          const name = typeof meta.name === 'string' ? meta.name.trim() : '';
          const sector = typeof meta.sector === 'string' ? meta.sector.trim() : '';
          const exchange = normalizeExchange(meta.exchange);
          symbolMeta[key] = {
            name: name || key,
            sector: sector || '',
            exchange: exchange || DEFAULT_EXCHANGE
          };
        });
      }
      let active = typeof raw.active === 'string' ? raw.active : WATCHLIST_ALL;
      if (active !== WATCHLIST_ALL && !watchlists[active]) {
        active = Object.keys(watchlists)[0];
      }
      return { active, watchlists, symbol_meta: symbolMeta };
    }

    function getActiveWatchlistName() {
      return WATCHLIST_STATE.active || WATCHLIST_ALL;
    }

    function getActiveWatchlistSymbols() {
      const active = getActiveWatchlistName();
      if (active === WATCHLIST_ALL) return null;
      const list = WATCHLIST_STATE.watchlists[active] || [];
      return new Set(list);
    }

    async function getSymbolsForBatchBacktest() {
      let symbols = [];
      const active = getActiveWatchlistName();
      if (active !== WATCHLIST_ALL) {
        symbols = Array.isArray(WATCHLIST_STATE.watchlists[active])
          ? WATCHLIST_STATE.watchlists[active].slice()
          : [];
      } else {
        if (!Array.isArray(SYMBOL_LIST_CACHE) || !SYMBOL_LIST_CACHE.length) {
          await populateTickerSegment();
        }
        if (Array.isArray(SYMBOL_LIST_CACHE) && SYMBOL_LIST_CACHE.length) {
          const normalized = normalizeSymbolEntries(SYMBOL_LIST_CACHE);
          symbols = Array.isArray(normalized.list)
            ? normalized.list.map((meta) => meta.symbol)
            : [];
        }
      }
      const seen = new Set();
      const cleaned = [];
      symbols.forEach((symbol) => {
        const sym = normalizeSymbolInput(symbol);
        if (!sym || seen.has(sym)) return;
        seen.add(sym);
        cleaned.push(sym);
      });
      return cleaned;
    }

    function getBatchSortValue(entry, key) {
      const summary = entry && entry.summary ? entry.summary : {};
      switch (key) {
        case 'symbol':
          return String(entry?.symbol || '');
        case 'trades':
          return Number(summary?.totalTrades);
        case 'netProfit':
          return Number(summary?.netProfit);
        case 'finalEquity':
          return Number(summary?.finalEquity);
        case 'cash':
          return Number(summary?.cash);
        case 'shares':
          return Number(summary?.shares);
        case 'maxDrawdownPct':
          return Number(summary?.maxDrawdownPct);
        case 'cagr':
          return Number(summary?.cagr);
        case 'maxLevels':
          return Number(summary?.maxOpenLevels);
        case 'profitPerLevel':
          return Number(summary?.profitPerLevel);
        case 'calmSells':
          return Number(entry?.sellFillStats?.median);
        case 'normalSells':
          return Number(entry?.sellFillStats?.trimmedMean);
        case 'volatileSells':
          return Number(entry?.sellFillStats?.pct95);
        default:
          return '';
      }
    }

    function sortBatchResults(results) {
      const list = Array.isArray(results) ? results.slice() : [];
      if (list.length <= 1) return list;
      const { key, dir } = BACKTEST_ALL_SORT;
      const direction = dir === 'desc' ? -1 : 1;
      const numericKeys = new Set([
        'trades',
        'netProfit',
        'finalEquity',
        'cash',
        'shares',
        'maxDrawdownPct',
        'cagr',
        'maxLevels',
        'profitPerLevel',
        'calmSells',
        'normalSells',
        'volatileSells'
      ]);
      return list.sort((a, b) => {
        const va = getBatchSortValue(a, key);
        const vb = getBatchSortValue(b, key);
        if (numericKeys.has(key)) {
          const aNum = Number.isFinite(va) ? va : NaN;
          const bNum = Number.isFinite(vb) ? vb : NaN;
          const aMissing = !Number.isFinite(aNum);
          const bMissing = !Number.isFinite(bNum);
          if (aMissing && bMissing) return 0;
          if (aMissing) return 1;
          if (bMissing) return -1;
          if (aNum === bNum) return 0;
          return aNum > bNum ? direction : -direction;
        }
        const aStr = String(va || '');
        const bStr = String(vb || '');
        const comp = aStr.localeCompare(bStr, undefined, { numeric: true, sensitivity: 'base' });
        return comp * direction;
      });
    }

    function updateBatchSortIndicators() {
      const headers = document.querySelectorAll('#batchResultsSection th[data-batch-sort]');
      headers.forEach((th) => {
        const key = th.getAttribute('data-batch-sort');
        if (!key) return;
        if (key === BACKTEST_ALL_SORT.key) {
          th.setAttribute('data-sort', BACKTEST_ALL_SORT.dir);
        } else {
          th.setAttribute('data-sort', 'none');
        }
      });
    }

    function renderBatchResults() {
      const section = document.getElementById('batchResultsSection');
      const body = document.getElementById('batchResultsBody');
      const empty = document.getElementById('batchResultsEmpty');
      if (section) {
        const shouldShow = BACKTEST_ALL_RUNNING || BACKTEST_ALL_RESULTS.length > 0;
        section.classList.toggle('hidden', !shouldShow);
      }
      if (!body) return;
      body.innerHTML = '';
      if (!BACKTEST_ALL_RESULTS.length) {
        if (empty) empty.classList.remove('hidden');
        return;
      }
      if (empty) empty.classList.add('hidden');
      const formatCurrencyOrDash = (value) => (Number.isFinite(value) ? formatCurrency(value) : '—');
      const formatNumberOrDash = (value, digits = 2) => (Number.isFinite(value) ? formatNumber(value, digits) : '—');
      const formatPercentOrDash = (value) => (Number.isFinite(value) ? formatPercent(value) : '—');
      const sorted = sortBatchResults(BACKTEST_ALL_RESULTS);
      updateBatchSortIndicators();
      sorted.forEach((entry) => {
        const summary = entry.summary || {};
        const trades = Number.isFinite(summary?.totalTrades) ? summary.totalTrades.toLocaleString() : '—';
        const netProfit = formatCurrencyOrDash(summary?.netProfit);
        const finalEquity = formatCurrencyOrDash(summary?.finalEquity);
        const cash = formatCurrencyOrDash(summary?.cash);
        const shares = formatNumberOrDash(summary?.shares, 4);
        const maxDdPct = formatPercentOrDash(summary?.maxDrawdownPct);
        const cagrPct = Number.isFinite(summary?.cagr) ? summary.cagr * 100 : NaN;
        const cagr = formatPercentOrDash(cagrPct);
        const maxLevels = formatNumberOrDash(summary?.maxOpenLevels, 0);
        const profitPerLevel = formatCurrencyOrDash(summary?.profitPerLevel);
        const calmSells = formatNumberOrDash(entry?.sellFillStats?.median, 2);
        const normalSells = formatNumberOrDash(entry?.sellFillStats?.trimmedMean, 2);
        const volatileSells = formatNumberOrDash(entry?.sellFillStats?.pct95, 2);
        const row = document.createElement('tr');
        const isSelected = entry.symbol && entry.symbol === BACKTEST_ALL_SELECTED;
        row.className = `table-row cursor-pointer transition${isSelected ? ' table-row-selected' : ''}`;
        row.setAttribute('data-batch-symbol', entry.symbol || '');
        row.innerHTML = `
          <td class="px-3 py-2 font-semibold text-slate-700">${entry.symbol || '—'}</td>
          <td class="px-3 py-2 text-right text-slate-700">${trades}</td>
          <td class="px-3 py-2 text-right text-slate-700">${netProfit}</td>
          <td class="px-3 py-2 text-right text-slate-700">${finalEquity}</td>
          <td class="px-3 py-2 text-right text-slate-700">${cash}</td>
          <td class="px-3 py-2 text-right text-slate-700">${shares}</td>
          <td class="px-3 py-2 text-right text-slate-700">${maxDdPct}</td>
          <td class="px-3 py-2 text-right text-slate-700">${cagr}</td>
          <td class="px-3 py-2 text-right text-slate-700">${maxLevels}</td>
          <td class="px-3 py-2 text-right text-slate-700">${profitPerLevel}</td>
          <td class="px-3 py-2 text-right text-slate-700">${calmSells}</td>
          <td class="px-3 py-2 text-right text-slate-700">${normalSells}</td>
          <td class="px-3 py-2 text-right text-slate-700">${volatileSells}</td>
        `;
        body.appendChild(row);
      });
      window.BACKTEST_ALL_RESULTS = BACKTEST_ALL_RESULTS;
    }

    async function runBatchBacktest() {
      if (BACKTEST_ALL_RUNNING) return;
      const btn = document.getElementById('watchlistBacktestAllBtn');
      BACKTEST_ALL_RUNNING = true;
      if (btn) btn.disabled = true;
      BACKTEST_ALL_RESULTS = [];
      BACKTEST_ALL_SELECTED = '';
      BACKTEST_ALL_SORT = { key: 'symbol', dir: 'asc' };
      renderBatchResults();
      setBatchResultsStatus('');
      const symbols = await getSymbolsForBatchBacktest();
      if (!symbols.length) {
        setBatchResultsStatus('No symbols available in the active watchlist.');
        BACKTEST_ALL_RUNNING = false;
        if (btn) btn.disabled = false;
        renderBatchResults();
        return;
      }
      for (let i = 0; i < symbols.length; i += 1) {
        const symbol = symbols[i];
        setBatchResultsStatus(`Backtesting ${symbol} (${i + 1}/${symbols.length})…`);
        setTicker(symbol);
        const loaded = await loadSymbolData(symbol);
        if (!loaded || !GRID_STATE?.summary) {
        BACKTEST_ALL_RESULTS.push({
          symbol,
          status: 'error',
          error: loaded ? 'No summary generated' : 'Data load failed',
          summary: null,
          sellFillStats: null,
          params: getGridParamsFromUI(),
          meta: null,
          generatedAt: new Date().toISOString()
        });
          renderBatchResults();
          continue;
        }
        const fillEntries = computeDailyFillEntries(GRID_STATE.trades).entries;
        const sellFillStats = computeSellFillStats(fillEntries);
        BACKTEST_ALL_RESULTS.push({
          symbol,
          status: 'ok',
          summary: GRID_STATE.summary,
          sellFillStats,
          params: getGridParamsFromUI(),
          meta: collectGridBacktestPayload(),
          generatedAt: new Date().toISOString()
        });
        renderBatchResults();
      }
      setBatchResultsStatus(`Completed ${BACKTEST_ALL_RESULTS.length} / ${symbols.length} symbols.`);
      BACKTEST_ALL_RUNNING = false;
      if (btn) btn.disabled = false;
      renderBatchResults();
    }

    function updateWatchlistControls() {
      const select = document.getElementById('watchlistSelect');
      const delBtn = document.getElementById('watchlistDeleteBtn');
      if (!select) return;
      select.innerHTML = '';
      const allOpt = document.createElement('option');
      allOpt.value = WATCHLIST_ALL;
      allOpt.textContent = 'All symbols';
      select.appendChild(allOpt);
      const names = Object.keys(WATCHLIST_STATE.watchlists || {}).sort((a, b) => a.localeCompare(b));
      names.forEach((name) => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        select.appendChild(opt);
      });
      const active = getActiveWatchlistName();
      select.value = active;
      if (delBtn) {
        const canDelete = active !== WATCHLIST_ALL && active !== 'Default' && !!WATCHLIST_STATE.watchlists[active];
        delBtn.disabled = !canDelete;
      }
    }

    async function loadWatchlists() {
      try {
        const res = await fetch('/api/watchlists', { cache: 'no-cache' });
        if (res.ok) {
          const data = await res.json();
          WATCHLIST_STATE = normalizeWatchlistState(data);
          const active = getActiveWatchlistName();
          if (active !== WATCHLIST_ALL) LAST_ACTIVE_WATCHLIST = active;
          updateWatchlistControls();
          return;
        }
      } catch (err) {
        console.warn('Failed to load watchlists', err);
      }
      WATCHLIST_STATE = normalizeWatchlistState(WATCHLIST_DEFAULTS);
      updateWatchlistControls();
    }

    async function saveWatchlists() {
      const activeToSave = WATCHLIST_STATE.active === WATCHLIST_ALL
        ? LAST_ACTIVE_WATCHLIST
        : WATCHLIST_STATE.active;
      const payload = {
        active: activeToSave,
        watchlists: WATCHLIST_STATE.watchlists,
        symbol_meta: WATCHLIST_STATE.symbol_meta || {}
      };
      try {
        const res = await fetch('/api/watchlists', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!res.ok && (res.status === 501 || res.status === 405)) {
          await fetch('/api/watchlists', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
        }
      } catch (err) {
        console.warn('Failed to save watchlists', err);
      }
    }

    function setActiveWatchlist(name) {
      WATCHLIST_STATE.active = name;
      if (name !== WATCHLIST_ALL) {
        LAST_ACTIVE_WATCHLIST = name;
      }
      updateWatchlistControls();
      if (Array.isArray(SYMBOL_LIST_CACHE)) {
        renderTickerSegment(SYMBOL_LIST_CACHE);
      } else {
        populateTickerSegment();
      }
      saveWatchlists();
    }

    function toggleSymbolInActiveWatchlist(symbol) {
      const active = getActiveWatchlistName();
      if (active === WATCHLIST_ALL) return;
      const key = (symbol || '').toUpperCase().trim();
      if (!key) return;
      const list = Array.isArray(WATCHLIST_STATE.watchlists[active])
        ? WATCHLIST_STATE.watchlists[active].slice()
        : [];
      const idx = list.indexOf(key);
      if (idx >= 0) {
        list.splice(idx, 1);
      } else {
        list.push(key);
      }
      WATCHLIST_STATE.watchlists[active] = list;
      saveWatchlists();
      if (Array.isArray(SYMBOL_LIST_CACHE)) {
        renderTickerSegment(SYMBOL_LIST_CACHE);
      }
    }

    function addSymbolToActiveWatchlist(symbol) {
      const key = (symbol || '').toUpperCase().trim();
      if (!key) return;
      let target = getActiveWatchlistName();
      if (target === WATCHLIST_ALL || !target) {
        target = LAST_ACTIVE_WATCHLIST || 'Default';
      }
      if (!WATCHLIST_STATE.watchlists[target]) {
        WATCHLIST_STATE.watchlists[target] = [];
      }
      if (!WATCHLIST_STATE.watchlists[target].includes(key)) {
        WATCHLIST_STATE.watchlists[target] = [...WATCHLIST_STATE.watchlists[target], key];
      }
      WATCHLIST_STATE.active = target;
      LAST_ACTIVE_WATCHLIST = target;
      if (Array.isArray(SYMBOL_LIST_CACHE)) {
        const exists = SYMBOL_LIST_CACHE.some((entry) => {
          if (typeof entry === 'string') return entry.toUpperCase() === key;
          return entry && typeof entry === 'object' && String(entry.symbol || '').toUpperCase() === key;
        });
        if (!exists) {
          SYMBOL_LIST_CACHE = [...SYMBOL_LIST_CACHE, { symbol: key, name: key, sector: '' }];
        }
      }
      updateWatchlistControls();
      saveWatchlists();
      if (Array.isArray(SYMBOL_LIST_CACHE)) {
        renderTickerSegment(SYMBOL_LIST_CACHE);
      }
    }

    function renderTickerSegment(entries) {
      const container = document.getElementById('tickerSegment');
      if (!container) return;
      const normalized = normalizeSymbolEntries(entries);
      SYMBOL_META = normalized.map instanceof Map ? normalized.map : new Map();
      let list = Array.isArray(normalized.list) ? normalized.list : [];
      const activeSet = getActiveWatchlistSymbols();
      if (activeSet) {
        const existing = new Set(list.map((meta) => meta.symbol));
        activeSet.forEach((symbol) => {
          if (existing.has(symbol)) return;
          const meta = ensureSymbolMetaEntry(symbol);
          if (!meta) return;
          list.push(meta);
          existing.add(symbol);
        });
      }
      if (activeSet) {
        list = list.filter((meta) => activeSet.has(meta.symbol));
      }
      container.innerHTML = '';
      if (!list.length) {
        container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">No symbols available.</span>';
        highlightTickerButton(currentTicker);
        return;
      }
      list.forEach((meta) => {
        const isWatchlistMode = getActiveWatchlistName() !== WATCHLIST_ALL;
        const isInList = isWatchlistMode && (WATCHLIST_STATE.watchlists[getActiveWatchlistName()] || []).includes(meta.symbol);
        const metaOverride = WATCHLIST_STATE.symbol_meta ? WATCHLIST_STATE.symbol_meta[meta.symbol] : null;
        const displayName = (metaOverride && metaOverride.name) || meta.name || meta.symbol;
        const displaySector = (metaOverride && metaOverride.sector) || meta.sector || '';
        const displayTitle = displaySector ? `${displayName} - ${displaySector}` : displayName;
        const toggleHtml = isWatchlistMode
          ? (isInList
            ? `<span class="absolute top-1 right-1 inline-flex items-center justify-center h-4 w-4 rounded-full border border-emerald-200 text-emerald-700 bg-emerald-50 text-[10px] font-bold leading-none" data-watchlist-menu="1" data-symbol="${meta.symbol}" title="Options" aria-label="Options">...</span>
               <div class="absolute top-6 right-1 z-20 hidden min-w-[140px] rounded-lg border border-slate-200 bg-white shadow-soft p-1 text-xs text-slate-700" data-watchlist-menu-panel="${meta.symbol}">
                 <button type="button" class="w-full text-left px-2 py-1 rounded-md hover:bg-slate-100" data-watchlist-action="edit" data-symbol="${meta.symbol}">Edit</button>
                 <button type="button" class="w-full text-left px-2 py-1 rounded-md text-rose-600 hover:bg-rose-50" data-watchlist-action="remove" data-symbol="${meta.symbol}">Remove</button>
               </div>`
            : `<span class="absolute top-1 right-1 inline-flex items-center justify-center text-[10px] uppercase tracking-wide font-semibold px-2 py-0.5 rounded-full border border-slate-200 text-slate-500 bg-white" data-watchlist-toggle="1" data-symbol="${meta.symbol}">Add</span>`)
          : '';
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'w-full h-full px-3 py-2 text-left bg-white hover:bg-emerald-50 transition relative';
        btn.setAttribute('data-symbol', meta.symbol);
        btn.setAttribute('title', displayTitle);
        btn.dataset.multiplier = String(meta.multiplier);
        btn.innerHTML = `
          <div class="flex items-start justify-between gap-2">
            <div class="flex flex-col gap-0.5 leading-tight">
              <span class="text-sm font-semibold">${meta.symbol}</span>
              <span class="text-xs text-slate-500" data-symbol-name>${displayName}</span>
              ${displaySector ? `<span class="text-[11px] text-slate-400">${displaySector}</span>` : ''}
            </div>
            ${toggleHtml}
          </div>
        `;
        container.appendChild(btn);
      });
      highlightTickerButton(currentTicker);
      if (!currentTicker && list[0]) {
        setTicker(list[0].symbol);
        loadSymbolData(list[0].symbol);
      }
    }

    async function populateTickerSegment() {
      const container = document.getElementById('tickerSegment');
      if (!container) return;
      if (Array.isArray(SYMBOL_LIST_CACHE) && SYMBOL_LIST_CACHE.length) {
        renderTickerSegment(SYMBOL_LIST_CACHE);
        return;
      }
      container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';
      try {
        const res = await fetch('data/index.json', { cache: 'no-cache' });
        if (res.ok) {
          const list = await res.json();
          if (Array.isArray(list) && list.length) {
            SYMBOL_LIST_CACHE = list;
            renderTickerSegment(list);
            return;
          }
        }
      } catch (err) {
        console.warn('Failed to load index.json', err);
      }
      try {
        const res = await fetch('data/', { cache: 'no-cache' });
        if (res.ok) {
          const text = await res.text();
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let files = [];
          if (ct.includes('text/html')) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            files = Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href')).filter(Boolean);
          } else {
            files = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          }
          const regex = /^([A-Za-z0-9-]+)_1m\.csv$/i;
          const syms = [];
          for (const f of files) {
            const name = (f || '').split('/').pop();
            const m = name.match(regex);
            if (m) syms.push({ symbol: m[1].toUpperCase(), name: m[1].toUpperCase(), multiplier: undefined });
          }
          if (syms.length) {
            SYMBOL_LIST_CACHE = syms;
            renderTickerSegment(syms);
            return;
          }
        }
      } catch (err) {
        console.warn('Failed to enumerate data directory', err);
      }
      SYMBOL_LIST_CACHE = ['TQQQ', 'TSLA', 'PLTR', 'UVXY'];
      renderTickerSegment(SYMBOL_LIST_CACHE);
    }

    function initWatchlistControls() {
      const select = document.getElementById('watchlistSelect');
      if (select) {
        select.addEventListener('change', () => {
          const next = select.value || WATCHLIST_ALL;
          setActiveWatchlist(next);
        });
      }
      const newBtn = document.getElementById('watchlistNewBtn');
      if (newBtn) {
        newBtn.addEventListener('click', () => {
          const name = window.prompt('New watchlist name');
          if (!name) return;
          const trimmed = name.trim();
          if (!trimmed) return;
          if (WATCHLIST_STATE.watchlists[trimmed]) {
            window.alert('That watchlist already exists.');
            return;
          }
          WATCHLIST_STATE.watchlists[trimmed] = [];
          WATCHLIST_STATE.active = trimmed;
          updateWatchlistControls();
          saveWatchlists();
          if (Array.isArray(SYMBOL_LIST_CACHE)) {
            renderTickerSegment(SYMBOL_LIST_CACHE);
          }
        });
      }
      const delBtn = document.getElementById('watchlistDeleteBtn');
      if (delBtn) {
        delBtn.addEventListener('click', () => {
          const active = getActiveWatchlistName();
          if (active === WATCHLIST_ALL || active === 'Default') return;
          const ok = window.confirm(`Delete watchlist \"${active}\"?`);
          if (!ok) return;
          delete WATCHLIST_STATE.watchlists[active];
          const next = Object.keys(WATCHLIST_STATE.watchlists)[0] || WATCHLIST_ALL;
          WATCHLIST_STATE.active = next;
          updateWatchlistControls();
          saveWatchlists();
          if (Array.isArray(SYMBOL_LIST_CACHE)) {
            renderTickerSegment(SYMBOL_LIST_CACHE);
          }
        });
      }
      const batchBtn = document.getElementById('watchlistBacktestAllBtn');
      if (batchBtn) {
        batchBtn.addEventListener('click', () => runBatchBacktest());
      }
    }

    function closeAllWatchlistMenus() {
      document.querySelectorAll('[data-watchlist-menu-panel]').forEach((panel) => {
        panel.classList.add('hidden');
      });
    }

    function toggleWatchlistMenu(symbol) {
      if (!symbol) return;
      const panel = document.querySelector(`[data-watchlist-menu-panel="${symbol}"]`);
      if (!panel) return;
      const isHidden = panel.classList.contains('hidden');
      closeAllWatchlistMenus();
      if (isHidden) panel.classList.remove('hidden');
    }

    function openWatchlistEditDialog(symbol) {
      const sym = (symbol || '').toUpperCase().trim();
      if (!sym) return;
      const dialog = document.getElementById('watchlistEditDialog');
      if (!dialog || typeof dialog.showModal !== 'function') {
        const name = window.prompt('Name', sym) || '';
        const sector = window.prompt('Sector', '') || '';
        const exchange = window.prompt('Exchange', DEFAULT_EXCHANGE) || '';
        saveSymbolMeta(sym, name, sector, exchange);
        return;
      }
      const nameInput = dialog.querySelector('#watchlistEditName');
      const sectorInput = dialog.querySelector('#watchlistEditSector');
      const exchangeInput = dialog.querySelector('#watchlistEditExchange');
      const meta = WATCHLIST_STATE.symbol_meta ? WATCHLIST_STATE.symbol_meta[sym] : null;
      const fallbackMeta = ensureSymbolMetaEntry(sym);
      if (nameInput) nameInput.value = (meta && meta.name) || (fallbackMeta && fallbackMeta.name) || sym;
      if (sectorInput) sectorInput.value = (meta && meta.sector) || (fallbackMeta && fallbackMeta.sector) || '';
      if (exchangeInput) {
        exchangeInput.value = normalizeExchange((meta && meta.exchange) || (fallbackMeta && fallbackMeta.exchange)) || DEFAULT_EXCHANGE;
      }
      dialog.dataset.symbol = sym;
      dialog.showModal();
    }

    function saveSymbolMeta(symbol, name, sector, exchange) {
      const sym = (symbol || '').toUpperCase().trim();
      if (!sym) return;
      const normalizedExchange = normalizeExchange(exchange) || DEFAULT_EXCHANGE;
      if (!WATCHLIST_STATE.symbol_meta) WATCHLIST_STATE.symbol_meta = {};
      WATCHLIST_STATE.symbol_meta[sym] = {
        name: String(name || sym).trim() || sym,
        sector: String(sector || '').trim(),
        exchange: normalizedExchange
      };
      const meta = ensureSymbolMetaEntry(sym);
      if (meta) {
        meta.name = WATCHLIST_STATE.symbol_meta[sym].name;
        meta.sector = WATCHLIST_STATE.symbol_meta[sym].sector;
        meta.exchange = WATCHLIST_STATE.symbol_meta[sym].exchange;
      }
      saveWatchlists();
      if (Array.isArray(SYMBOL_LIST_CACHE)) {
        renderTickerSegment(SYMBOL_LIST_CACHE);
      }
      if (sym === currentTicker) {
        renderTradingViewProfile(currentTicker);
      }
    }

    document.addEventListener('click', (e) => {
      const menuToggle = e.target.closest('[data-watchlist-menu][data-symbol]');
      if (menuToggle) {
        e.preventDefault();
        e.stopPropagation();
        const symbol = menuToggle.getAttribute('data-symbol');
        toggleWatchlistMenu(symbol);
        return;
      }
      const menuAction = e.target.closest('[data-watchlist-action][data-symbol]');
      if (menuAction) {
        e.preventDefault();
        e.stopPropagation();
        const symbol = menuAction.getAttribute('data-symbol');
        const action = menuAction.getAttribute('data-watchlist-action');
        closeAllWatchlistMenus();
        if (action === 'edit') {
          openWatchlistEditDialog(symbol);
        } else if (action === 'remove') {
          toggleSymbolInActiveWatchlist(symbol);
        }
        return;
      }
      const toggle = e.target.closest('[data-watchlist-toggle][data-symbol]');
      if (toggle) {
        e.preventDefault();
        e.stopPropagation();
        const symbol = toggle.getAttribute('data-symbol');
        if (symbol) toggleSymbolInActiveWatchlist(symbol);
        return;
      }
      const btn = e.target.closest('#tickerSegment button[data-symbol]');
      if (!btn) return;
      const symbol = btn.getAttribute('data-symbol');
      if (!symbol) return;
      setTicker(symbol);
      loadSymbolData(symbol);
    });

    document.addEventListener('DOMContentLoaded', () => {
      const themeToggle = document.getElementById('toggleTheme');
      const initialTheme = applyTheme(getPreferredTheme());
      if (themeToggle) {
        themeToggle.checked = initialTheme === THEME_DARK;
        themeToggle.addEventListener('change', () => {
          const next = themeToggle.checked ? THEME_DARK : THEME_LIGHT;
          applyTheme(next);
          try {
            localStorage.setItem(THEME_STORAGE_KEY, next);
          } catch {}
        });
      }
      initGridControls();
      initTradeTableControls();
      initWatchlistControls();
      renderBatchResults();
      const batchSection = document.getElementById('batchResultsSection');
      if (batchSection) {
        batchSection.addEventListener('click', (e) => {
          const btn = e.target.closest('[data-batch-sort]');
          if (!btn) return;
          const key = btn.getAttribute('data-batch-sort');
          if (!key) return;
          if (BACKTEST_ALL_SORT.key === key) {
            BACKTEST_ALL_SORT.dir = BACKTEST_ALL_SORT.dir === 'asc' ? 'desc' : 'asc';
          } else {
            BACKTEST_ALL_SORT.key = key;
            BACKTEST_ALL_SORT.dir = 'asc';
          }
          renderBatchResults();
        });
      }
      const batchBody = document.getElementById('batchResultsBody');
      if (batchBody) {
        batchBody.addEventListener('click', (e) => {
          const row = e.target.closest('tr[data-batch-symbol]');
          if (!row) return;
          if (BACKTEST_ALL_RUNNING) return;
          const symbol = row.getAttribute('data-batch-symbol');
          if (!symbol) return;
          BACKTEST_ALL_SELECTED = symbol;
          renderBatchResults();
          setTicker(symbol);
          loadSymbolData(symbol);
        });
      }
      const profileToggle = document.getElementById('toggleSymbolProfile');
      const profileSection = document.getElementById('symbolProfileSection');
      const gridLevelsSection = document.getElementById('gridLevelsSection');
      if (profileToggle && (profileSection || gridLevelsSection)) {
        const syncProfileVisibility = () => {
          const shouldShow = profileToggle.checked;
          if (profileSection) profileSection.classList.toggle('hidden', !shouldShow);
          if (gridLevelsSection) gridLevelsSection.classList.toggle('hidden', !shouldShow);
        };
        profileToggle.addEventListener('change', syncProfileVisibility);
        syncProfileVisibility();
      }
      loadWatchlists().finally(() => populateTickerSegment());
      document.addEventListener('click', (e) => {
        const target = e.target;
        if (target && (target.closest('[data-watchlist-menu-panel]') || target.closest('[data-watchlist-menu]'))) {
          return;
        }
        closeAllWatchlistMenus();
      });
      const dialog = document.getElementById('watchlistEditDialog');
      if (dialog) {
        dialog.addEventListener('close', () => {
          dialog.dataset.symbol = '';
        });
        const form = dialog.querySelector('form');
        if (form) {
          form.addEventListener('submit', (e) => {
            e.preventDefault();
            const sym = dialog.dataset.symbol || '';
            const nameInput = dialog.querySelector('#watchlistEditName');
            const sectorInput = dialog.querySelector('#watchlistEditSector');
            const exchangeInput = dialog.querySelector('#watchlistEditExchange');
            saveSymbolMeta(
              sym,
              nameInput ? nameInput.value : '',
              sectorInput ? sectorInput.value : '',
              exchangeInput ? exchangeInput.value : ''
            );
            dialog.close();
          });
        }
      }
    });

    window.addEventListener('resize', () => {
      if (gridEquityChartInst) {
        try { gridEquityChartInst.resize(); } catch {}
      }
      if (gridLadderChartInst) {
        try { gridLadderChartInst.resize(); } catch {}
      }
      if (fillsPerDayChartInst) {
        try { fillsPerDayChartInst.resize(); } catch {}
      }
      if (openLevelsChartInst) {
        try { openLevelsChartInst.resize(); } catch {}
      }
      if (fillsPerMonthChartInst) {
        try { fillsPerMonthChartInst.resize(); } catch {}
      }
      if (priceDistributionChartInst) {
        try { priceDistributionChartInst.resize(); } catch {}
      }
      if (levelDistributionChartInst) {
        try { levelDistributionChartInst.resize(); } catch {}
      }
      if (cumulativeLevelDistributionChartInst) {
        try { cumulativeLevelDistributionChartInst.resize(); } catch {}
      }
    });
  })();
</script>
</body>
</html>
