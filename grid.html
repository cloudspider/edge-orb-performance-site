
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grid Backtest</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"
  />
  <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
  <!-- Apache ECharts for interactive charts (mobile pinch-zoom supported) -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    .num-pos { color: #119d6e !important; }
    .num-neg { color: #ff0000 !important; }
    .pnl-strong { font-size: 1.8rem !important; }
    .sticky-th { position: sticky; top: 0; background: white; z-index: 1; }
    .shadow-soft { box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
    thead th { position: sticky; top: 0; background: white; z-index: 1; }
    th.sortable button {
      width: 100%;
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.35rem;
      font: inherit;
      color: inherit;
      background: transparent;
      border: none;
      padding: 0;
      cursor: pointer;
    }
    th.sortable button:focus-visible {
      outline: 2px solid rgba(16, 185, 129, 0.6);
      outline-offset: 2px;
    }
    th.sortable .sort-indicator {
      font-size: 0.65rem;
      opacity: 0.4;
    }
    th[data-sort="asc"] .sort-indicator::after {
      content: "▲";
      opacity: 0.9;
    }
    th[data-sort="desc"] .sort-indicator::after {
      content: "▼";
      opacity: 0.9;
    }
    th[data-sort="none"] .sort-indicator::after {
      content: "↕";
    }

    /* Hide native spin buttons for key numeric inputs */
    #inp_orb_m::-webkit-outer-spin-button,
    #inp_orb_m::-webkit-inner-spin-button,
    #inp_target_R::-webkit-outer-spin-button,
    #inp_target_R::-webkit-inner-spin-button,
    #inp_stop_R::-webkit-outer-spin-button,
    #inp_stop_R::-webkit-inner-spin-button,
    #inp_risk_pct::-webkit-outer-spin-button,
    #inp_risk_pct::-webkit-inner-spin-button,
    #inp_aum0::-webkit-outer-spin-button,
    #inp_aum0::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    #inp_orb_m,
    #inp_target_R,
    #inp_stop_R,
    #inp_risk_pct,
    #inp_aum0 {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Generic: hide spinners for any future number input */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Segment controls responsive layout */
    #tickerSegment {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      grid-auto-rows: 1fr;
      width: 100%;
      gap: 1px;
    }
    #tickerSegment button {
      width: 100%;
      height: 100%;
    }
    #sessionSegment {
      display: flex;
      flex-wrap: wrap;
      max-width: 100%;
      min-width: 0;
      white-space: normal;
    }
    #sessionSegment button {
      flex: 0 0 auto;
    }
    .summary-tile {
      position: relative;
    }
    .summary-tile .summary-tooltip {
      position: absolute;
      left: 50%;
      bottom: calc(100% + 0.5rem);
      transform: translate(-50%, 0) scale(0.98);
      transform-origin: bottom center;
      background: #0f172a;
      color: #f8fafc;
      padding: 0.65rem 0.75rem;
      border-radius: 0.65rem;
      text-align: left;
      font-size: 0.75rem;
      line-height: 1.25;
      width: max(14rem, min(18rem, 70vw));
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 40;
    }
    .summary-tile .summary-tooltip::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: #0f172a transparent transparent transparent;
    }
    .summary-tile:hover .summary-tooltip,
    .summary-tile:focus-within .summary-tooltip {
      opacity: 1;
      transform: translate(-50%, -0.35rem) scale(1);
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Site navigation -->
  <nav class="bg-white border-b border-slate-200 sticky top-0 z-50 shadow-sm">
    <div class="max-w-screen-2xl mx-auto px-6 py-3 flex items-center gap-4">
      <div class="flex items-center gap-6 flex-1 min-w-0">
        <div class="flex items-center gap-2 font-semibold text-slate-800">
          <svg class="h-5 w-5 text-emerald-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" fill="currentColor" aria-hidden="true"><path d="M192 384L88.5 384C63.6 384 48.3 356.9 61.1 335.5L114 247.3C122.7 232.8 138.3 224 155.2 224L250.2 224C326.3 95.1 439.8 88.6 515.7 99.7C528.5 101.6 538.5 111.6 540.3 124.3C551.4 200.2 544.9 313.7 416 389.8L416 484.8C416 501.7 407.2 517.3 392.7 526L304.5 578.9C283.2 591.7 256 576.3 256 551.5L256 448C256 412.7 227.3 384 192 384L191.9 384zM464 224C464 197.5 442.5 176 416 176C389.5 176 368 197.5 368 224C368 250.5 389.5 272 416 272C442.5 272 464 250.5 464 224z"/></svg>
          <span>GRID</span>
        </div>
        <div class="flex items-center gap-2 flex-wrap">
          <a data-nav href="grid.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Grid Backtest</a>
          <a data-nav href="grid_calc.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Grid Calculator</a>
          <a data-nav href="grid_about.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">About</a>
        </div>
      </div>
    </div>
  </nav>
  <script>
    // Activate nav item for current page
    (function(){
      try {
        const file = (location.pathname.split('/').pop() || 'grid.html').toLowerCase();
        document.querySelectorAll('a[data-nav]').forEach(a => {
          const href = (a.getAttribute('href') || '').toLowerCase();
          const active = href === file || (file === '' && href.endsWith('index.html'));
          a.classList.toggle('bg-slate-800', active);
          a.classList.toggle('text-white', active);
          a.classList.toggle('hover:bg-slate-100', !active);
          if (active) a.setAttribute('aria-current','page'); else a.removeAttribute('aria-current');
        });
      } catch {}
    })();
  </script>

  <div class="max-w-screen-2xl mx-auto p-6 space-y-6">
    <header class="mb-2">
      <h1 id="mainTitle" class="text-2xl md:text-3xl font-semibold">Grid Backtest</h1>
      <!-- <p class="text-slate-600 mt-1">Under construction. Hook up buy-the-dip grid datasets and controls here.</p> -->
    </header>

    <section id="symbolPicker" class="bg-white rounded-2xl shadow-soft p-3 md:p-4">
      <div class="overflow-x-auto -mx-3 md:mx-0 px-3 md:px-0">
        <nav class="flex min-w-max border-b border-slate-200 gap-1" role="tablist">
          <button type="button" class="inline-flex items-center gap-2 border-b-2 border-blue-500 px-3 py-2 text-sm font-medium text-slate-900 transition">
            <span class="inline-flex h-8 w-8 items-center justify-center text-emerald-500">
              <ion-icon name="grid-outline" class="text-2xl"></ion-icon>
            </span>
            <span>Buy-the-Dip Grid</span>
          </button>
        </nav>
      </div>

      <div class="flex-1 min-w-0 mt-4">
        <div class="flex flex-wrap items-center gap-2 mb-2">
          <label class="text-sm text-slate-600" for="inpAdhocSymbol">Ad hoc symbol</label>
          <input
            id="inpAdhocSymbol"
            type="text"
            inputmode="text"
            autocomplete="off"
            placeholder="TSLA"
            class="w-28 rounded-lg border border-slate-200 px-3 py-1.5 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-200"
          >
          <button
            type="button"
            id="btnAdhocGetData"
            class="inline-flex items-center gap-2 rounded-lg bg-slate-900 px-3 py-1.5 text-sm font-semibold text-white shadow-sm transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:bg-slate-400"
          >
            <ion-icon name="download-outline" class="text-base"></ion-icon>
            <span>Get Data</span>
          </button>
        </div>
        <div class="flex items-center gap-2 mb-2">
          <div class="flex-1 min-w-0">
            <div id="tickerSegment" class="w-full rounded-xl border border-slate-200 bg-slate-200 p-px overflow-hidden">
              <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
            </div>
          </div>
        </div>
        <div class="flex items-center gap-2 text-xs text-slate-500">
          <label class="inline-flex items-center gap-2 cursor-pointer">
            <input id="toggleDownsample" type="checkbox" class="h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-500" checked>
            <span>Downsample to 10m</span>
          </label>
        </div>
        <div id="status" class="text-xs text-slate-500"></div>
      </div>
    </section>

    <section id="gridParameters" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
        <div>
          <h2 class="font-semibold text-slate-700">Grid Parameters</h2>
          <p class="text-sm text-slate-500">Adjust spacing and sizing, then run the backtest on the loaded symbol.</p>
        </div>
        <div class="flex flex-wrap gap-2">
          <button
            type="button"
            id="btnRunGridBacktest"
            class="inline-flex items-center justify-center gap-2 rounded-xl bg-emerald-600 px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-emerald-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-500 disabled:cursor-not-allowed disabled:bg-slate-300"
            disabled
          >
            <ion-icon name="play-outline" class="text-lg"></ion-icon>
            <span>Run Backtest</span>
          </button>
          <button
            type="button"
            id="btnSaveGridBacktest"
            class="inline-flex items-center justify-center gap-2 rounded-xl border border-slate-300 bg-white px-4 py-2 text-sm font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-400 disabled:cursor-not-allowed disabled:bg-slate-100"
            disabled
          >
            <ion-icon name="save-outline" class="text-lg"></ion-icon>
            <span>Save Backtest</span>
          </button>
        </div>
      </div>

      <div class="grid gap-4 md:grid-cols-8">
        <label class="block">
          <span class="text-sm text-slate-600">Grid Type</span>
          <div class="relative mt-1">
            <select
              id="selGridType"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="pullback" selected>Buy-the-Dip Grid</option>
              <option value="grid_ath_reset">Buy-the-Dip · ATH Reset</option>
              <option value="progressive">Progressive Grid</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Entry Filter</span>
          <div class="relative mt-1">
            <select
              id="selEntryFilter"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="none" selected>None</option>
              <option value="sma10">10 SMA</option>
              <option value="sma20">20 SMA</option>
              <option value="sma50">50 SMA</option>
              <option value="sma100">100 SMA</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Retained Shares</span>
          <div class="relative mt-1" title="Choose how much of a profitable leg to leave on after selling the trade-value portion.">
            <select
              id="selRetentionMode"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="none">None</option>
              <option value="profit" selected>Profit Portion</option>
              <option value="profit_plus_5">Profit + 5%</option>
              <option value="profit_plus_10">Profit + 10%</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Grid Spacing</span>
          <div class="relative mt-1">
            <select
              id="selGridSpacing"
              class="w-full appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-9 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            >
              <option value="fixed">Fixed Price</option>
              <option value="percent_fixed" selected>Percentage · Fixed Anchor</option>
              <option value="percent_ratchet_up">Percentage · Ratcheting Up Anchor</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3 text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
              </svg>
            </span>
          </div>
        </label>
        <label class="block">
          <span id="gridSizeLabel" class="text-sm text-slate-600">Grid Size ($)</span>
          <div class="mt-1 relative">
            <input
              id="inpGridSize"
              type="number"
              step="0.5"
              min="0.5"
              value="5"
              class="w-full border border-slate-200 bg-white text-slate-700 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            />
            <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase grid size" data-num-target="inpGridSize" data-num-step="1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd" /></svg>
              </button>
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease grid size" data-num-target="inpGridSize" data-num-step="-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd" /></svg>
              </button>
            </div>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Base Price ($)</span>
          <div class="mt-1 relative">
            <input
              id="inpBasePrice"
              type="number"
              step="0.01"
              min="0.01"
              value="100"
              data-default="100"
              class="w-full border border-slate-200 bg-white text-slate-700 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
            />
            <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase base price" data-num-target="inpBasePrice" data-num-step="1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd" /></svg>
              </button>
              <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease base price" data-num-target="inpBasePrice" data-num-step="-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd" /></svg>
              </button>
            </div>
          </div>
        </label>
        <label class="block">
          <span class="text-sm text-slate-600">Trade Value ($)</span>
          <input
            id="inpTradeValue"
            type="number"
            step="100"
            min="100"
            value="1000"
            class="mt-1 w-full appearance-none rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60"
          />
        </label>
        <label class="flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-600 shadow-sm transition focus-within:ring-2 focus-within:ring-emerald-500/60">
          <input
            id="inpFractionalShares"
            type="checkbox"
            class="h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-500"
            checked
          />
          <span>Allow fractional shares</span>
        </label>
      </div>
    </section>

    <section id="gridLevelsSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-3 md:flex-row md:items-start md:justify-between">
        <div class="flex flex-col gap-1">
          <h2 class="font-semibold text-slate-700">Grid Levels</h2>
          <p id="gridLevelsSummary" class="text-sm text-slate-500">Run the backtest to list the ladder levels currently seeded for buys and sells.</p>
        </div>
        <button
          type="button"
          id="gridLevelsToggle"
          aria-expanded="false"
          aria-controls="gridLevelsBody"
          class="inline-flex items-center gap-2 self-start rounded-full border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600"
        >
          <span id="gridLevelsToggleLabel">Show Levels</span>
          <svg
            id="gridLevelsChevron"
            xmlns="http://www.w3.org/2000/svg"
            class="h-4 w-4 text-slate-500 transition-transform"
            viewBox="0 0 20 20"
            fill="currentColor"
            aria-hidden="true"
          >
            <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd" />
          </svg>
        </button>
      </div>
      <div id="gridLevelsBody" class="grid gap-4 md:grid-cols-2 hidden">
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm flex flex-col">
          <div class="flex items-center justify-between pb-2 border-b border-slate-100">
            <h3 class="text-sm font-semibold text-slate-600">Buy Levels</h3>
            <span id="gridBuyLevelCount" class="text-xs text-slate-500">0</span>
          </div>
          <div id="gridBuyLevels" class="mt-3 grow overflow-y-auto text-sm text-slate-700 max-h-72">
            <div class="text-slate-500 text-xs">Run the backtest to populate buy levels.</div>
          </div>
        </div>
        <div class="rounded-xl border border-slate-200 p-4 shadow-sm flex flex-col">
          <div class="flex items-center justify-between pb-2 border-b border-slate-100">
            <h3 class="text-sm font-semibold text-slate-600">Sell Levels</h3>
            <span id="gridSellLevelCount" class="text-xs text-slate-500">0</span>
          </div>
          <div id="gridSellLevels" class="mt-3 grow overflow-y-auto text-sm text-slate-700 max-h-72">
            <div class="text-slate-500 text-xs">Run the backtest to populate sell levels.</div>
          </div>
        </div>
      </div>
    </section>

    <section id="gridFiltersSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2">
        <h2 class="font-semibold text-slate-700">Filters</h2>
        <p class="text-sm text-slate-500">Limit the displayed results to specific months.</p>
      </div>
      <div class="relative inline-block" aria-label="Months">
        <button id="sumMonthMultiBtn" type="button" class="inline-flex items-center justify-between gap-2 bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm min-w-[200px]">
          <span id="sumMonthMultiLabel" class="truncate">All months</span>
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
        </button>
        <div id="sumMonthMultiMenu" class="absolute z-30 mt-1 w-64 bg-white border border-slate-200 rounded-xl shadow-soft p-2 hidden">
          <div class="sticky top-0 bg-white z-10 px-2 pb-2 border-b border-slate-200 flex items-center justify-between gap-2">
            <button id="sumMonthSelectAll" type="button" class="text-xs font-medium text-emerald-700 hover:text-emerald-900 hover:underline">Select all</button>
            <button id="sumMonthClearAll" type="button" class="text-xs text-slate-600 hover:text-slate-800 hover:underline">Clear</button>
          </div>
          <div id="sumMonthMultiList" class="max-h-64 overflow-auto text-sm text-slate-700"></div>
        </div>
      </div>
    </section>

    <section id="gridSummarySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
        <div>
          <h2 class="font-semibold text-slate-700">Summary</h2>
          <p id="gridStatus" class="text-sm text-slate-500">Load data and run the backtest to populate results.</p>
        </div>
        <div class="flex flex-wrap items-center gap-x-6 gap-y-2 text-xs text-slate-500">
          <span>Min Cash:</span>
          <span id="summaryMinCash" class="text-sm font-semibold text-slate-800">$0.00</span>
          <span>Cash:</span>
          <span id="summaryCash" class="text-sm font-semibold text-slate-800">$0.00</span>
          <span>Shares:</span>
          <span id="summaryShares" class="text-sm font-semibold text-slate-800">0</span>
        </div>
      </div>
      <dl class="grid gap-4 sm:grid-cols-2 lg:grid-cols-10">
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Completed Trades</dt>
          <dd id="summaryTotalTrades" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
          <span class="summary-tooltip">Count of round-trip trades (buy then matched sell) completed during the test window.</span>
        </div>
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Levels</dt>
          <dd id="summaryMaxLevels" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
          <span class="summary-tooltip">Peak simultaneous open ladder levels (active sells) at any point in the run.</span>
        </div>
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Deployed Capital</dt>
          <dd id="summaryMaxCapital" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
          <span class="summary-tooltip">Peak notional capital requirement = trade value × highest open levels (tracks the largest ladder footprint).</span>
        </div>
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Net Profit</dt>
          <dd id="summaryNetProfit" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
          <span class="summary-tooltip">Realized P&L from completed trades only: sell proceeds minus cost basis of those sells.</span>
        </div>
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Profit per Level</dt>
          <dd id="summaryProfitPerLevel" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
          <span class="summary-tooltip">Realized net profit normalized by ladder size: net profit ÷ peak open levels.</span>
        </div>
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Final Equity</dt>
          <dd id="summaryFinalEquity" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
          <span class="summary-tooltip">Ending mark-to-market equity at the last bar close: cash plus shares valued at the final bar price (not just the last trade price).</span>
        </div>
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">CAGR</dt>
          <dd id="summaryCagr" class="mt-2 text-xl font-semibold text-slate-800">0.00%</dd>
          <span class="summary-tooltip">Compound annual growth rate using required capital (trade value × max open levels) versus final equity over the test span.</span>
        </div>
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Retained Shares</dt>
          <dd id="summaryRetained" class="mt-2 text-xl font-semibold text-slate-800">0</dd>
          <span class="summary-tooltip">Total shares intentionally retained after sells and carried forward (not yet closed).</span>
        </div>
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Drawdown</dt>
          <dd id="summaryMaxDD" class="mt-2 text-xl font-semibold text-slate-800">$0.00</dd>
          <span class="summary-tooltip">Largest peak-to-trough drop in equity (dollars) using bar-end mark-to-market equity.</span>
        </div>
        <div class="summary-tile rounded-xl border border-slate-200 p-4 shadow-sm" tabindex="0">
          <dt class="text-xs font-medium uppercase tracking-wide text-slate-500">Max Drawdown %</dt>
          <dd id="summaryMaxDDPct" class="mt-2 text-xl font-semibold text-slate-800">0.00%</dd>
          <span class="summary-tooltip">Same drawdown as a percentage of the prior equity peak, computed on bar-end mark-to-market equity.</span>
        </div>
      </dl>
    </section>

    <section id="gridEquitySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Equity Curve</h2>
        <span id="equitySummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="gridEquityChart" class="w-full h-72 md:h-96"></div>
        <div id="gridEquityEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to plot equity over time.
        </div>
      </div>
    </section>

    <section id="gridLadderSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Ladder Activity</h2>
        <span id="ladderSummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="gridLadderChart" class="w-full h-72 md:h-80"></div>
        <div id="gridLadderEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to visualize ladder entries and exits.
        </div>
      </div>
    </section>

    <section id="fillsPerMonthSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Fills per Month</h2>
        <span id="fillsMonthSummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="monthlyFillsChart" class="w-full h-72 md:h-80"></div>
        <div id="monthlyFillsEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to tally fills per month.
        </div>
      </div>
    </section>

    <section id="fillsPerDaySection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Fills per Day</h2>
        <span id="fillsDaySummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="dailyFillsChart" class="w-full h-72 md:h-80"></div>
        <div id="dailyFillsEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to tally fills per day.
        </div>
      </div>
    </section>

    <section id="openLevelsSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Open Levels</h2>
        <span id="openLevelsSummaryLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="openLevelsChart" class="w-full h-72 md:h-80"></div>
        <div id="openLevelsEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to view open levels at the end of each day.
        </div>
      </div>
    </section>

    <section id="priceDistributionSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <div class="flex flex-col gap-1">
          <h2 class="font-semibold text-slate-700">Price Fill Distribution</h2>
          <span id="priceDistributionLabel" class="text-sm text-slate-500"></span>
        </div>
        <div id="priceFillToggle" class="inline-flex rounded-full border border-slate-200 bg-slate-100 p-1 text-xs font-semibold text-slate-600">
          <button type="button" data-view="buy" class="px-3 py-1 rounded-full">Buy fills</button>
          <button type="button" data-view="sell" class="px-3 py-1 rounded-full">Sell fills</button>
        </div>
      </div>
      <div class="relative">
        <div id="priceDistributionChart" class="w-full h-72 md:h-80"></div>
        <div id="priceDistributionEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to chart buy fill counts by price.
        </div>
      </div>
    </section>

    <section id="levelDistributionSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Level Fill Distribution</h2>
        <span id="levelDistributionLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="levelDistributionChart" class="w-full h-72 md:h-80"></div>
        <div id="levelDistributionEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to chart sell fills per level.
        </div>
      </div>
    </section>

    <section id="cumulativeLevelDistributionSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Cumulative Level Fill Distribution</h2>
        <span id="cumulativeLevelDistributionLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="relative">
        <div id="cumulativeLevelDistributionChart" class="w-full h-72 md:h-80"></div>
        <div id="cumulativeLevelDistributionEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-slate-500">
          Run the backtest to see how quickly sell fills accumulate by level.
        </div>
      </div>
    </section>

    <section id="gridTradesSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 space-y-4">
      <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <h2 class="font-semibold text-slate-700">Trade Log</h2>
        <span id="tradeCountLabel" class="text-sm text-slate-500"></span>
      </div>
      <div class="overflow-x-auto">
        <table class="min-w-full divide-y divide-slate-200 text-sm">
          <thead class="bg-slate-50 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">
            <tr>
              <th class="px-3 py-2 sortable" data-sort-key="buyTime"><button type="button"><span>Buy Time</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="buyPrice"><button type="button"><span>Buy Price</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="buyQty"><button type="button"><span>Buy Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="openQty"><button type="button"><span>Open Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="openEquity"><button type="button"><span>Open Equity</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="openLevels"><button type="button"><span>Open Levels</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 sortable" data-sort-key="sellTime"><button type="button"><span>Sell Time</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="sellPrice"><button type="button"><span>Sell Price</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="sellQty"><button type="button"><span>Sell Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="closeQty"><button type="button"><span>Close Qty</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="closeEquity"><button type="button"><span>Close Equity</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="qtyRetained"><button type="button"><span>Qty Retained</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="cumQtyRetained"><button type="button"><span>Cum Retained</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="daysHeld"><button type="button"><span>Days Held</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="profit"><button type="button"><span>Profit $</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="cumProfit"><button type="button"><span>Cum Profit $</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="runningPnl"><button type="button"><span>PnL</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="drawdown"><button type="button"><span>Drawdown</span><span class="sort-indicator"></span></button></th>
              <th class="px-3 py-2 text-right sortable" data-sort-key="roiPct"><button type="button"><span>ROI %</span><span class="sort-indicator"></span></button></th>
            </tr>
          </thead>
          <tbody id="gridTradeRows" class="divide-y divide-slate-100"></tbody>
        </table>
        <div id="gridTradesEmpty" class="py-6 text-center text-sm text-slate-500">Run the backtest to see individual trades.</div>
      </div>
      <div class="mt-3 flex flex-col gap-2 text-xs text-slate-500 sm:flex-row sm:items-center sm:justify-between">
        <div id="tradePaginationInfo"></div>
        <div class="flex flex-wrap items-center gap-2">
          <label for="tradePageSize" class="text-[11px] uppercase tracking-wide font-semibold text-slate-500">Rows per page</label>
          <select id="tradePageSize" class="rounded-lg border border-slate-200 bg-white px-2 py-1 text-xs text-slate-700 focus:outline-none focus:ring-2 focus:ring-emerald-500/60">
            <option value="100">100</option>
            <option value="250" selected>250</option>
            <option value="500">500</option>
            <option value="1000">1000</option>
          </select>
          <div class="inline-flex rounded-full border border-slate-200 bg-white shadow-sm">
            <button id="tradePagePrev" type="button" class="px-3 py-1 text-xs font-semibold text-slate-500 hover:text-emerald-600 disabled:opacity-40 disabled:hover:text-slate-400">&larr; Prev</button>
            <span class="h-6 w-px bg-slate-200 self-center"></span>
            <button id="tradePageNext" type="button" class="px-3 py-1 text-xs font-semibold text-slate-500 hover:text-emerald-600 disabled:opacity-40 disabled:hover:text-slate-400">Next &rarr;</button>
          </div>
        </div>
      </div>
    </section>
  </div>
<script>
  (function(){
    const DEFAULT_PRICE_PRECISION = 2;
    const GRID_DEFAULTS = {
      gridSize: 5,
      gridSpacingType: 'percent_fixed',
      tradeValue: 1000,
      fractionalShares: true,
      entryFilter: 'none'
    };
    const CURRENCY_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const NUMBER_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const NUMBER_FORMAT_4 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 4, maximumFractionDigits: 4 });
    const PERCENT_FORMAT = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const DAILY_SMA_WINDOWS = [10, 20, 50, 100];
    const SMA_FILTER_LOOKUP = {
      sma10: 10,
      sma20: 20,
      sma50: 50,
      sma100: 100
    };
    const DEFAULT_RESAMPLE_INTERVAL_MINUTES = 10;
    let RESAMPLE_INTERVAL_MINUTES = DEFAULT_RESAMPLE_INTERVAL_MINUTES;
    const SMA_PROPERTY_BY_WINDOW = {
      10: 'sma10',
      20: 'sma20',
      50: 'sma50',
      100: 'sma100'
    };
    const SMA_PROPERTIES = Object.values(SMA_PROPERTY_BY_WINDOW);
    const PRICE_FORMATTERS = new Map();

    const pad2 = (n) => String(n).padStart(2, '0');
    const dateKeyFromStr = (val) => {
      if (val == null) return null;
      if (typeof val === 'string') {
        const m = val.trim().match(/^(\d{4}-\d{2}-\d{2})/);
        if (m) return m[1];
      }
      const d = new Date(val);
      if (isNaN(d)) return null;
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
    };

    let currentTicker = '';
    let BASE_ROWS = [];
    let ROWS = [];
    let DAY_GROUPS = new Map();
    let DAYS = [];
    let DAY_SMA_MAPS = new Map();
    let SMA_METADATA = new Map();
    let SYMBOL_META = new Map();
    let GRID_STATE = { trades: [], summary: null, equitySeries: [], ladderHistory: [], buyLevels: [], sellLevels: [], baseLevel: null, gridLevels: [] };
    let TRADE_SORT_STATE = { key: 'buyTime', dir: 'asc' };
    let gridEquityChartInst = null;
    let gridLadderChartInst = null;
    let fillsPerDayChartInst = null;
    let fillsPerMonthChartInst = null;
    let openLevelsChartInst = null;
    let priceDistributionChartInst = null;
    let levelDistributionChartInst = null;
    let cumulativeLevelDistributionChartInst = null;
    let AVAILABLE_MONTHS = [];
    let VIEW_MONTHS = new Set();
    let PRICE_DISTRIBUTION_VIEW = 'buy';
    const TRADE_TABLE_STATE = { page: 1, pageSize: 250 };

    function setStatus(msg) {
      const el = document.getElementById('status');
      if (el) el.textContent = msg || '';
    }

    function formatResampleLabel(minutes) {
      const interval = Number(minutes);
      if (!Number.isFinite(interval) || interval <= 1) return '1-minute';
      return `${Math.max(1, Math.floor(interval))}-minute`;
    }

    function updateLoadedStatus() {
      if (!Array.isArray(ROWS) || !ROWS.length) {
        setStatus('');
        return;
      }
      const label = formatResampleLabel(RESAMPLE_INTERVAL_MINUTES);
      setStatus(`Loaded ${ROWS.length.toLocaleString()} ${label} bars across ${DAYS.length.toLocaleString()} day(s).`);
    }

    function updateLoadedGridStatus(suffix) {
      if (!Array.isArray(ROWS) || !ROWS.length) return;
      const label = formatResampleLabel(RESAMPLE_INTERVAL_MINUTES);
      const tail = suffix ? ` ${suffix}` : '';
      setGridStatus(`Loaded ${ROWS.length.toLocaleString()} ${label} bars across ${DAYS.length.toLocaleString()} day(s).${tail}`);
    }

    function setGridStatus(msg) {
      const el = document.getElementById('gridStatus');
      if (el) el.textContent = msg || '';
    }

    function setRunButtonEnabled(enabled) {
      const btn = document.getElementById('btnRunGridBacktest');
      if (!btn) return;
      btn.disabled = !enabled;
      btn.classList.toggle('opacity-70', !enabled);
    }

    function setSaveButtonEnabled(enabled) {
      const btn = document.getElementById('btnSaveGridBacktest');
      if (!btn) return;
      btn.disabled = !enabled;
      btn.classList.toggle('opacity-70', !enabled);
    }

    function updateGridSizeLabel() {
      const label = document.getElementById('gridSizeLabel');
      if (!label) return;
      const spacingType = (document.getElementById('selGridSpacing')?.value || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const percentMode = spacingType.startsWith('percent');
      label.textContent = percentMode ? 'Grid Size (%)' : 'Grid Size ($)';
      const input = document.getElementById('inpGridSize');
      if (input) {
        if (percentMode) {
          input.min = '0.5';
          input.step = '0.5';
        } else {
          input.min = '0.5';
          input.step = '0.5';
        }
      }
    }

    function ensureSymbolMetaEntry(symbol) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return null;
      if (!SYMBOL_META.has(sym)) {
        SYMBOL_META.set(sym, { symbol: sym, name: sym, multiplier: 1, precision: DEFAULT_PRICE_PRECISION, basePrice: 100, tickSize: 0.01 });
      }
      const meta = SYMBOL_META.get(sym);
      if (meta && !meta.symbol) meta.symbol = sym;
      return meta || null;
    }

    function countPriceDecimals(value) {
      if (!Number.isFinite(value)) return 0;
      const str = Number(value).toFixed(8).replace(/0+$/,'').replace(/\.$/,'');
      const idx = str.indexOf('.');
      return idx >= 0 ? (str.length - idx - 1) : 0;
    }

    function inferPricePrecisionFromRows(rows) {
      if (!Array.isArray(rows)) return DEFAULT_PRICE_PRECISION;
      let maxDecimals = 0;
      const limit = Math.min(rows.length, 400);
      for (let i = 0; i < limit; i++) {
        const row = rows[i];
        if (!row) continue;
        const values = [row.open, row.high, row.low, row.close];
        for (const val of values) {
          const decimals = countPriceDecimals(val);
          if (decimals > maxDecimals) {
            maxDecimals = decimals;
            if (maxDecimals >= 6) return 6;
          }
        }
      }
      return Math.min(Math.max(maxDecimals, DEFAULT_PRICE_PRECISION), 8);
    }

    function updateSymbolPrecisionFromRows(symbol, rows) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return;
      const precision = inferPricePrecisionFromRows(rows);
      const meta = ensureSymbolMetaEntry(sym);
      if (meta) {
        meta.precision = precision;
        SYMBOL_META.set(sym, meta);
      }
    }

    function findFirstPriceFromRows(rows) {
      if (!Array.isArray(rows) || !rows.length) return null;
      for (const row of rows) {
        if (!row) continue;
        const candidates = [row.open, row.close, row.high, row.low];
        for (const val of candidates) {
          if (Number.isFinite(val) && val > 0) return Number(val);
        }
      }
      return null;
    }

    function updateSymbolBasePriceFromRows(symbol) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return;
      const rows = Array.isArray(BASE_ROWS) && BASE_ROWS.length ? BASE_ROWS : ROWS;
      if (!Array.isArray(rows) || !rows.length) return;
      let minPrice = Number.POSITIVE_INFINITY;
      let maxPrice = Number.NEGATIVE_INFINITY;
      for (const row of rows) {
        if (!row) continue;
        const low = Number(row.low);
        const high = Number(row.high);
        if (Number.isFinite(low)) minPrice = Math.min(minPrice, low);
        if (Number.isFinite(high)) maxPrice = Math.max(maxPrice, high);
      }
      if (!Number.isFinite(minPrice) || !Number.isFinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) return;
      const meta = ensureSymbolMetaEntry(sym);
      if (!meta) return;
      const currentBase = Number(meta.basePrice);
      const tolerance = 1e-6 * Math.max(1, minPrice, maxPrice);
      const inRange = Number.isFinite(currentBase)
        && currentBase >= (minPrice - tolerance)
        && currentBase <= (maxPrice + tolerance);
      if (inRange) return;
      const firstPrice = findFirstPriceFromRows(rows);
      if (!Number.isFinite(firstPrice) || firstPrice <= 0) return;
      meta.basePrice = firstPrice;
      SYMBOL_META.set(sym, meta);
      updateBasePriceInput(sym);
    }

    function countDecimals(value) {
      if (!Number.isFinite(value)) return 0;
      const s = String(value);
      if (!s.includes('.')) return 0;
      const trimmed = s.replace(/0+$/, '');
      const idx = trimmed.indexOf('.');
      return idx >= 0 ? (trimmed.length - idx - 1) : 0;
    }

    function decimalsFromStep(step) {
      if (!Number.isFinite(step)) return 0;
      const s = String(step);
      const idx = s.indexOf('.');
      return idx === -1 ? 0 : (s.length - idx - 1);
    }

    function snapToTick(value, tick) {
      if (!Number.isFinite(value) || !Number.isFinite(tick) || tick <= 0) return value;
      const snapped = Math.round(value / tick) * tick;
      const d = decimalsFromStep(tick);
      return Number(snapped.toFixed(Math.min(Math.max(d, 0), 8)));
    }

    function formatCurrency(value) {
      if (!Number.isFinite(value)) return '$0.00';
      return `$${CURRENCY_FORMAT.format(value)}`;
    }

    function formatNumber(value, digits = 2) {
      if (!Number.isFinite(value)) return digits === 4 ? '0.0000' : '0.00';
      if (digits === 4) return NUMBER_FORMAT_4.format(value);
      return NUMBER_FORMAT.format(value);
    }

    function getActiveTickSize(symbol) {
      const meta = ensureSymbolMetaEntry(symbol || currentTicker);
      const tickSize = Number(meta?.tickSize);
      return Number.isFinite(tickSize) && tickSize > 0 ? tickSize : 0.01;
    }

    function updateBasePriceInput(symbol) {
      const input = document.getElementById('inpBasePrice');
      if (!input) return;
      const meta = ensureSymbolMetaEntry(symbol || currentTicker);
      const basePrice = Number.isFinite(meta?.basePrice) ? meta.basePrice : 100;
      const tickSize = getActiveTickSize(symbol || currentTicker);
      const digits = countDecimals(tickSize);
      const valueStr = Number.isFinite(basePrice)
        ? (digits > 0 ? basePrice.toFixed(digits) : String(Math.round(basePrice)))
        : '100';
      input.step = String(tickSize);
      input.min = String(tickSize);
      input.value = valueStr;
      input.setAttribute('data-default', valueStr);
    }

    function getActivePricePrecision() {
      const meta = ensureSymbolMetaEntry(currentTicker);
      const precision = meta && Number.isInteger(meta.precision) ? meta.precision : DEFAULT_PRICE_PRECISION;
      return Math.min(Math.max(precision, 0), 8);
    }

    function formatPrice(value, precision) {
      const digits = Number.isInteger(precision) ? Math.min(Math.max(precision, 0), 8) : DEFAULT_PRICE_PRECISION;
      if (!Number.isFinite(value)) {
        return digits ? `0.${'0'.repeat(digits)}` : '0';
      }
      let formatter = PRICE_FORMATTERS.get(digits);
      if (!formatter) {
        formatter = new Intl.NumberFormat(undefined, {
          minimumFractionDigits: digits,
          maximumFractionDigits: digits
        });
        PRICE_FORMATTERS.set(digits, formatter);
      }
      return formatter.format(value);
    }

    function roundToPrecision(value, precision) {
      if (!Number.isFinite(value)) return null;
      const digits = Number.isInteger(precision) ? Math.min(Math.max(precision, 0), 8) : DEFAULT_PRICE_PRECISION;
      if (!digits) return Math.round(value);
      const factor = Math.pow(10, digits);
      return Math.round(value * factor) / factor;
    }

    function formatPercent(value) {
      if (!Number.isFinite(value)) return '0.00%';
      return `${PERCENT_FORMAT.format(value)}%`;
    }

    function formatDateTime(value) {
      if (!(value instanceof Date) || isNaN(value)) return '';
      const year = value.getFullYear();
      const month = pad2(value.getMonth() + 1);
      const day = pad2(value.getDate());
      const hour = pad2(value.getHours());
      const minute = pad2(value.getMinutes());
      return `${year}-${month}-${day} ${hour}:${minute}`;
    }

    // Numeric steppers for grid controls
    (function(){
      function decimals(stepStr){
        if (!stepStr) return 0;
        const s = String(stepStr);
        const idx = s.indexOf('.');
        return idx === -1 ? 0 : (s.length - idx - 1);
      }
      function roundTo(value, step){
        const d = decimals(step);
        return Number(value.toFixed(d));
      }
      function adjustNumberInput(id, deltaUnits){
        const el = document.getElementById(id);
        if (!el) return;
        const stepAttr = parseFloat(el.getAttribute('step') || '1');
        const step = Number.isFinite(stepAttr) && stepAttr > 0 ? stepAttr : 1;
        const minAttr = parseFloat(el.getAttribute('min'));
        const maxAttr = parseFloat(el.getAttribute('max'));
        const defAttr = parseFloat(el.getAttribute('data-default'));
        const curVal = parseFloat(el.value);
        const base = Number.isFinite(curVal) ? curVal : (Number.isFinite(defAttr) ? defAttr : 0);
        const next = base + (Number(deltaUnits) || 0) * step;
        const clamped = Math.min(Number.isFinite(maxAttr) ? maxAttr : Infinity, Math.max(Number.isFinite(minAttr) ? minAttr : -Infinity, next));
        const rounded = roundTo(clamped, step);
        el.value = String(rounded);
        el.dispatchEvent(new Event('change', { bubbles: true }));
        el.dispatchEvent(new Event('input', { bubbles: true }));
      }
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-num-target][data-num-step]');
        if (!btn) return;
        const id = btn.getAttribute('data-num-target');
        const delta = parseFloat(btn.getAttribute('data-num-step')) || 0;
        adjustNumberInput(id, delta);
      });
    })();

    const RETENTION_EXTRA_PCT = {
      none: 0,
      profit: 0,
      profit_plus_5: 0.05,
      profit_plus_10: 0.10
    };

    function computeSellExecution({ baseQty, desiredQty, sharesAvailable, mode, fractional }) {
      const normalizedMode = (mode || 'profit').toLowerCase();
      const safeDesired = Number.isFinite(desiredQty) && desiredQty > 0 ? desiredQty : baseQty;
      let desiredSell = Math.min(baseQty, safeDesired);
      if (!Number.isFinite(desiredSell) || desiredSell < 0) desiredSell = baseQty;
      const baseRetained = Math.max(0, baseQty - desiredSell);
      let targetRetained;
      switch (normalizedMode) {
        case 'none':
          targetRetained = 0;
          break;
        case 'profit':
          targetRetained = baseRetained;
          break;
        case 'profit_plus_5':
        case 'profit_plus_10':
          targetRetained = baseRetained + (RETENTION_EXTRA_PCT[normalizedMode] || 0) * baseQty;
          break;
        default:
          targetRetained = baseRetained;
          break;
      }
      targetRetained = Math.min(baseQty, Math.max(0, targetRetained));
      let targetSell = baseQty - targetRetained;
      let qty = Math.max(0, Math.min(targetSell, baseQty, Number.isFinite(sharesAvailable) ? sharesAvailable : baseQty));
      if (!fractional) {
        qty = Math.floor(qty);
        if (qty <= 0 && baseQty > 0 && (Number.isFinite(sharesAvailable) ? sharesAvailable : baseQty) > 0) {
          qty = Math.min(baseQty, Number.isFinite(sharesAvailable) ? sharesAvailable : baseQty, 1);
        }
      }
      const retained = Math.max(0, baseQty - qty);
      return { qty, retained };
    }

    function buildPercentFixedGridLevels({ basePrice, gridSize, minPrice, maxPrice, tickSize }) {
      const rawPercent = Number(gridSize);
      const stepPercent = rawPercent / 100;
      if (!Number.isFinite(stepPercent) || stepPercent <= 0 || stepPercent >= 1) {
        return { ladder: [], pairs: [], baseIndex: -1 };
      }
      const resolvedTickSize = Number.isFinite(tickSize) && tickSize > 0 ? tickSize : 0.01;
      const rawBase = Number(basePrice);
      const base = snapToTick(rawBase, resolvedTickSize);
      if (!Number.isFinite(base) || base <= 0) {
        return { ladder: [], pairs: [], baseIndex: -1 };
      }
      const minBound = Number.isFinite(minPrice) && minPrice > 0 ? minPrice : base;
      const maxBound = Number.isFinite(maxPrice) && maxPrice > 0 ? maxPrice : base;
      const tolerance = 1e-9 * Math.max(1, minBound, maxBound, base);
      const divisor = 1 - stepPercent;
      if (divisor <= 0) return { ladder: [], pairs: [], baseIndex: -1 };
      const down = [];
      let priceAccumulator = base;
      let safety = 0;
      while (safety < 5000) {
        priceAccumulator = priceAccumulator * divisor;
        const price = snapToTick(priceAccumulator, resolvedTickSize);
        if (!Number.isFinite(price) || price <= 0) break;
        if (price < minBound - tolerance) break;
        if (!down.length || Math.abs(price - down[down.length - 1]) > tolerance) {
          down.push(price);
        }
        safety += 1;
      }
      const up = [];
      priceAccumulator = base;
      safety = 0;
      while (safety < 5000) {
        priceAccumulator = priceAccumulator / divisor;
        const price = snapToTick(priceAccumulator, resolvedTickSize);
        if (!Number.isFinite(price) || price <= 0) break;
        if (price > maxBound + tolerance) break;
        if (!up.length || Math.abs(price - up[up.length - 1]) > tolerance) {
          up.push(price);
        }
        safety += 1;
      }
      const ladder = [...down.reverse(), base, ...up];
      const baseIndex = down.length;
      const pairs = [];
      for (let i = 0; i < ladder.length - 1; i++) {
        pairs.push({
          level: i - baseIndex,
          buyPrice: ladder[i],
          sellPrice: ladder[i + 1]
        });
      }
      return { ladder, pairs, baseIndex };
    }

    function createGridSpacingHelpers({ spacingType, gridSize, basePrice, firstPrice, minPrice, maxPrice, tickSize }) {
      const typeRaw = (spacingType || 'fixed').toLowerCase();
      const isPercentType = typeRaw === 'percent' || typeRaw === 'percent_fixed' || typeRaw === 'percent_ratchet_up';
      if (isPercentType) {
        const rawPercent = Number(gridSize);
        const percent = rawPercent / 100;
        if (!Number.isFinite(percent) || percent <= 0 || percent >= 1) {
          return { error: 'invalid_percent' };
        }
        const rawBase = Number(basePrice);
        const anchorBase = Number.isFinite(rawBase) && rawBase > 0 ? rawBase : null;
        let anchor = Math.max(anchorBase != null ? anchorBase : Number(firstPrice) || 0, 1e-9);
        if (typeRaw === 'percent_fixed') {
          const levels = buildPercentFixedGridLevels({
            basePrice: anchor,
            gridSize: rawPercent,
            minPrice,
            maxPrice,
            tickSize
          });
          if (Number.isInteger(levels.baseIndex) && levels.baseIndex >= 0 && Array.isArray(levels.ladder)) {
            const snappedBase = levels.ladder[levels.baseIndex];
            if (Number.isFinite(snappedBase)) {
              anchor = snappedBase;
            }
          }
          if (Array.isArray(levels.pairs)) {
            console.log('Percent fixed grid levels:', levels.pairs);
          }
          const ladder = Array.isArray(levels.ladder) ? levels.ladder : [];
          const priceTolerance = 1e-6;
          const findFloorIndex = (value) => {
            if (!Number.isFinite(value) || !ladder.length) return -1;
            let lo = 0;
            let hi = ladder.length - 1;
            if (value <= ladder[0]) return 0;
            if (value >= ladder[hi]) return hi;
            while (lo <= hi) {
              const mid = Math.floor((lo + hi) / 2);
              const level = ladder[mid];
              if (Math.abs(level - value) <= priceTolerance) return mid;
              if (level < value) {
                lo = mid + 1;
              } else {
                hi = mid - 1;
              }
            }
            return Math.max(0, Math.min(ladder.length - 1, hi));
          };
          const findCeilIndex = (value) => {
            if (!Number.isFinite(value) || !ladder.length) return -1;
            let lo = 0;
            let hi = ladder.length - 1;
            if (value <= ladder[0]) return 0;
            if (value >= ladder[hi]) return hi;
            while (lo <= hi) {
              const mid = Math.floor((lo + hi) / 2);
              const level = ladder[mid];
              if (Math.abs(level - value) <= priceTolerance) return mid;
              if (level < value) {
                lo = mid + 1;
              } else {
                hi = mid - 1;
              }
            }
            return Math.max(0, Math.min(ladder.length - 1, lo));
          };
          const findNearestIndex = (value) => {
            const floorIdx = findFloorIndex(value);
            const ceilIdx = findCeilIndex(value);
            if (floorIdx < 0) return ceilIdx;
            if (ceilIdx < 0) return floorIdx;
            const floorVal = ladder[floorIdx];
            const ceilVal = ladder[ceilIdx];
            if (!Number.isFinite(floorVal)) return ceilIdx;
            if (!Number.isFinite(ceilVal)) return floorIdx;
            return Math.abs(value - floorVal) <= Math.abs(ceilVal - value) ? floorIdx : ceilIdx;
          };
          const snap = (value) => {
            if (!Number.isFinite(value)) return NaN;
            const idx = findNearestIndex(value);
            return idx >= 0 ? ladder[idx] : NaN;
          };
          const move = (value, steps = 1) => {
            if (!Number.isFinite(value) || !ladder.length) return NaN;
            const idx = findNearestIndex(value);
            const target = idx + Math.round(steps);
            return ladder[target] ?? NaN;
          };
          const nextUp = (value) => move(value, 1);
          const nextDown = (value) => move(value, -1);
          const stepsBetween = (from, to) => {
            if (!Number.isFinite(from) || !Number.isFinite(to) || !ladder.length) return 0;
            const fromIdx = findNearestIndex(from);
            const toIdx = findNearestIndex(to);
            if (fromIdx < 0 || toIdx < 0) return 0;
            return toIdx - fromIdx;
          };
          const key = (value) => {
            if (!Number.isFinite(value)) return 'nan';
            const snapped = snap(value);
            return Number.isFinite(snapped) ? snapped.toFixed(6) : 'nan';
          };
          const floor = (value) => {
            const idx = findFloorIndex(value);
            return idx >= 0 ? ladder[idx] : NaN;
          };
          const ceil = (value) => {
            const idx = findCeilIndex(value);
            return idx >= 0 ? ladder[idx] : NaN;
          };
          const setAnchor = (value) => {
            if (!Number.isFinite(value) || value <= 0) return;
            anchor = value;
          };
          const getAnchor = () => anchor;
          return {
            type: 'percent',
            gridSize: rawPercent,
            percent,
            anchor,
            snap,
            move,
            nextUp,
            nextDown,
            stepsBetween,
            key,
            floor,
            ceil,
            priceTolerance,
            anchorMode: 'fixed',
            setAnchor,
            getAnchor,
            gridLevels: Array.isArray(levels.pairs) ? levels.pairs : [],
            gridLadder: ladder
          };
        }
        const ratio = 1 + percent;
        const logRatio = Math.log(ratio);
        const priceTolerance = 1e-6;
        const snap = (value) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          const idx = Math.round(Math.log(value / anchor) / logRatio);
          return anchor * Math.pow(ratio, idx);
        };
        const move = (value, steps = 1) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          return snap(value * Math.pow(ratio, steps));
        };
        const nextUp = (value) => move(value, 1);
        const nextDown = (value) => move(value, -1);
        const stepsBetween = (from, to) => {
          if (!Number.isFinite(from) || !Number.isFinite(to) || from <= 0 || to <= 0) return 0;
          return Math.log(to / from) / logRatio;
        };
        const key = (value) => {
          if (!Number.isFinite(value) || value <= 0) return 'nan';
          return snap(value).toFixed(6);
        };
        const floor = (value) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          const idx = Math.floor(Math.log(value / anchor) / logRatio);
          return anchor * Math.pow(ratio, idx);
        };
        const ceil = (value) => {
          if (!Number.isFinite(value) || value <= 0) return NaN;
          const idx = Math.ceil(Math.log(value / anchor) / logRatio);
          return anchor * Math.pow(ratio, idx);
        };
        const anchorMode = typeRaw === 'percent_ratchet_up' ? 'ratchet_up' : 'fixed';
        const setAnchor = (value) => {
          if (!Number.isFinite(value) || value <= 0) return;
          anchor = value;
        };
        const getAnchor = () => anchor;
        return {
          type: 'percent',
          gridSize: rawPercent,
          percent,
          anchor,
          ratio,
          logRatio,
          snap,
          move,
          nextUp,
          nextDown,
          stepsBetween,
          key,
          floor,
          ceil,
          priceTolerance,
          anchorMode,
          setAnchor,
          getAnchor
        };
      }
      const size = Number(gridSize);
      if (!Number.isFinite(size) || size <= 0) {
        return { error: 'invalid_fixed' };
      }
      const rawBase = Number(basePrice);
      const offset = Number.isFinite(rawBase) ? rawBase : (Number(firstPrice) || 0);
      const decimals = Math.min(Math.max(countDecimals(size), 0), 4);
      const scale = Math.pow(10, Math.min(decimals + 2, 8));
      const round = (value) => Math.round(value * scale) / scale;
      const snap = (value) => {
        if (!Number.isFinite(value)) return NaN;
        const snapped = offset + Math.round((value - offset) / size) * size;
        return round(snapped);
      };
      const move = (value, steps = 1) => snap(value + steps * size);
      const nextUp = (value) => move(value, 1);
      const nextDown = (value) => move(value, -1);
      const stepsBetween = (from, to) => {
        if (!Number.isFinite(from) || !Number.isFinite(to)) return 0;
        return (to - from) / size;
      };
      const key = (value) => snap(value).toFixed(6);
      const floor = (value) => {
        if (!Number.isFinite(value)) return NaN;
        return snap(offset + Math.floor((value - offset) / size) * size);
      };
      const ceil = (value) => {
        if (!Number.isFinite(value)) return NaN;
        return snap(offset + Math.ceil((value - offset) / size) * size);
      };
      return {
        type: 'fixed',
        gridSize: size,
        snap,
        move,
        nextUp,
        nextDown,
        stepsBetween,
        key,
        floor,
        ceil,
        priceTolerance: 1e-9,
        decimals,
        scale,
        round,
        anchorMode: 'fixed'
      };
    }

    function passesEntryFilter(price, row, filter) {
      const normalized = (filter || 'none').toLowerCase();
      if (normalized === 'none') return true;
      if (!row) return false;
      const candidates = [
        Number(price),
        Number(row.open),
        Number(row.high),
        Number(row.close)
      ].filter(Number.isFinite);
      if (!candidates.length) return false;
      const priceNum = Math.min(...candidates);
      const windowLength = SMA_FILTER_LOOKUP[normalized];
      if (!windowLength) return true;
      const prop = SMA_PROPERTY_BY_WINDOW[windowLength];
      const comparison = prop ? row[prop] : null;
      if (!Number.isFinite(comparison) || Math.abs(comparison) < 1e-9) return true;
      const tolerance = 1e-9 * Math.max(1, Math.abs(comparison));
      return priceNum >= (comparison - tolerance);
    }

    function getEntryFilterWindow(filter) {
      const key = (filter || '').toLowerCase();
      return SMA_FILTER_LOOKUP[key] || null;
    }

    function describeSmaAvailability(filter) {
      const window = getEntryFilterWindow(filter);
      if (!window) return null;
      if (!(SMA_METADATA instanceof Map) || !SMA_METADATA.size) return null;
      const meta = SMA_METADATA.get(window);
      if (!meta) return null;
      const remaining = Math.max(0, window - (meta.totalDays || 0));
      return {
        window,
        totalDays: meta.totalDays || 0,
        availableDays: meta.availableDays || 0,
        required: window,
        remaining
      };
    }

    function getGridParamsFromUI() {
      const gridSize = Number(document.getElementById('inpGridSize')?.value ?? GRID_DEFAULTS.gridSize);
      const basePrice = Number(document.getElementById('inpBasePrice')?.value ?? 100);
      const tradeValue = Number(document.getElementById('inpTradeValue')?.value ?? GRID_DEFAULTS.tradeValue);
      const fractionalShares = !!document.getElementById('inpFractionalShares')?.checked;
      const gridType = (document.getElementById('selGridType')?.value || 'pullback').toLowerCase();
      const gridSpacingType = (document.getElementById('selGridSpacing')?.value || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const retentionMode = (document.getElementById('selRetentionMode')?.value || 'profit').toLowerCase();
      const entryFilter = (document.getElementById('selEntryFilter')?.value || GRID_DEFAULTS.entryFilter).toLowerCase();
      const tickSize = getActiveTickSize();
      return {
        gridSize: Number.isFinite(gridSize) ? gridSize : GRID_DEFAULTS.gridSize,
        basePrice: Number.isFinite(basePrice) ? basePrice : 100,
        tradeValue: Number.isFinite(tradeValue) ? tradeValue : GRID_DEFAULTS.tradeValue,
        fractionalShares,
        gridType,
        gridSpacingType,
        retentionMode,
        entryFilter,
        tickSize
      };
    }

    function renderGridSummary(summary) {
      const totalTradesEl = document.getElementById('summaryTotalTrades');
      const maxLevelsEl = document.getElementById('summaryMaxLevels');
      const netProfitEl = document.getElementById('summaryNetProfit');
      const profitPerLevelEl = document.getElementById('summaryProfitPerLevel');
      const maxCapitalEl = document.getElementById('summaryMaxCapital');
      const finalEquityEl = document.getElementById('summaryFinalEquity');
      const retainedEl = document.getElementById('summaryRetained');
      const cagrEl = document.getElementById('summaryCagr');
      const maxDdEl = document.getElementById('summaryMaxDD');
      const maxDdPctEl = document.getElementById('summaryMaxDDPct');
      const minCashEl = document.getElementById('summaryMinCash');
      const cashEl = document.getElementById('summaryCash');
      const sharesEl = document.getElementById('summaryShares');
      if (!summary) {
        if (totalTradesEl) totalTradesEl.textContent = '0';
        if (maxLevelsEl) maxLevelsEl.textContent = '0';
        if (netProfitEl) {
          netProfitEl.textContent = '$0.00';
          netProfitEl.classList.remove('text-emerald-600', 'text-red-600');
          netProfitEl.classList.add('text-slate-800');
        }
        if (profitPerLevelEl) {
          profitPerLevelEl.textContent = '$0.00';
          profitPerLevelEl.classList.remove('text-emerald-600', 'text-red-600');
          profitPerLevelEl.classList.add('text-slate-800');
        }
        if (finalEquityEl) finalEquityEl.textContent = '$0.00';
        if (retainedEl) retainedEl.textContent = '0';
        if (cagrEl) {
          cagrEl.textContent = '0.00%';
          cagrEl.classList.remove('text-emerald-600', 'text-red-600');
          cagrEl.classList.add('text-slate-800');
        }
        if (maxCapitalEl) maxCapitalEl.textContent = '$0.00';
        if (maxDdEl) {
          maxDdEl.textContent = '$0.00';
          maxDdEl.classList.remove('text-red-600');
          maxDdEl.classList.add('text-slate-800');
        }
        if (maxDdPctEl) {
          maxDdPctEl.textContent = '0.00%';
          maxDdPctEl.classList.remove('text-red-600');
          maxDdPctEl.classList.add('text-slate-800');
        }
        if (minCashEl) minCashEl.textContent = '$0.00';
        if (cashEl) cashEl.textContent = '$0.00';
        if (sharesEl) sharesEl.textContent = '0';
        return;
      }
      if (totalTradesEl) totalTradesEl.textContent = String(summary.totalTrades ?? 0);
      if (maxLevelsEl) {
        const maxLevels = Number.isFinite(summary?.maxOpenLevels) ? summary.maxOpenLevels : 0;
        maxLevelsEl.textContent = maxLevels.toLocaleString();
      }
      if (maxCapitalEl) {
        const maxCapital = Number.isFinite(summary?.maxDeployedCapital) ? summary.maxDeployedCapital : 0;
        maxCapitalEl.textContent = formatCurrency(maxCapital);
      }
      if (netProfitEl) {
        const net = summary.netProfit ?? 0;
        netProfitEl.textContent = formatCurrency(net);
        netProfitEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (net > 1e-8) {
          netProfitEl.classList.add('text-emerald-600');
        } else if (net < -1e-8) {
          netProfitEl.classList.add('text-red-600');
        } else {
          netProfitEl.classList.add('text-slate-800');
        }
      }
      if (profitPerLevelEl) {
        const val = summary.profitPerLevel ?? 0;
        profitPerLevelEl.textContent = formatCurrency(val);
        profitPerLevelEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (val > 1e-8) {
          profitPerLevelEl.classList.add('text-emerald-600');
        } else if (val < -1e-8) {
          profitPerLevelEl.classList.add('text-red-600');
        } else {
          profitPerLevelEl.classList.add('text-slate-800');
        }
      }
      if (finalEquityEl) finalEquityEl.textContent = formatCurrency(summary.finalEquity ?? 0);
      if (retainedEl) retainedEl.textContent = formatNumber(summary.totalRetainedShares ?? 0, 4);
      if (cagrEl) {
        const cagr = summary.cagr ?? 0;
        const pct = cagr * 100;
        cagrEl.textContent = formatPercent(pct);
        cagrEl.classList.remove('text-slate-800', 'text-emerald-600', 'text-red-600');
        if (cagr > 1e-6) {
          cagrEl.classList.add('text-emerald-600');
        } else if (cagr < -1e-6) {
          cagrEl.classList.add('text-red-600');
        } else {
          cagrEl.classList.add('text-slate-800');
        }
      }
      if (maxDdEl) {
        const maxDd = summary.maxDrawdown ?? 0;
        maxDdEl.textContent = formatCurrency(maxDd);
        maxDdEl.classList.remove('text-slate-800', 'text-red-600');
        if (maxDd < -1e-8) {
          maxDdEl.classList.add('text-red-600');
        } else {
          maxDdEl.classList.add('text-slate-800');
        }
      }
      if (maxDdPctEl) {
        const maxDdPct = summary.maxDrawdownPct ?? 0;
        const pctStr = `${PERCENT_FORMAT.format(maxDdPct)}%`;
        maxDdPctEl.textContent = pctStr;
        maxDdPctEl.classList.remove('text-slate-800', 'text-red-600');
        if (maxDdPct < -1e-8) {
          maxDdPctEl.classList.add('text-red-600');
        } else {
          maxDdPctEl.classList.add('text-slate-800');
        }
      }
      if (minCashEl) minCashEl.textContent = formatCurrency(summary.minCash ?? 0);
      if (cashEl) cashEl.textContent = formatCurrency(summary.cash ?? 0);
      if (sharesEl) sharesEl.textContent = formatNumber(summary.shares ?? 0, 4);
    }

    function getTradeSortValue(trade, key) {
      if (!trade) return 0;
      switch (key) {
        case 'buyTime':
          return trade.buyTime instanceof Date ? trade.buyTime.getTime() : new Date(trade.buyTime).getTime() || 0;
        case 'sellTime':
          return trade.sellTime instanceof Date ? trade.sellTime.getTime() : new Date(trade.sellTime).getTime() || 0;
        case 'buyPrice':
        case 'sellPrice':
        case 'buyQty':
        case 'openQty':
        case 'openEquity':
        case 'sellQty':
        case 'closeQty':
        case 'closeEquity':
        case 'qtyRetained':
        case 'cumQtyRetained':
        case 'daysHeld':
        case 'profit':
        case 'cumProfit':
        case 'runningPnl':
        case 'drawdown':
        case 'roiPct':
        case 'gridLevel':
        case 'openLevels':
          return Number(trade[key]) || 0;
        default:
          return 0;
      }
    }

    function sortTradesForDisplay(trades) {
      if (!Array.isArray(trades) || trades.length <= 1) return Array.isArray(trades) ? trades.slice() : [];
      const { key, dir } = TRADE_SORT_STATE;
      const direction = dir === 'desc' ? -1 : 1;
      return trades.slice().sort((a, b) => {
        const va = getTradeSortValue(a, key);
        const vb = getTradeSortValue(b, key);
        if (va === vb) return 0;
        return va > vb ? direction : -direction;
      });
    }

    function updateTradeSortIndicators() {
      const headers = document.querySelectorAll('th[data-sort-key]');
      headers.forEach((th) => {
        const key = th.getAttribute('data-sort-key');
        if (!key) return;
        if (key === TRADE_SORT_STATE.key) {
          th.setAttribute('data-sort', TRADE_SORT_STATE.dir);
        } else {
          th.setAttribute('data-sort', 'none');
        }
      });
    }

    function formatMonthKeyFromDate(value) {
      const date = value instanceof Date ? value : new Date(value);
      if (!(date instanceof Date) || isNaN(date)) return null;
      const mm = pad2(date.getMonth() + 1);
      const yy = date.getFullYear();
      return `${mm}/${yy}`;
    }

    function monthChoicesFromDays() {
      if (!Array.isArray(DAYS) || !DAYS.length) return [];
      const set = new Set();
      for (const dayKey of DAYS) {
        if (typeof dayKey !== 'string' || dayKey.length < 7) continue;
        set.add(`${dayKey.slice(5, 7)}/${dayKey.slice(0, 4)}`);
      }
      return Array.from(set).sort((a, b) => {
        const [am, ay] = a.split('/').map(Number);
        const [bm, by] = b.split('/').map(Number);
        if (ay !== by) return by - ay;
        return bm - am;
      });
    }

    function isMonthFilterStrict() {
      return VIEW_MONTHS.size > 0 && VIEW_MONTHS.size < AVAILABLE_MONTHS.length;
    }

    function formatDayKeyToMonth(dayKey) {
      if (typeof dayKey !== 'string' || dayKey.length < 7) return null;
      return `${dayKey.slice(5, 7)}/${dayKey.slice(0, 4)}`;
    }

    function applyMonthFilter(trades) {
      if (!Array.isArray(trades) || !trades.length) return [];
      if (!VIEW_MONTHS.size) return trades.slice();
      return trades.filter((trade) => {
        const key = formatMonthKeyFromDate(trade?.buyTime);
        return key && VIEW_MONTHS.has(key);
      });
    }

    function filterRowsBySelectedMonths(rows) {
      if (!Array.isArray(rows) || !rows.length) return [];
      if (!VIEW_MONTHS.size) return rows.slice();
      return rows.filter((row) => {
        if (!row || !row.dayKey) return false;
        const key = formatDayKeyToMonth(row.dayKey);
        return key && VIEW_MONTHS.has(key);
      });
    }

    function rerunBacktestIfDataLoaded() {
      if (Array.isArray(ROWS) && ROWS.length) {
        runGridBacktest();
      }
    }

    function clampTradePage(totalRows) {
      const size = Math.max(25, Math.min(1000, Math.round(TRADE_TABLE_STATE.pageSize) || 250));
      TRADE_TABLE_STATE.pageSize = size;
      const total = Math.max(0, Number(totalRows) || 0);
      const totalPages = total > 0 ? Math.ceil(total / size) : 1;
      if (TRADE_TABLE_STATE.page > totalPages) TRADE_TABLE_STATE.page = totalPages;
      if (TRADE_TABLE_STATE.page < 1) TRADE_TABLE_STATE.page = 1;
      return { pageSize: size, totalPages };
    }

    function normalizeSymbolInput(val) {
      return (val || '').trim().toUpperCase();
    }

    function collectGridBacktestPayload() {
      if (!GRID_STATE?.summary) return null;
      const params = getGridParamsFromUI();
      const summary = GRID_STATE.summary || {};
      const days = Array.isArray(DAYS) ? DAYS : [];
      const dateStart = days.length ? days[0] : null;
      const dateEnd = days.length ? days[days.length - 1] : null;
      return {
        symbol: currentTicker || null,
        bar_interval_minutes: RESAMPLE_INTERVAL_MINUTES,
        bar_count: Array.isArray(ROWS) ? ROWS.length : 0,
        day_count: days.length,
        date_start: dateStart,
        date_end: dateEnd,
        base_price: Number.isFinite(params?.basePrice) ? params.basePrice : null,
        grid_type: params?.gridType || null,
        grid_size: Number.isFinite(params?.gridSize) ? params.gridSize : null,
        trade_value: Number.isFinite(params?.tradeValue) ? params.tradeValue : null,
        retention_mode: params?.retentionMode || null,
        max_levels: Number.isFinite(summary?.maxOpenLevels) ? summary.maxOpenLevels : null,
        completed_trades: Number.isFinite(summary?.totalTrades) ? summary.totalTrades : null,
        net_profit: Number.isFinite(summary?.netProfit) ? summary.netProfit : null,
        profit_per_level: Number.isFinite(summary?.profitPerLevel) ? summary.profitPerLevel : null,
        final_equity: Number.isFinite(summary?.finalEquity) ? summary.finalEquity : null,
        cagr: Number.isFinite(summary?.cagr) ? summary.cagr : null,
        retained_shares: Number.isFinite(summary?.totalRetainedShares) ? summary.totalRetainedShares : null,
        max_drawdown: Number.isFinite(summary?.maxDrawdown) ? summary.maxDrawdown : null,
        max_drawdown_pct: Number.isFinite(summary?.maxDrawdownPct) ? summary.maxDrawdownPct : null,
        max_deployed_capital: Number.isFinite(summary?.maxDeployedCapital) ? summary.maxDeployedCapital : null
      };
    }

    async function requestSaveGridBacktest(payload) {
      const res = await fetch('/api/save-grid-backtest', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      const data = contentType.includes('application/json') ? await res.json() : null;
      if (!res.ok) {
        const errMsg = data && data.error ? data.error : `HTTP ${res.status}`;
        throw new Error(errMsg);
      }
      return data;
    }

    let adhocStatusPoll = null;

    function stopAdhocStatusPolling() {
      if (adhocStatusPoll) {
        clearInterval(adhocStatusPoll);
        adhocStatusPoll = null;
      }
    }

    async function fetchAdhocStatus(symbol) {
      const res = await fetch(`/api/polygon-download/status?symbol=${encodeURIComponent(symbol)}`);
      if (!res.ok) return;
      const payload = await res.json();
      const message = payload && payload.message ? payload.message : '';
      if (message) {
        setStatus(message);
        setGridStatus(message);
      }
      if (payload && payload.state && payload.state !== 'running') {
        stopAdhocStatusPolling();
      }
    }

    function startAdhocStatusPolling(symbol) {
      stopAdhocStatusPolling();
      if (!symbol) return;
      adhocStatusPoll = setInterval(() => {
        fetchAdhocStatus(symbol).catch(() => {});
      }, 1000);
      fetchAdhocStatus(symbol).catch(() => {});
    }

    function setAdhocDownloadBusy(isBusy) {
      const btn = document.getElementById('btnAdhocGetData');
      const input = document.getElementById('inpAdhocSymbol');
      if (btn) btn.disabled = !!isBusy;
      if (input) input.disabled = !!isBusy;
    }

    async function requestAdhocDownload(symbol) {
      const res = await fetch('/api/polygon-download', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ symbol })
      });
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      const payload = contentType.includes('application/json') ? await res.json() : null;
      if (!res.ok) {
        const errMsg = payload && payload.error ? payload.error : `HTTP ${res.status}`;
        throw new Error(errMsg);
      }
      return payload;
    }

    function updateTradePaginationControls(totalRows, range) {
      const info = document.getElementById('tradePaginationInfo');
      const prev = document.getElementById('tradePagePrev');
      const next = document.getElementById('tradePageNext');
      const select = document.getElementById('tradePageSize');
      const { pageSize, totalPages } = clampTradePage(totalRows);
      const page = TRADE_TABLE_STATE.page;
      const start = Math.max(0, range?.start ?? 0);
      const end = Math.max(start, Math.min(totalRows, range?.end ?? (start + pageSize)));
      if (info) {
        if (!totalRows) {
          info.textContent = 'No trades to display.';
        } else {
          info.textContent = `${start + 1}–${end} of ${totalRows.toLocaleString()} trade${totalRows === 1 ? '' : 's'}`;
        }
      }
      if (prev) prev.disabled = page <= 1 || totalRows <= 0;
      if (next) next.disabled = page >= totalPages || totalRows <= pageSize;
      if (select && select.value !== String(pageSize)) {
        select.value = String(pageSize);
      }
    }

    function renderGridTrades(trades, options = {}) {
      if (options?.resetPage) {
        TRADE_TABLE_STATE.page = 1;
      }
      const tbody = document.getElementById('gridTradeRows');
      const emptyState = document.getElementById('gridTradesEmpty');
      const label = document.getElementById('tradeCountLabel');
      if (!tbody) return;
      const source = Array.isArray(trades) ? trades : [];
      const filtered = applyMonthFilter(source);
      const filterActive = isMonthFilterStrict();
      tbody.innerHTML = '';
      if (!filtered.length) {
        if (emptyState) {
          emptyState.textContent = filterActive
            ? 'No trades match the selected month filter.'
            : 'Run the backtest to see individual trades.';
          emptyState.classList.remove('hidden');
        }
        if (label) label.textContent = '0 trades';
        updateTradePaginationControls(0);
        updateTradeSortIndicators();
        return;
      }
      if (emptyState) {
        emptyState.textContent = 'Run the backtest to see individual trades.';
        emptyState.classList.add('hidden');
      }
      const displayTrades = sortTradesForDisplay(filtered);
      const { pageSize } = clampTradePage(displayTrades.length);
      const page = TRADE_TABLE_STATE.page;
      const start = (page - 1) * pageSize;
      const end = Math.min(displayTrades.length, start + pageSize);
      const visibleTrades = displayTrades.slice(start, end);
      const frag = document.createDocumentFragment();
      for (const trade of visibleTrades) {
        const tr = document.createElement('tr');
        const openLevelsLabel = Number.isFinite(trade.openLevels) ? trade.openLevels.toLocaleString() : '—';
        tr.innerHTML = `
          <td class="px-3 py-2 whitespace-nowrap">${formatDateTime(trade.buyTime)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.buyPrice, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.buyQty, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.openQty ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatCurrency(trade.openEquity ?? 0)}</td>
          <td class="px-3 py-2 text-right">${openLevelsLabel}</td>
          <td class="px-3 py-2 whitespace-nowrap">${formatDateTime(trade.sellTime)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.sellPrice, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.sellQty, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.closeQty ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatCurrency(trade.closeEquity ?? 0)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.qtyRetained ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.cumQtyRetained ?? 0, 4)}</td>
          <td class="px-3 py-2 text-right">${formatNumber(trade.daysHeld ?? 0, 2)}</td>
          <td class="px-3 py-2 text-right ${trade.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(trade.profit)}</td>
          <td class="px-3 py-2 text-right ${trade.cumProfit >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(trade.cumProfit)}</td>
          <td class="px-3 py-2 text-right ${trade.runningPnl >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(trade.runningPnl)}</td>
          <td class="px-3 py-2 text-right ${trade.drawdown >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatCurrency(trade.drawdown)}</td>
          <td class="px-3 py-2 text-right ${trade.roiPct >= 0 ? 'text-emerald-600' : 'text-red-600'}">${formatPercent(trade.roiPct)}</td>
        `;
        frag.appendChild(tr);
      }
      tbody.appendChild(frag);
      if (label) label.textContent = `${filtered.length} trade${filtered.length === 1 ? '' : 's'}`;
      updateTradePaginationControls(displayTrades.length, { start, end });
      updateTradeSortIndicators();
    }

    function updateMonthFilterLabel() {
      const lbl = document.getElementById('sumMonthMultiLabel');
      if (!lbl) return;
      if (!VIEW_MONTHS.size || VIEW_MONTHS.size === AVAILABLE_MONTHS.length) {
        lbl.textContent = 'All months';
        return;
      }
      if (VIEW_MONTHS.size <= 2) {
        lbl.textContent = Array.from(VIEW_MONTHS).sort().join(', ');
        return;
      }
      lbl.textContent = `${VIEW_MONTHS.size} selected`;
    }

    function buildMonthFilterOptions() {
      AVAILABLE_MONTHS = monthChoicesFromDays();
      const list = document.getElementById('sumMonthMultiList');
      if (!list) return;
      if (!AVAILABLE_MONTHS.length) {
        list.innerHTML = '<div class="px-2 py-1 text-xs text-slate-500">No data loaded.</div>';
      } else {
        list.innerHTML = AVAILABLE_MONTHS.map(key => `
          <label class="flex items-center gap-2 px-2 py-1 rounded hover:bg-slate-50 cursor-pointer">
            <input type="checkbox" class="h-4 w-4 rounded border-slate-300" data-month="${key}" ${VIEW_MONTHS.has(key) ? 'checked' : ''} />
            <span class="text-sm text-slate-800">${key}</span>
          </label>
        `).join('');
      }
      if (VIEW_MONTHS.size && VIEW_MONTHS.size >= AVAILABLE_MONTHS.length) {
        VIEW_MONTHS = new Set(AVAILABLE_MONTHS);
      } else {
        const valid = new Set();
        VIEW_MONTHS.forEach(key => { if (AVAILABLE_MONTHS.includes(key)) valid.add(key); });
        VIEW_MONTHS = valid;
      }
      document.querySelectorAll('#sumMonthMultiList input[data-month]').forEach(cb => {
        const key = cb.getAttribute('data-month');
        cb.checked = VIEW_MONTHS.has(key);
      });
      updateMonthFilterLabel();
    }

    document.addEventListener('click', (e) => {
      const menu = document.getElementById('sumMonthMultiMenu');
      if (!menu) return;
      const btn = e.target.closest('#sumMonthMultiBtn');
      if (btn) {
        menu.classList.toggle('hidden');
        return;
      }
      if (!menu.contains(e.target)) {
        menu.classList.add('hidden');
      }
    });

    document.addEventListener('click', (e) => {
      const selAll = e.target.closest('#sumMonthSelectAll');
      const clrAll = e.target.closest('#sumMonthClearAll');
      if (!selAll && !clrAll) return;
      if (selAll) VIEW_MONTHS = new Set(AVAILABLE_MONTHS);
      if (clrAll) VIEW_MONTHS = new Set();
      document.querySelectorAll('#sumMonthMultiList input[data-month]').forEach(cb => {
        const key = cb.getAttribute('data-month');
        cb.checked = VIEW_MONTHS.has(key);
      });
      updateMonthFilterLabel();
      renderGridTrades(GRID_STATE.trades || [], { resetPage: true });
      rerunBacktestIfDataLoaded();
    });

    document.addEventListener('change', (e) => {
      const cb = e.target.closest('#sumMonthMultiList input[data-month]');
      if (!cb) return;
      const key = cb.getAttribute('data-month');
      if (!key) return;
      if (cb.checked) VIEW_MONTHS.add(key); else VIEW_MONTHS.delete(key);
      updateMonthFilterLabel();
      renderGridTrades(GRID_STATE.trades || [], { resetPage: true });
      rerunBacktestIfDataLoaded();
    });

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#priceFillToggle button[data-view]');
      if (!btn) return;
      const view = btn.getAttribute('data-view');
      if (!view) return;
      setPriceDistributionView(view);
    });

    (function(){
      const toggle = document.getElementById('gridLevelsToggle');
      const body = document.getElementById('gridLevelsBody');
      const label = document.getElementById('gridLevelsToggleLabel');
      const chevron = document.getElementById('gridLevelsChevron');
      if (!toggle || !body) return;
      const setExpanded = (expanded) => {
        toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        body.classList.toggle('hidden', !expanded);
        if (label) label.textContent = expanded ? 'Hide Levels' : 'Show Levels';
        if (chevron) chevron.classList.toggle('rotate-180', expanded);
      };
      setExpanded(false);
      toggle.addEventListener('click', (e) => {
        e.preventDefault();
        const expanded = toggle.getAttribute('aria-expanded') === 'true';
        setExpanded(!expanded);
      });
    })();

    function renderGridLevels(buyLevels, sellLevels, baseLevel) {
      const buyEl = document.getElementById('gridBuyLevels');
      const sellEl = document.getElementById('gridSellLevels');
      const buyCountEl = document.getElementById('gridBuyLevelCount');
      const sellCountEl = document.getElementById('gridSellLevelCount');
      const summaryEl = document.getElementById('gridLevelsSummary');
      const defaultMsg = 'Run the backtest to list the ladder levels currently seeded for buys and sells.';
      const formatList = (values, order = 'desc') => {
        if (!Array.isArray(values) || !values.length) {
          return '<div class="text-xs text-slate-500">No levels generated yet.</div>';
        }
        const sorted = values.slice().sort(order === 'asc' ? ((a, b) => a - b) : ((a, b) => b - a));
        const items = sorted.map((price, idx) => `
          <li class="flex items-center justify-between gap-4">
            <span class="text-xs text-slate-500">#${idx + 1}</span>
            <span class="font-mono text-sm text-slate-800">$${formatNumber(price, 4)}</span>
          </li>
        `).join('');
        return `<ol class="space-y-1">${items}</ol>`;
      };
      const buyCount = Array.isArray(buyLevels) ? buyLevels.length : 0;
      const sellCount = Array.isArray(sellLevels) ? sellLevels.length : 0;
      if (buyEl) buyEl.innerHTML = formatList(buyLevels || [], 'desc');
      if (sellEl) sellEl.innerHTML = formatList(sellLevels || [], 'asc');
      if (buyCountEl) buyCountEl.textContent = `${buyCount.toLocaleString()} level${buyCount === 1 ? '' : 's'}`;
      if (sellCountEl) sellCountEl.textContent = `${sellCount.toLocaleString()} level${sellCount === 1 ? '' : 's'}`;
      if (summaryEl) {
        if (buyCount || sellCount) {
          const baseText = Number.isFinite(baseLevel) ? ` Base price: $${formatNumber(baseLevel, 4)}.` : '';
          summaryEl.textContent = `Tracking ${buyCount.toLocaleString()} buy level${buyCount === 1 ? '' : 's'} and ${sellCount.toLocaleString()} sell level${sellCount === 1 ? '' : 's'} from the latest run.${baseText}`;
        } else {
          summaryEl.textContent = defaultMsg;
        }
      }
    }

    function renderGridEquityChart(series) {
      const container = document.getElementById('gridEquityChart');
      const emptyState = document.getElementById('gridEquityEmpty');
      const label = document.getElementById('equitySummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!gridEquityChartInst) {
        gridEquityChartInst = echarts.init(container);
      }
      if (!Array.isArray(series) || !series.length) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        gridEquityChartInst.clear();
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const equityData = series.map(point => {
        const time = point.time instanceof Date ? point.time : new Date(point.time);
        return [time.getTime(), Number(point.equity) || 0];
      }).filter(item => Number.isFinite(item[0]) && Number.isFinite(item[1]));
      equityData.sort((a, b) => a[0] - b[0]);
      const cashData = series.map(point => {
        const time = point.time instanceof Date ? point.time : new Date(point.time);
        return [time.getTime(), Number(point.cash)];
      }).filter(item => Number.isFinite(item[0]) && Number.isFinite(item[1]));
      cashData.sort((a, b) => a[0] - b[0]);
      if (!equityData.length) {
        gridEquityChartInst.clear();
        if (label) label.textContent = '';
        if (emptyState) emptyState.classList.remove('hidden');
        return;
      }
      const first = equityData[0];
      const last = equityData[equityData.length - 1];
      if (label && first && last) {
        const start = new Date(first[0]);
        const end = new Date(last[0]);
        label.textContent = `${start.toISOString().slice(0, 10)} → ${end.toISOString().slice(0, 10)} (${equityData.length.toLocaleString()} points)`;
      }
      const gradient = (echarts.graphic && echarts.graphic.LinearGradient)
        ? new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: 'rgba(15, 118, 110, 0.25)' },
            { offset: 1, color: 'rgba(15, 118, 110, 0)' }
          ])
        : 'rgba(15, 118, 110, 0.1)';
      gridEquityChartInst.setOption({
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        legend: {
          data: ['Equity', 'Cash Balance'],
          textStyle: { color: '#475569' },
          selected: {
            Equity: true,
            'Cash Balance': true
          }
        },
        dataZoom: [
          {
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'filter'
          },
          {
            type: 'inside',
            yAxisIndex: 0,
            filterMode: 'weakFilter'
          }
        ],
        visualMap: undefined,
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'cross' },
          valueFormatter: (val) => formatCurrency(val)
        },
        xAxis: {
          type: 'time',
          boundaryGap: false,
          axisLabel: { color: '#64748b' }
        },
        yAxis: {
          type: 'value',
          scale: true,
          axisLabel: {
            formatter: (val) => formatCurrency(val).replace('$', ''),
            color: '#64748b'
          },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Equity',
            type: 'line',
            smooth: true,
            showSymbol: false,
            lineStyle: { color: '#0f766e', width: 2 },
            areaStyle: gradient ? { color: gradient } : undefined,
            data: equityData
          },
          {
            name: 'Cash Balance',
            type: 'line',
            smooth: true,
            showSymbol: false,
            lineStyle: { color: '#64748b', width: 1.5, type: 'dashed' },
            data: cashData
          }
        ]
      }, true);
    }

    function renderLadderChart(trades) {
      const container = document.getElementById('gridLadderChart');
      const emptyState = document.getElementById('gridLadderEmpty');
      const label = document.getElementById('ladderSummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!gridLadderChartInst) {
        gridLadderChartInst = echarts.init(container);
      }
      if (!Array.isArray(trades) || !trades.length) {
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        gridLadderChartInst.clear();
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const buyPoints = [];
      const sellPoints = [];
      trades.forEach((trade) => {
        if (trade?.buyTime) {
          const time = trade.buyTime instanceof Date ? trade.buyTime : new Date(trade.buyTime);
          if (time instanceof Date && !isNaN(time)) {
            buyPoints.push([
              time.getTime(),
              Number(trade.buyPrice) || 0,
              Number(trade.buyQty) || 0
            ]);
          }
        }
        if (trade?.sellTime) {
          const time = trade.sellTime instanceof Date ? trade.sellTime : new Date(trade.sellTime);
          if (time instanceof Date && !isNaN(time)) {
            sellPoints.push([
              time.getTime(),
              Number(trade.sellPrice) || 0,
              Number(trade.sellQty) || 0
            ]);
          }
        }
      });
      buyPoints.sort((a, b) => a[0] - b[0]);
      sellPoints.sort((a, b) => a[0] - b[0]);
      if (!buyPoints.length && !sellPoints.length) {
        gridLadderChartInst.clear();
        if (label) label.textContent = '';
        if (emptyState) emptyState.classList.remove('hidden');
        return;
      }
      if (label) {
        const totalPoints = buyPoints.length + sellPoints.length;
        label.textContent = `${totalPoints.toLocaleString()} fills (${buyPoints.length.toLocaleString()} buys · ${sellPoints.length.toLocaleString()} sells)`;
      }
      const formatter = (params) => {
        if (!params || !params.value) return '';
        const [ts, price, qty] = params.value;
        const date = new Date(ts);
        const timeStr = Number.isFinite(ts) ? formatDateTime(date) : '';
        return `
          <div class="text-xs">
            <div class="font-semibold">${params.seriesName}</div>
            <div>${timeStr}</div>
            <div>Price: ${formatNumber(price, 4)}</div>
            <div>Qty: ${formatNumber(qty, 4)}</div>
          </div>
        `;
      };
      gridLadderChartInst.setOption({
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        legend: {
          data: ['Buy fills', 'Sell fills'],
          textStyle: { color: '#475569' }
        },
        tooltip: {
          trigger: 'item',
          formatter
        },
        dataZoom: [
          {
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'filter'
          },
          {
            type: 'inside',
            yAxisIndex: 0,
            filterMode: 'weakFilter'
          }
        ],
        xAxis: {
          type: 'time',
          axisLabel: { color: '#64748b' }
        },
        yAxis: {
          type: 'value',
          scale: true,
          axisLabel: {
            formatter: (val) => formatNumber(val, 4),
            color: '#64748b'
          },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Buy fills',
            type: 'scatter',
            symbolSize: 4,
            itemStyle: { color: '#0f766e' },
            data: buyPoints
          },
          {
            name: 'Sell fills',
            type: 'scatter',
            symbolSize: 4,
            itemStyle: { color: '#dc2626' },
            data: sellPoints
          }
        ]
      }, true);
    }

    function computeDailyFillEntries(trades) {
      const source = Array.isArray(trades) ? trades : [];
      const counts = new Map();
      const addCount = (key, type) => {
        if (!key) return;
        if (!counts.has(key)) counts.set(key, { key, buy: 0, sell: 0 });
        const entry = counts.get(key);
        if (type === 'buy') entry.buy += 1;
        if (type === 'sell') entry.sell += 1;
      };
      for (const trade of source) {
        addCount(dateKeyFromStr(trade?.buyTime), 'buy');
        addCount(dateKeyFromStr(trade?.sellTime), 'sell');
      }
      const entries = Array.from(counts.values()).sort((a, b) => (a.key || '').localeCompare(b.key || ''));
      const totals = entries.reduce((acc, entry) => {
        acc.buys += Number(entry.buy) || 0;
        acc.sells += Number(entry.sell) || 0;
        return acc;
      }, { buys: 0, sells: 0 });
      return { entries, totals };
    }

    function computeDailyOpenLevels(history) {
      const source = Array.isArray(history) ? history : [];
      const perDay = new Map();
      for (const entry of source) {
        if (!entry) continue;
        const dateKey = dateKeyFromStr(entry.time);
        if (!dateKey) continue;
        const ts = entry.time instanceof Date ? entry.time.getTime() : NaN;
        const levelsRaw = Number.isFinite(entry?.sells) ? Number(entry.sells) : Number(entry?.buys);
        const levels = Number.isFinite(levelsRaw) ? Math.max(0, levelsRaw) : 0;
        const existing = perDay.get(dateKey);
        if (!existing || (Number.isFinite(ts) && ts > existing.ts)) {
          perDay.set(dateKey, { key: dateKey, levels, ts });
        }
      }
      const entries = Array.from(perDay.values()).sort((a, b) => (a.key || '').localeCompare(b.key || ''));
      const stats = entries.reduce((acc, entry) => {
        if (entry && Number.isFinite(entry.levels)) {
          acc.max = Math.max(acc.max, entry.levels);
          acc.last = entry.levels;
        }
        return acc;
      }, { max: 0, last: 0 });
      return { entries, stats };
    }

    function renderFillsPerDayChart(trades) {
      const container = document.getElementById('dailyFillsChart');
      const emptyState = document.getElementById('dailyFillsEmpty');
      const label = document.getElementById('fillsDaySummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!fillsPerDayChartInst) {
        fillsPerDayChartInst = echarts.init(container);
      }
      const { entries, totals } = computeDailyFillEntries(trades);
      if (!entries.length) {
        fillsPerDayChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      const categories = entries.map(entry => entry.key);
      const buyCounts = entries.map(entry => {
        const val = Number(entry.buy) || 0;
        return val ? -val : 0;
      });
      const sellCounts = entries.map(entry => Number(entry.sell) || 0);
      const totalBuys = totals?.buys || 0;
      const totalSells = totals?.sells || 0;
      const totalFills = totalBuys + totalSells;
      if (label) {
        label.textContent = `${totalFills.toLocaleString()} fills across ${entries.length.toLocaleString()} day${entries.length === 1 ? '' : 's'} (${totalBuys.toLocaleString()} buys · ${totalSells.toLocaleString()} sells)`;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const tooltipFormatter = (params) => {
        if (!Array.isArray(params) || !params.length) return '';
        const date = params[0]?.axisValueLabel || '';
        const rows = params.map((p) => {
          const val = Math.abs(Number(p.value) || 0);
          return `
            <div style="display:flex;align-items:center;gap:6px;">
              <span style="display:inline-block;width:10px;height:10px;border-radius:999px;background:${p.color};"></span>
              <span>${p.seriesName}: ${val.toLocaleString()}</span>
            </div>
          `;
        }).join('');
        return `<div><div class="font-semibold mb-1">${date}</div>${rows}</div>`;
      };
      fillsPerDayChartInst.setOption({
        color: ['#0f766e', '#dc2626', '#2563eb'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 55, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'shadow' },
          formatter: tooltipFormatter
        },
        legend: {
          data: ['Buy fills (shown negative)', 'Sell fills', 'Net Sell Fills'],
          selected: { 'Net Sell Fills': false },
          textStyle: { color: '#475569' }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b', rotate: 45 },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Buy fills (shown negative)',
            type: 'bar',
            barGap: '25%',
            barCategoryGap: '45%',
            itemStyle: { color: '#0f766e' },
            data: buyCounts
          },
          {
            name: 'Sell fills',
            type: 'bar',
            barGap: '25%',
            barCategoryGap: '45%',
            itemStyle: { color: '#dc2626' },
            data: sellCounts
          },
          {
            name: 'Net Sell Fills',
            type: 'bar',
            barGap: '25%',
            barCategoryGap: '45%',
            itemStyle: { color: '#2563eb' },
            data: entries.map(entry => (Number(entry.sell) || 0) - (Number(entry.buy) || 0))
          }
        ]
      }, true);
    }

    function renderOpenLevelsChart(ladderHistory) {
      const container = document.getElementById('openLevelsChart');
      const emptyState = document.getElementById('openLevelsEmpty');
      const label = document.getElementById('openLevelsSummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!openLevelsChartInst) {
        openLevelsChartInst = echarts.init(container);
      }
      const { entries, stats } = computeDailyOpenLevels(ladderHistory);
      if (!entries.length) {
        openLevelsChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      const categories = entries.map(entry => entry.key);
      const levels = entries.map(entry => Number(entry.levels) || 0);
      const maxLevels = Number.isFinite(stats?.max) ? stats.max : 0;
      const lastLevels = Number.isFinite(stats?.last) ? stats.last : 0;
      if (label) {
        label.textContent = `${entries.length.toLocaleString()} day${entries.length === 1 ? '' : 's'} · last: ${lastLevels.toLocaleString()} open level${lastLevels === 1 ? '' : 's'} · max: ${maxLevels.toLocaleString()}`;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const tooltipFormatter = (params) => {
        if (!Array.isArray(params) || !params.length) return '';
        const date = params[0]?.axisValueLabel || '';
        const rows = params.map((p) => {
          const val = Number(p.value) || 0;
          return `
            <div style="display:flex;align-items:center;gap:6px;">
              <span style="display:inline-block;width:10px;height:10px;border-radius:999px;background:${p.color};"></span>
              <span>${p.seriesName}: ${val.toLocaleString()}</span>
            </div>
          `;
        }).join('');
        return `<div><div class="font-semibold mb-1">${date}</div>${rows}</div>`;
      };
      openLevelsChartInst.setOption({
        color: ['#2563eb'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 55, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'line' },
          formatter: tooltipFormatter
        },
        legend: {
          data: ['Open Levels (end of day)'],
          textStyle: { color: '#475569' }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b', rotate: 45 },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Open Levels (end of day)',
            type: 'bar',
            barGap: '30%',
            barCategoryGap: '45%',
            itemStyle: { color: '#2563eb' },
            data: levels
          }
        ]
      }, true);
    }

    function renderFillsPerMonthChart(trades) {
      const container = document.getElementById('monthlyFillsChart');
      const emptyState = document.getElementById('monthlyFillsEmpty');
      const label = document.getElementById('fillsMonthSummaryLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!fillsPerMonthChartInst) {
        fillsPerMonthChartInst = echarts.init(container);
      }
      const source = Array.isArray(trades) ? trades : [];
      const counts = new Map();
      const addCount = (key, type) => {
        if (!key) return;
        if (!counts.has(key)) counts.set(key, { key, buy: 0, sell: 0 });
        const entry = counts.get(key);
        if (type === 'buy') entry.buy += 1;
        if (type === 'sell') entry.sell += 1;
      };
      for (const trade of source) {
        addCount(formatMonthKeyFromDate(trade?.buyTime), 'buy');
        addCount(formatMonthKeyFromDate(trade?.sellTime), 'sell');
      }
      const entries = Array.from(counts.values());
      if (!entries.length) {
        fillsPerMonthChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      entries.sort((a, b) => {
        const [am, ay] = a.key.split('/').map(Number);
        const [bm, by] = b.key.split('/').map(Number);
        if (ay !== by) return ay - by;
        return am - bm;
      });
      const categories = entries.map(entry => entry.key);
      const buyCounts = entries.map(entry => entry.buy);
      const sellCounts = entries.map(entry => entry.sell);
      const totalBuys = buyCounts.reduce((sum, val) => sum + val, 0);
      const totalSells = sellCounts.reduce((sum, val) => sum + val, 0);
      const totalFills = totalBuys + totalSells;
      if (label) {
        label.textContent = `${totalFills.toLocaleString()} fills (${totalBuys.toLocaleString()} buys · ${totalSells.toLocaleString()} sells)`;
      }
      if (emptyState) emptyState.classList.add('hidden');
      fillsPerMonthChartInst.setOption({
        color: ['#0f766e', '#dc2626'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'shadow' }
        },
        legend: {
          data: ['Buy fills', 'Sell fills'],
          textStyle: { color: '#475569' }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b' },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Buy fills',
            type: 'bar',
            barGap: '30%',
            barCategoryGap: '40%',
            itemStyle: { color: '#0f766e' },
            data: buyCounts
          },
          {
            name: 'Sell fills',
            type: 'bar',
            barGap: '30%',
            barCategoryGap: '40%',
            itemStyle: { color: '#dc2626' },
            data: sellCounts
          }
        ]
      }, true);
    }

    function updatePriceDistributionToggle() {
      const toggle = document.getElementById('priceFillToggle');
      if (!toggle) return;
      toggle.querySelectorAll('button[data-view]').forEach(btn => {
        const view = btn.getAttribute('data-view');
        const active = view === PRICE_DISTRIBUTION_VIEW;
        btn.setAttribute('aria-pressed', active ? 'true' : 'false');
        btn.classList.toggle('text-white', active);
        btn.classList.toggle('text-slate-600', !active);
        btn.classList.toggle('bg-emerald-600', active && view === 'buy');
        btn.classList.toggle('bg-rose-600', active && view === 'sell');
        btn.classList.toggle('bg-transparent', !active);
      });
    }

    function setPriceDistributionView(view) {
      const next = view === 'sell' ? 'sell' : 'buy';
      if (PRICE_DISTRIBUTION_VIEW === next) return;
      PRICE_DISTRIBUTION_VIEW = next;
      updatePriceDistributionToggle();
      renderPriceDistributionChart(GRID_STATE.trades || []);
    }

    function computePriceFillCounts(trades) {
      const source = Array.isArray(trades) ? trades : [];
      const precision = getActivePricePrecision();
      const buyMap = new Map();
      const sellMap = new Map();
      const addPrice = (map, value) => {
        const rounded = roundToPrecision(value, precision);
        if (!Number.isFinite(rounded)) return;
        map.set(rounded, (map.get(rounded) || 0) + 1);
      };
      for (const trade of source) {
        const buyPrice = Number(trade?.buyPrice);
        const sellPrice = Number(trade?.sellPrice);
        if (Number.isFinite(buyPrice)) addPrice(buyMap, buyPrice);
        if (Number.isFinite(sellPrice)) addPrice(sellMap, sellPrice);
      }
      const toEntries = (map) => {
        const entries = Array.from(map.entries()).map(([price, count]) => ({ price, count }));
        entries.sort((a, b) => a.price - b.price);
        return entries;
      };
      return {
        buyEntries: toEntries(buyMap),
        sellEntries: toEntries(sellMap),
        precision
      };
    }

    function renderPriceDistributionChart(trades) {
      const container = document.getElementById('priceDistributionChart');
      const emptyState = document.getElementById('priceDistributionEmpty');
      const label = document.getElementById('priceDistributionLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!priceDistributionChartInst) {
        priceDistributionChartInst = echarts.init(container);
      }
      updatePriceDistributionToggle();
      const { buyEntries, sellEntries, precision } = computePriceFillCounts(trades);
      const totalBuys = buyEntries.reduce((sum, entry) => sum + entry.count, 0);
      const totalSells = sellEntries.reduce((sum, entry) => sum + entry.count, 0);
      const hasAny = totalBuys + totalSells > 0;
      if (label) {
        if (hasAny) {
          const buyLabel = `${totalBuys.toLocaleString()} buy fill${totalBuys === 1 ? '' : 's'}`;
          const sellLabel = `${totalSells.toLocaleString()} sell fill${totalSells === 1 ? '' : 's'}`;
          label.textContent = `${buyLabel} · ${sellLabel}`;
        } else {
          label.textContent = '';
        }
      }
      const view = PRICE_DISTRIBUTION_VIEW === 'sell' ? 'sell' : 'buy';
      const entries = view === 'sell' ? sellEntries : buyEntries;
      if (!entries.length) {
        priceDistributionChartInst.clear();
        if (emptyState) {
          if (hasAny) {
            emptyState.textContent = view === 'sell'
              ? 'No sell fills to chart for this run.'
              : 'No buy fills to chart for this run.';
          } else {
            emptyState.textContent = view === 'sell'
              ? 'Run the backtest to chart sell fill counts by price.'
              : 'Run the backtest to chart buy fill counts by price.';
          }
          emptyState.classList.remove('hidden');
        }
        return;
      }
      if (emptyState) emptyState.classList.add('hidden');
      const categories = entries.map(entry => `$${formatPrice(entry.price, precision)}`);
      const values = entries.map(entry => entry.count);
      const seriesName = view === 'sell' ? 'Sell fills' : 'Buy fills';
      const barColor = view === 'sell' ? '#dc2626' : '#0f766e';
      priceDistributionChartInst.setOption({
        color: [barColor],
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'shadow' },
          formatter: (params) => {
            if (!Array.isArray(params) || !params.length) return '';
            const item = params[0];
            const value = Number(item?.value) || 0;
            return `${item?.name || 'Price'}<br/>${seriesName}: ${value.toLocaleString()}`;
          }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b' },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: seriesName,
            type: 'bar',
            barCategoryGap: '35%',
            itemStyle: { color: barColor },
            data: values
          }
        ]
      }, true);
    }

    function computeLevelFillCounts(trades) {
      const source = Array.isArray(trades) ? trades : [];
      const counts = new Map();
      for (const trade of source) {
        const level = Number(trade?.openLevels);
        if (!Number.isFinite(level) || level <= 0) continue;
        counts.set(level, (counts.get(level) || 0) + 1);
      }
      const entries = Array.from(counts.entries()).map(([level, count]) => ({ level, count }));
      entries.sort((a, b) => a.level - b.level);
      const total = entries.reduce((sum, entry) => sum + entry.count, 0);
      return { entries, total };
    }

    function renderLevelDistributionChart(trades) {
      const container = document.getElementById('levelDistributionChart');
      const emptyState = document.getElementById('levelDistributionEmpty');
      const label = document.getElementById('levelDistributionLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!levelDistributionChartInst) {
        levelDistributionChartInst = echarts.init(container);
      }
      const { entries, total } = computeLevelFillCounts(trades);
      if (!entries.length) {
        levelDistributionChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      const categories = entries.map(entry => `Level ${entry.level}`);
      const values = entries.map(entry => entry.count);
      const totalSells = total;
      if (label) {
        label.textContent = `${totalSells.toLocaleString()} sell fills across ${entries.length} level${entries.length === 1 ? '' : 's'}`;
      }
      if (emptyState) emptyState.classList.add('hidden');
      levelDistributionChartInst.setOption({
        color: ['#6366f1'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'shadow' },
          formatter: (params) => {
            if (!params || !params.length) return '';
            const item = params[0];
            const value = Number(item?.value) || 0;
            return `${item?.name || 'Level'}<br/>Sell fills: ${value.toLocaleString()}`;
          }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b' },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          minInterval: 1,
          axisLabel: { color: '#64748b' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Sell fills',
            type: 'bar',
            barCategoryGap: '35%',
            itemStyle: { color: '#6366f1' },
            data: values
          }
        ]
      }, true);
    }

    function renderCumulativeLevelDistributionChart(trades) {
      const container = document.getElementById('cumulativeLevelDistributionChart');
      const emptyState = document.getElementById('cumulativeLevelDistributionEmpty');
      const label = document.getElementById('cumulativeLevelDistributionLabel');
      if (!container) return;
      if (typeof echarts === 'undefined' || !echarts.init) return;
      if (!cumulativeLevelDistributionChartInst) {
        cumulativeLevelDistributionChartInst = echarts.init(container);
      }
      const { entries, total } = computeLevelFillCounts(trades);
      if (!entries.length || !total) {
        cumulativeLevelDistributionChartInst.clear();
        if (emptyState) emptyState.classList.remove('hidden');
        if (label) label.textContent = '';
        return;
      }
      let running = 0;
      const cumulative = entries.map(entry => {
        running += entry.count;
        const pct = total > 0 ? (running / total) * 100 : 0;
        return { ...entry, running, pct };
      });
      const categories = cumulative.map(entry => `Level ${entry.level}`);
      const pctValues = cumulative.map(entry => Number(entry.pct.toFixed(2)));
      const findThresholdLevel = (thresholdPct) => {
        const hit = cumulative.find(entry => entry.pct >= thresholdPct);
        return hit ? hit.level : null;
      };
      const p50Level = findThresholdLevel(50);
      const p75Level = findThresholdLevel(75);
      const labelParts = [`${total.toLocaleString()} sell fill${total === 1 ? '' : 's'}`];
      labelParts.push(`${entries.length.toLocaleString()} level${entries.length === 1 ? '' : 's'}`);
      if (p50Level != null) labelParts.push(`50% reached by level ${p50Level}`);
      if (p75Level != null) labelParts.push(`75% by level ${p75Level}`);
      if (label) label.textContent = labelParts.join(' · ');
      if (emptyState) emptyState.classList.add('hidden');
      const tooltipFormatter = (params) => {
        if (!Array.isArray(params) || !params.length) return '';
        const idx = Number(params[0]?.dataIndex);
        const entry = Number.isInteger(idx) && idx >= 0 ? cumulative[idx] : null;
        if (!entry) return '';
        const pctLabel = formatNumber(entry.pct, 2);
        return `
          <div class="text-xs">
            <div class="font-semibold">${params[0]?.name || 'Level'}</div>
            <div>Level fills: ${entry.count.toLocaleString()}</div>
            <div>Cumulative: ${entry.running.toLocaleString()} (${pctLabel}%)</div>
          </div>
        `;
      };
      cumulativeLevelDistributionChartInst.setOption({
        color: ['#0ea5e9'],
        grid: { left: '3%', right: '3%', top: 40, bottom: 40, containLabel: true },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'line' },
          formatter: tooltipFormatter
        },
        legend: {
          data: ['Cumulative % of Sell Fills'],
          textStyle: { color: '#475569' }
        },
        xAxis: {
          type: 'category',
          data: categories,
          axisLabel: { color: '#64748b' },
          axisTick: { alignWithLabel: true }
        },
        yAxis: {
          type: 'value',
          min: 0,
          max: 100,
          axisLabel: {
            color: '#64748b',
            formatter: (val) => `${val.toFixed(0)}%`
          },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 184, 0.2)' } }
        },
        series: [
          {
            name: 'Cumulative % of Sell Fills',
            type: 'line',
            smooth: true,
            symbol: 'circle',
            symbolSize: 6,
            lineStyle: { width: 2 },
            areaStyle: { color: 'rgba(14, 165, 233, 0.12)' },
            markLine: {
              symbol: 'none',
              lineStyle: { color: 'rgba(100, 116, 139, 0.5)', type: 'dashed' },
              label: { color: '#475569', formatter: (params) => `${params.value}%` },
              data: [
                { yAxis: 50, name: '50%' },
                { yAxis: 75, name: '75%' }
              ]
            },
            data: pctValues
          }
        ]
      }, true);
    }

    function highlightTickerButton(symbol) {
      const seg = document.getElementById('tickerSegment');
      if (!seg) return;
      const upper = (symbol || '').toUpperCase();
      seg.querySelectorAll('button[data-symbol]').forEach(btn => {
        const active = (btn.getAttribute('data-symbol') || '').toUpperCase() === upper;
        btn.classList.toggle('bg-emerald-600', active);
        btn.classList.toggle('text-white', active);
        btn.classList.toggle('hover:bg-emerald-600', active);
        btn.classList.toggle('bg-white', !active);
        btn.classList.toggle('hover:bg-emerald-50', !active);
        const nameSpan = btn.querySelector('[data-symbol-name]');
        if (nameSpan) {
          nameSpan.classList.toggle('text-emerald-100', active);
          nameSpan.classList.toggle('text-slate-500', !active);
        }
      });
    }

    function renderDataSummary() {
      const summaryEl = document.getElementById('dataSummary');
      if (!summaryEl) return;
      if (!currentTicker) {
        summaryEl.textContent = 'Select a symbol to load intraday data.';
        return;
      }
      if (!ROWS.length) {
        summaryEl.innerHTML = `<span class="font-semibold">${currentTicker}</span> selected. Choose another symbol or verify data files exist in the <code>data/</code> folder.`;
        return;
      }
      const firstDay = DAYS[0];
      const lastDay = DAYS[DAYS.length - 1];
      summaryEl.innerHTML = `
        <span class="font-semibold">${currentTicker}</span> loaded
        <span class="font-medium">${ROWS.length.toLocaleString()}</span> bars across
        <span class="font-medium">${DAYS.length.toLocaleString()}</span> trading day(s)
        (${firstDay || 'n/a'} → ${lastDay || 'n/a'}).
      `;
    }

    function setTicker(sym) {
      currentTicker = (sym || '').toUpperCase();
      const titleEl = document.getElementById('mainTitle');
      const meta = ensureSymbolMetaEntry(currentTicker);
      const friendlyName = meta && meta.name && meta.name.toUpperCase() !== currentTicker ? ` · ${meta.name}` : '';
      const fullTitle = currentTicker ? `${currentTicker}${friendlyName} - Buy-the-Dip Grid Backtest` : 'Buy-the-Dip Grid Backtest';
      if (titleEl) titleEl.textContent = fullTitle;
      document.title = fullTitle;
      highlightTickerButton(currentTicker);
      updateBasePriceInput(currentTicker);
      const loadingMsg = currentTicker ? `Loading data for ${currentTicker}…` : 'Load data and run the backtest to populate results.';
      resetGridOutputs(loadingMsg);
      setRunButtonEnabled(false);
      renderDataSummary();
    }

    function resetGridOutputs(message) {
      GRID_STATE = { trades: [], summary: null, equitySeries: [], ladderHistory: [], buyLevels: [], sellLevels: [], baseLevel: null, gridLevels: [] };
      renderGridSummary(null);
      renderGridTrades([], { resetPage: true });
      setGridStatus(message || 'Load data and run the backtest to populate results.');
      setSaveButtonEnabled(false);
      renderGridEquityChart(null);
      renderLadderChart([]);
      renderFillsPerDayChart([]);
      renderOpenLevelsChart([]);
      renderFillsPerMonthChart([]);
      renderPriceDistributionChart([]);
      renderLevelDistributionChart([]);
      renderCumulativeLevelDistributionChart([]);
      renderGridLevels([], [], null);
      buildMonthFilterOptions();
    }

    function applyResamplingFromBase() {
      if (!Array.isArray(BASE_ROWS) || !BASE_ROWS.length) {
        ROWS = [];
        DAY_GROUPS = new Map();
        DAYS = [];
        buildMonthFilterOptions();
        return;
      }
      ROWS = resampleIntradayRows(BASE_ROWS, RESAMPLE_INTERVAL_MINUTES);
      DAY_GROUPS = new Map();
      for (const row of ROWS) {
        if (!DAY_GROUPS.has(row.dayKey)) DAY_GROUPS.set(row.dayKey, []);
        DAY_GROUPS.get(row.dayKey).push(row);
      }
      for (const [, arr] of DAY_GROUPS.entries()) arr.sort((a, b) => a.caldt - b.caldt);
      DAYS = Array.from(DAY_GROUPS.keys()).sort();
      computeDailySmaMaps();
      buildMonthFilterOptions();
    }

    function normalizeAndIndex(rows) {
      if (!rows || !rows.length) {
        BASE_ROWS = [];
        applyResamplingFromBase();
        return;
      }
      const required = ['caldt', 'day', 'open', 'high', 'low', 'close'];
      const missing = required.filter(c => !(c in rows[0]));
      if (missing.length) throw new Error('Missing columns: ' + missing.join(', '));

      const cleanRows = rows.map(r => {
        const caldt = new Date(r.caldt);
        const dayKey = dateKeyFromStr(r.day);
        const open = Number(r.open), high = Number(r.high), low = Number(r.low), close = Number(r.close);
        if (!dayKey || isNaN(caldt)) return null;
        if ([open, high, low, close].some(v => !Number.isFinite(v))) return null;
        return { caldt, dayKey, open, high, low, close, sma10: null, sma20: null, sma50: null, sma100: null };
      }).filter(Boolean);
      cleanRows.sort((a, b) => a.caldt - b.caldt);
      BASE_ROWS = cleanRows;
      applyResamplingFromBase();
    }

    function resampleIntradayRows(rows, minutes) {
      if (!Array.isArray(rows) || !rows.length) return [];
      const interval = Number(minutes);
      if (!Number.isFinite(interval) || interval <= 1) {
        return [...rows];
      }
      const intervalMs = Math.max(1, Math.floor(interval)) * 60000;
      const aggregated = [];
      let current = null;

      const flush = () => {
        if (!current) return;
        const caldt = current.lastTimeMs != null ? new Date(current.lastTimeMs) : new Date(current.bucketStartMs);
        aggregated.push({
          caldt,
          dayKey: current.dayKey,
          open: current.open,
          high: current.high,
          low: current.low,
          close: current.close,
          sma10: null,
          sma20: null,
          sma50: null,
          sma100: null
        });
        current = null;
      };

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const timeMs = row.caldt.getTime();
        const bucketStartMs = Math.floor(timeMs / intervalMs) * intervalMs;
        if (!current || current.dayKey !== row.dayKey || current.bucketStartMs !== bucketStartMs) {
          flush();
          current = {
            dayKey: row.dayKey,
            bucketStartMs,
            open: row.open,
            high: row.high,
            low: row.low,
            close: row.close,
            lastTimeMs: timeMs
          };
          continue;
        }
        if (row.high > current.high) current.high = row.high;
        if (row.low < current.low) current.low = row.low;
        current.close = row.close;
        current.lastTimeMs = timeMs;
      }
      flush();
      aggregated.sort((a, b) => a.caldt - b.caldt);
      return aggregated;
    }

    function computeDailySmaMaps() {
      DAY_SMA_MAPS = new Map();
      SMA_METADATA = new Map();
      if (!Array.isArray(DAYS) || !DAYS.length) return;
      const windows = Array.isArray(DAILY_SMA_WINDOWS) && DAILY_SMA_WINDOWS.length ? DAILY_SMA_WINDOWS : [];
      if (!windows.length) return;
      windows.forEach(win => DAY_SMA_MAPS.set(win, new Map()));
      const dailyCloses = [];
      for (const dayKey of DAYS) {
        const rows = DAY_GROUPS.get(dayKey);
        if (!Array.isArray(rows) || !rows.length) continue;
        const lastRow = rows[rows.length - 1];
        if (!lastRow) continue;
        const close = Number(lastRow.close);
        if (!Number.isFinite(close)) continue;
        dailyCloses.push({ dayKey, close });
      }
      for (const window of windows) {
        const target = DAY_SMA_MAPS.get(window);
        if (!target) continue;
        let firstIdx = null;
        for (let i = 0; i < dailyCloses.length; i++) {
          if (i + 1 < window) continue;
          let sum = 0;
          for (let j = i - window + 1; j <= i; j++) {
            sum += dailyCloses[j].close;
          }
          const avg = sum / window;
          target.set(dailyCloses[i].dayKey, avg);
          if (firstIdx == null) firstIdx = i;
        }
        const totalDays = dailyCloses.length;
        const availableDays = firstIdx == null ? 0 : (totalDays - firstIdx);
        SMA_METADATA.set(window, {
          totalDays,
          availableDays,
          firstDay: firstIdx != null ? dailyCloses[firstIdx].dayKey : null,
          required: window
        });
      }
      for (const row of ROWS) {
        if (!row) continue;
        const dayKey = row.dayKey;
        for (const prop of SMA_PROPERTIES) {
          row[prop] = null;
        }
        for (const window of windows) {
          const map = DAY_SMA_MAPS.get(window);
          if (!map) continue;
          const value = map.get(dayKey);
          const prop = SMA_PROPERTY_BY_WINDOW[window];
          if (prop) row[prop] = Number.isFinite(value) ? value : null;
        }
      }
    }

    function collectOrdersInRange(map, minVal, maxVal, ascending) {
      const out = [];
      if (!map || !map.size) return out;
      const lower = Math.min(minVal, maxVal);
      const upper = Math.max(minVal, maxVal);
      for (const arr of map.values()) {
        if (!Array.isArray(arr) || !arr.length) continue;
        for (const order of arr) {
          if (!order || !Number.isFinite(order.level)) continue;
          const tolerance = 1e-9 * Math.max(1, Math.abs(order.level), Math.abs(lower), Math.abs(upper));
          if (order.level >= (lower - tolerance) && order.level <= (upper + tolerance)) {
            out.push(order);
          }
        }
      }
      out.sort((a, b) => ascending ? (a.level - b.level) : (b.level - a.level));
      return out;
    }

    function runPullbackGridSimulation(rows, params) {
      const trades = [];
      const equitySeries = [];
      const ladderHistory = [];
      const mode = (params?.gridType || 'pullback').toLowerCase();
      if (mode === 'progressive') {
        return runProgressiveGrid(rows, params);
      }

      const athResetMode = mode === 'grid_ath_reset';
      const summary = {
        totalTrades: 0,
        netProfit: 0,
        profitPerLevel: 0,
        finalEquity: 0,
        totalRetainedShares: 0,
        cash: 0,
        minCash: 0,
        shares: 0,
        maxDrawdown: 0,
        maxSharesHeld: 0,
        maxOpenLevels: 0,
        maxDeployedCapital: 0,
        athResetCount: 0,
        cagr: 0
      };
      const buyLevelSet = new Set();
      const sellLevelSet = new Set();
      let gridLevels = [];
      let resolveBaseLevel = () => NaN;
      const finalizeResult = () => ({
        trades,
        summary,
        equitySeries,
        ladderHistory,
        buyLevels: Array.from(buyLevelSet).sort((a, b) => b - a),
        sellLevels: Array.from(sellLevelSet).sort((a, b) => a - b),
        gridLevels: Array.isArray(gridLevels) ? gridLevels : [],
        baseLevel: (() => {
          const val = resolveBaseLevel();
          return Number.isFinite(val) ? val : null;
        })()
      });
      if (!Array.isArray(rows) || !rows.length) {
        return finalizeResult();
      }
      const rawGridSize = Number(params?.gridSize);
      const rawBasePrice = Number(params?.basePrice);
      const gridSpacingType = (params?.gridSpacingType || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const tradeValue = Number(params?.tradeValue);
      const tickSize = Number(params?.tickSize);
      const resolvedTickSize = Number.isFinite(tickSize) && tickSize > 0 ? tickSize : 0.01;
      const fractional = !!params?.fractionalShares;
      const retentionMode = (params?.retentionMode || 'profit').toLowerCase();
      const entryFilter = (params?.entryFilter || 'none').toLowerCase();
      if (!Number.isFinite(rawGridSize) || rawGridSize <= 0 || !Number.isFinite(tradeValue) || tradeValue <= 0) {
        return finalizeResult();
      }
      let firstPrice = [rows[0]?.open, rows[0]?.close, rows[0]?.high, rows[0]?.low].map(Number).find(Number.isFinite);
      if (!Number.isFinite(firstPrice) || firstPrice <= 0) {
        return finalizeResult();
      }
      const basePrice = Number.isFinite(rawBasePrice) && rawBasePrice > 0 ? rawBasePrice : firstPrice;
      let minPrice = firstPrice;
      let maxPrice = firstPrice;
      for (const row of rows) {
        if (!row) continue;
        const low = Number(row.low);
        const high = Number(row.high);
        if (Number.isFinite(low)) minPrice = Math.min(minPrice, low);
        if (Number.isFinite(high)) maxPrice = Math.max(maxPrice, high);
      }
      if (!Number.isFinite(minPrice) || !Number.isFinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) {
        return finalizeResult();
      }

      const spacing = createGridSpacingHelpers({
        spacingType: gridSpacingType,
        gridSize: rawGridSize,
        basePrice,
        firstPrice,
        minPrice,
        maxPrice,
        tickSize: resolvedTickSize
      });
      if (spacing.error) {
        console.warn('Grid spacing configuration invalid:', spacing.error);
        return finalizeResult();
      }
      gridLevels = Array.isArray(spacing.gridLevels) ? spacing.gridLevels : [];
      gridLevels = Array.isArray(spacing.gridLevels) ? spacing.gridLevels : [];
      const snapLevel = spacing.snap;
      const keyFor = spacing.key;
      const nextUpLevel = spacing.nextUp;
      const nextDownLevel = spacing.nextDown;
      const stepsBetween = spacing.stepsBetween;
      const priceTolerance = spacing.priceTolerance ?? 1e-9;
      const usePercentSpacing = spacing.type === 'percent';
      const shouldRatchetUp = usePercentSpacing && spacing.anchorMode === 'ratchet_up' && typeof spacing.setAnchor === 'function' && typeof spacing.getAnchor === 'function';
      const refreshOrderRungs = () => {
        activeBuys.forEach(arr => {
          if (!Array.isArray(arr)) return;
          arr.forEach(order => {
            if (order) order.rungIndex = computeRungIndex(order.level);
          });
        });
        activeSells.forEach(arr => {
          if (!Array.isArray(arr)) return;
          arr.forEach(order => {
            if (order) order.buyRung = computeRungIndex(order.buyPrice);
          });
        });
      };
      const ratchetAnchorIfNeeded = (candidate) => {
        if (!shouldRatchetUp || !Number.isFinite(candidate)) return;
        const currentAnchor = spacing.getAnchor && spacing.getAnchor();
        if (!Number.isFinite(currentAnchor)) return;
        const tolerance = priceTolerance * Math.max(1, candidate);
        if (candidate <= currentAnchor + tolerance) return;
        const snapped = snapLevel(candidate);
        spacing.setAnchor(snapped);
        if (Number.isFinite(highestSeededBuyLevel)) {
          highestSeededBuyLevel = snapLevel(highestSeededBuyLevel);
        }
        refreshOrderRungs();
      };
      const initialBaseLevel = snapLevel(basePrice);
      resolveBaseLevel = () => {
        if (usePercentSpacing && typeof spacing.getAnchor === 'function') {
          const anchor = spacing.getAnchor();
          if (Number.isFinite(anchor)) return anchor;
        }
        return initialBaseLevel;
      };
      const currentBaseLevel = () => {
        if (usePercentSpacing && typeof spacing.getAnchor === 'function') {
          const anchor = spacing.getAnchor();
          if (Number.isFinite(anchor)) return anchor;
        }
        return initialBaseLevel;
      };
      const computeRungIndex = (level) => {
        const anchor = currentBaseLevel();
        if (!Number.isFinite(level) || !Number.isFinite(anchor)) return 0;
        const diff = stepsBetween(anchor, level);
        if (!Number.isFinite(diff)) return 0;
        return Math.round(diff);
      };

      const activeBuys = new Map();
      const activeSells = new Map();
      const queuedBuyActivations = [];
      let orderSeq = 1;
      let highestSeededBuyLevel = Number.NEGATIVE_INFINITY;

      const removeOrder = (map, order) => {
        if (!order || !Number.isFinite(order.level)) return;
        const key = keyFor(order.level);
        const arr = map.get(key);
        if (!arr) return;
        const idx = arr.indexOf(order);
        if (idx >= 0) arr.splice(idx, 1);
        if (!arr.length) map.delete(key);
      };

      const addBuyOrder = (level) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price) || price <= 0) return null;
        buyLevelSet.add(price);
        const key = keyFor(price);
        const existing = activeBuys.get(key);
        if (existing && existing.length) return existing[0];
        const order = { id: orderSeq++, level: price, rungIndex: computeRungIndex(price) };
        activeBuys.set(key, [order]);
        if (!Number.isFinite(highestSeededBuyLevel) || price > highestSeededBuyLevel) {
          highestSeededBuyLevel = price;
        }
        return order;
      };

      const addSellOrder = (level, buyInfo) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price) || price <= 0) return null;
        sellLevelSet.add(price);
        const key = keyFor(price);
        if (!activeSells.has(key)) activeSells.set(key, []);
        const order = {
          id: orderSeq++,
          level: price,
          buyPrice: Number(buyInfo?.price),
          buyQty: Number(buyInfo?.qty),
          buyTime: buyInfo?.time instanceof Date ? new Date(buyInfo.time.getTime()) : new Date(),
          buyRung: Number.isFinite(buyInfo?.rungIndex) ? buyInfo.rungIndex : computeRungIndex(price)
        };
        activeSells.get(key).push(order);
        return order;
      };

      const applyBaseAnchor = (basePrice) => {
        if (!usePercentSpacing || typeof spacing.setAnchor !== 'function') return;
        const snapped = snapLevel(basePrice);
        if (Number.isFinite(snapped) && snapped > 0) {
          spacing.setAnchor(snapped);
        }
      };

      const seedDownLadderFromBase = (basePrice) => {
        const snappedBase = snapLevel(basePrice);
        if (!Number.isFinite(snappedBase) || snappedBase <= 0) return;
        let level = nextDownLevel(snappedBase);
        let safety = 0;
        const coverageFloor = Math.max(minPrice, priceTolerance);
        while (
          Number.isFinite(level) &&
          level > 0 &&
          level >= coverageFloor - priceTolerance * Math.max(1, level) &&
          safety < 5000
        ) {
          addBuyOrder(level);
          const nextLevel = nextDownLevel(level);
          if (!Number.isFinite(nextLevel) || Math.abs(nextLevel - level) <= priceTolerance * Math.max(1, level)) break;
          level = nextLevel;
          safety += 1;
        }
        if (!Number.isFinite(highestSeededBuyLevel) || highestSeededBuyLevel === Number.NEGATIVE_INFINITY) {
          const fallback = nextDownLevel(snappedBase);
          if (Number.isFinite(fallback) && fallback > 0) {
            const order = addBuyOrder(fallback);
            if (order) highestSeededBuyLevel = order.level;
          }
        }
      };

      applyBaseAnchor(basePrice);
      seedDownLadderFromBase(basePrice);

      let cash = 0;
      let minCashBalance = cash;
      const initialEquity = cash;
      let fundedLevels = 0;
      let openPositions = 0;
      const firstEquityTime = rows[0]?.caldt instanceof Date ? new Date(rows[0].caldt.getTime()) : null;
      let lastEquityTime = firstEquityTime;
      let shares = 0;
      let realizedProfit = 0;
      let cumulativeRetained = 0;
      let prevPrice = firstPrice;
      let peakEquity = cash + shares * firstPrice;
      let maxDrawdown = 0;
      let maxDrawdownPct = 0;
      let maxSharesHeld = shares;

      const hasActiveBuy = (level) => {
        const price = snapLevel(level);
        const key = keyFor(price);
        const arr = activeBuys.get(key);
        return Array.isArray(arr) && arr.length > 0;
      };

      const hasQueuedBuyActivation = (level) => {
        const price = snapLevel(level);
        if (!Number.isFinite(price)) return false;
        return queuedBuyActivations.some(entry => {
          const diff = Math.abs(entry.buyLevel - price);
          return diff <= priceTolerance * Math.max(1, entry.buyLevel);
        });
      };

      const queueDelayedBuy = (sellPrice) => {
        const buyPrice = snapLevel(sellPrice);
        if (!Number.isFinite(buyPrice) || buyPrice <= 0) return;
        if (hasActiveBuy(buyPrice) || hasQueuedBuyActivation(buyPrice)) return;
        const triggerLevel = nextUpLevel(buyPrice);
        if (!Number.isFinite(triggerLevel) || triggerLevel <= 0) return;
        if (Math.abs(triggerLevel - buyPrice) <= priceTolerance * Math.max(1, triggerLevel)) return;
        queuedBuyActivations.push({ buyLevel: buyPrice, trigger: triggerLevel });
      };

      const ensureRunupBuys = (maxPrice) => {
        if (!Number.isFinite(maxPrice)) return;
        if (!Number.isFinite(highestSeededBuyLevel)) return;
        let safety = 0;
        while (stepsBetween(highestSeededBuyLevel, Math.max(maxPrice, highestSeededBuyLevel)) >= 2 - 1e-9 && safety < 1000) {
          const nextLevel = nextUpLevel(highestSeededBuyLevel);
          if (!Number.isFinite(nextLevel) || nextLevel <= 0) break;
          if (!hasActiveBuy(nextLevel) && !hasQueuedBuyActivation(nextLevel)) {
            addBuyOrder(nextLevel);
          }
          if (Math.abs(nextLevel - highestSeededBuyLevel) <= priceTolerance * Math.max(1, nextLevel)) break;
          highestSeededBuyLevel = nextLevel;
          safety += 1;
        }
        ratchetAnchorIfNeeded(Math.max(maxPrice, highestSeededBuyLevel));
      };

      const activateQueuedBuys = (maxPrice) => {
        if (!Number.isFinite(maxPrice) || !queuedBuyActivations.length) return;
        for (let i = queuedBuyActivations.length - 1; i >= 0; i--) {
          const entry = queuedBuyActivations[i];
          if (!entry) continue;
          const tolerance = priceTolerance * Math.max(1, entry.trigger);
          if (maxPrice >= entry.trigger - tolerance) {
            addBuyOrder(entry.buyLevel);
            queuedBuyActivations.splice(i, 1);
          }
        }
      };

      const hasActiveSellOrders = () => {
        for (const arr of activeSells.values()) {
          if (Array.isArray(arr) && arr.length) return true;
        }
        return false;
      };

      const clearLadderState = () => {
        activeBuys.clear();
        activeSells.clear();
        queuedBuyActivations.length = 0;
        buyLevelSet.clear();
        sellLevelSet.clear();
        highestSeededBuyLevel = Number.NEGATIVE_INFINITY;
      };

      const rebuildLadderAtBase = (basePrice, timestamp) => {
        clearLadderState();
        applyBaseAnchor(basePrice);
        seedDownLadderFromBase(basePrice);
        summary.athResetCount += 1;
        ladderHistory.push({
          time: timestamp instanceof Date ? new Date(timestamp.getTime()) : (lastEquityTime ? new Date(lastEquityTime.getTime()) : new Date()),
          buys: activeBuys.size,
          sells: activeSells.size,
          queued: queuedBuyActivations.length
        });
      };

      let runningAth = firstPrice;
      const maybeTriggerAthReset = (price, timestamp) => {
        if (!athResetMode) return;
        if (!Number.isFinite(price)) return;
        const tolerance = priceTolerance * Math.max(1, price);
        if (price > runningAth + tolerance) {
          runningAth = price;
          if (!hasActiveSellOrders() && Math.abs(shares) <= 1e-8) {
            rebuildLadderAtBase(price, timestamp);
          }
        }
      };

      const executeBuy = (order, timestamp, contextRow) => {
        if (!order) return false;
        const price = order.level;
        if (!passesEntryFilter(price, contextRow, entryFilter)) {
          return false;
        }
        const qtyRaw = tradeValue / price;
        let qty = fractional ? qtyRaw : Math.floor(qtyRaw);
        if (!Number.isFinite(qty) || qty <= 0) {
          removeOrder(activeBuys, order);
          return false;
        }
        const neededPositions = openPositions + 1;
        if (neededPositions > fundedLevels) {
          const levelsToAdd = neededPositions - fundedLevels;
          cash += levelsToAdd * tradeValue;
          fundedLevels += levelsToAdd;
          const deployed = fundedLevels * tradeValue;
          if (deployed > summary.maxDeployedCapital) {
            summary.maxDeployedCapital = deployed;
          }
        }
        const cost = qty * price;
        cash -= cost;
        if (cash < minCashBalance) minCashBalance = cash;
        shares += qty;
        if (shares > maxSharesHeld) maxSharesHeld = shares;
        openPositions += 1;
        if (openPositions > summary.maxOpenLevels) summary.maxOpenLevels = openPositions;
        removeOrder(activeBuys, order);
        const sellLevel = nextUpLevel(price);
        if (Number.isFinite(sellLevel) && sellLevel > 0) {
          addSellOrder(sellLevel, { price, qty, time: timestamp, rungIndex: Number.isFinite(order?.rungIndex) ? order.rungIndex : computeRungIndex(price) });
        }
        return true;
      };

      const executeSell = (order, timestamp) => {
        if (!order) return false;
        const price = order.level;
        const openQty = shares;
        const desiredRaw = tradeValue / price;
        let desired = fractional ? desiredRaw : Math.floor(desiredRaw);
        const exec = computeSellExecution({
          baseQty: order.buyQty,
          desiredQty: desired,
          sharesAvailable: shares,
          mode: retentionMode,
          fractional
        });
        let qty = exec.qty;
        if (!Number.isFinite(qty) || qty <= 0) {
          removeOrder(activeSells, order);
          return false;
        }
        const revenue = qty * price;
        const costBasis = qty * order.buyPrice;
        cash += revenue;
        shares -= qty;
        if (openPositions > 0) openPositions -= 1;
        removeOrder(activeSells, order);
        const profit = revenue - costBasis;
        realizedProfit += profit;
        const qtyRetained = Math.max(0, exec.retained);
        cumulativeRetained += qtyRetained;
        const closeQty = shares;
        const closeEquity = cash + shares * price;
        const totalContributed = Math.max(0, openPositions) * tradeValue;
        const runningPnl = closeEquity - totalContributed;
        const nextPeak = Math.max(peakEquity, closeEquity);
        const drawdown = closeEquity - nextPeak;
        peakEquity = nextPeak;
        const sellTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const buyTime = order.buyTime instanceof Date ? new Date(order.buyTime.getTime()) : new Date();
        const msHeld = sellTime.getTime() - buyTime.getTime();
        const daysHeld = Number.isFinite(msHeld) ? Math.max(0, msHeld / 86400000) : 0;
        const openTradesCount = Array.from(activeSells.values()).reduce((acc, arr) => acc + (Array.isArray(arr) ? arr.length : 0), 0);
        const openLevelSnapshot = openTradesCount + 1;
        if (openLevelSnapshot > summary.maxOpenLevels) {
          summary.maxOpenLevels = openLevelSnapshot;
        }
        const openEquity = openLevelSnapshot * tradeValue;
        trades.push({
          buyTime,
          buyPrice: order.buyPrice,
          buyQty: order.buyQty,
          gridLevel: Number.isFinite(order.buyRung) ? order.buyRung : computeRungIndex(order.buyPrice),
          openLevels: openLevelSnapshot,
          openQty,
          openEquity,
          sellTime,
          sellPrice: price,
          sellQty: qty,
          closeQty,
          closeEquity,
          qtyRetained,
          cumQtyRetained: cumulativeRetained,
          daysHeld,
          profit,
          cumProfit: realizedProfit,
          runningPnl,
          drawdown,
          roiPct: costBasis > 0 ? (profit / costBasis) * 100 : 0
        });
        const buyLevel = nextDownLevel(price);
        if (Number.isFinite(buyLevel) && buyLevel > 0) {
          addBuyOrder(buyLevel);
        }
        queueDelayedBuy(price);
        return true;
      };

      const processMove = (start, end, timestamp, contextRow) => {
        if (!Number.isFinite(start) || !Number.isFinite(end)) return;
        const scale = Math.max(1, Math.abs(start), Math.abs(end));
        const threshold = priceTolerance * scale;
        if (end > start + threshold) {
          const sells = collectOrdersInRange(activeSells, start, end, true);
          for (const order of sells) executeSell(order, timestamp);
        } else if (end < start - threshold) {
          const buys = collectOrdersInRange(activeBuys, end, start, false);
          for (const order of buys) executeBuy(order, timestamp, contextRow);
        }
        const maxVal = Math.max(start, end);
        ensureRunupBuys(maxVal);
        activateQueuedBuys(maxVal);
        ratchetAnchorIfNeeded(maxVal);
        maybeTriggerAthReset(maxVal, timestamp);
        if (timestamp instanceof Date) {
          ladderHistory.push({
            time: new Date(timestamp.getTime()),
            buys: activeBuys.size,
            sells: activeSells.size,
            queued: queuedBuyActivations.length
          });
        }
      };

      const buildPath = (fromPrice, row) => {
        const path = [];
        let start = Number(fromPrice);
        if (!Number.isFinite(start)) start = Number(row.open) || Number(row.close) || 0;
        path.push(start);
        const addPoint = (value) => {
          const num = Number(value);
          if (!Number.isFinite(num)) return;
          if (Math.abs(num - path[path.length - 1]) < priceTolerance * Math.max(1, num)) return;
          path.push(num);
        };
        const open = Number(row.open);
        const high = Number(row.high);
        const low = Number(row.low);
        const close = Number(row.close);
        if (Number.isFinite(open)) addPoint(open);
        const upBar = Number.isFinite(close) && Number.isFinite(open) ? (close >= open) : true;
        if (upBar) {
          if (Number.isFinite(high)) addPoint(high);
          if (Number.isFinite(low)) addPoint(low);
        } else {
          if (Number.isFinite(low)) addPoint(low);
          if (Number.isFinite(high)) addPoint(high);
        }
        if (Number.isFinite(close)) addPoint(close);
        return path;
      };

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const path = buildPath(prevPrice, row);
        for (let i = 1; i < path.length; i++) {
          const from = path[i - 1];
          const to = path[i];
          processMove(from, to, row.caldt, row);
        }
        prevPrice = path[path.length - 1];
        const equity = cash + shares * prevPrice;
        const openBuyOrders = Array.from(activeBuys.values()).reduce((acc, arr) => acc + (Array.isArray(arr) ? arr.length : 0), 0);
        if (equity > peakEquity) peakEquity = equity;
        const drawdown = equity - peakEquity;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
        const equityPct = peakEquity > 0 ? (equity - peakEquity) / peakEquity : 0;
        if (equityPct < maxDrawdownPct) maxDrawdownPct = equityPct;
        lastEquityTime = new Date(row.caldt.getTime());
        equitySeries.push({
          time: new Date(row.caldt.getTime()),
          equity,
          cash: cash,
          cashDeployed: openBuyOrders * tradeValue,
          capitalBudget: fundedLevels * tradeValue
        });
      }

      const finalEquity = cash + shares * prevPrice;
      const millis = firstEquityTime && lastEquityTime ? (lastEquityTime.getTime() - firstEquityTime.getTime()) : 0;
      const years = millis > 0 ? (millis / (365.25 * 24 * 60 * 60 * 1000)) : 0;
      const maxLevelsUsed = Number.isFinite(summary.maxOpenLevels) ? summary.maxOpenLevels : 0;
      const derivedMaxCapital = (tradeValue > 0 && maxLevelsUsed > 0)
        ? tradeValue * maxLevelsUsed
        : 0;
      const trackedCapital = summary.maxDeployedCapital > 0 ? summary.maxDeployedCapital : (fundedLevels * tradeValue);
      const maxDeployedCapital = Math.max(derivedMaxCapital, trackedCapital);
      const cagrBaseEquity = maxDeployedCapital > 0 ? maxDeployedCapital : initialEquity;
      const cagr = (years > 0 && cagrBaseEquity > 0 && finalEquity > 0)
        ? Math.pow(finalEquity / cagrBaseEquity, 1 / years) - 1
        : 0;
      summary.totalTrades = trades.length;
      summary.netProfit = realizedProfit;
      summary.profitPerLevel = maxLevelsUsed > 0 ? realizedProfit / maxLevelsUsed : 0;
      summary.finalEquity = finalEquity;
      summary.totalRetainedShares = cumulativeRetained;
      summary.cash = cash;
      summary.minCash = minCashBalance;
      summary.shares = shares;
      summary.maxDrawdown = maxDrawdown;
      summary.maxDrawdownPct = maxDrawdownPct * 100;
      summary.maxSharesHeld = maxSharesHeld;
      summary.cagr = cagr;
      summary.maxDeployedCapital = maxDeployedCapital;
      return finalizeResult();
    }

    function runProgressiveGrid(rows, params) {
      const trades = [];
      const equitySeries = [];
      const ladderHistory = [];
      const summary = {
        totalTrades: 0,
        netProfit: 0,
        profitPerLevel: 0,
        finalEquity: 0,
        totalRetainedShares: 0,
        cash: 0,
        minCash: 0,
        shares: 0,
        maxDrawdown: 0,
        maxSharesHeld: 0,
        maxOpenLevels: 0,
        maxDeployedCapital: 0,
        cagr: 0
      };
      const buyLevelSet = new Set();
      const sellLevelSet = new Set();
      let gridLevels = [];
      let resolveBaseLevel = () => NaN;
      const finalizeResult = () => ({
        trades,
        summary,
        equitySeries,
        ladderHistory,
        buyLevels: Array.from(buyLevelSet).sort((a, b) => b - a),
        sellLevels: Array.from(sellLevelSet).sort((a, b) => a - b),
        gridLevels: Array.isArray(gridLevels) ? gridLevels : [],
        baseLevel: (() => {
          const val = resolveBaseLevel();
          return Number.isFinite(val) ? val : null;
        })()
      });
      if (!Array.isArray(rows) || !rows.length) {
        return finalizeResult();
      }
      const rawGridSize = Number(params?.gridSize);
      const rawBasePrice = Number(params?.basePrice);
      const gridSpacingType = (params?.gridSpacingType || GRID_DEFAULTS.gridSpacingType).toLowerCase();
      const tradeValue = Number(params?.tradeValue);
      const tickSize = Number(params?.tickSize);
      const resolvedTickSize = Number.isFinite(tickSize) && tickSize > 0 ? tickSize : 0.01;
      const fractional = !!params?.fractionalShares;
      const retentionMode = (params?.retentionMode || 'profit').toLowerCase();
      const entryFilter = (params?.entryFilter || 'none').toLowerCase();
      if (!Number.isFinite(rawGridSize) || rawGridSize <= 0 || !Number.isFinite(tradeValue) || tradeValue <= 0) {
        return finalizeResult();
      }
      let firstPrice = [rows[0]?.open, rows[0]?.close, rows[0]?.high, rows[0]?.low].map(Number).find(Number.isFinite);
      if (!Number.isFinite(firstPrice) || firstPrice <= 0) {
        return finalizeResult();
      }
      const basePrice = Number.isFinite(rawBasePrice) && rawBasePrice > 0 ? rawBasePrice : firstPrice;

      let minPrice = firstPrice;
      let maxPrice = firstPrice;
      for (const row of rows) {
        if (!row) continue;
        const low = Number(row.low);
        const high = Number(row.high);
        if (Number.isFinite(low)) minPrice = Math.min(minPrice, low);
        if (Number.isFinite(high)) maxPrice = Math.max(maxPrice, high);
      }
      if (!Number.isFinite(minPrice) || !Number.isFinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) {
        return finalizeResult();
      }

      const spacing = createGridSpacingHelpers({
        spacingType: gridSpacingType,
        gridSize: rawGridSize,
        basePrice,
        firstPrice,
        minPrice,
        maxPrice,
        tickSize: resolvedTickSize
      });
      if (spacing.error) {
        console.warn('Grid spacing configuration invalid:', spacing.error);
        return finalizeResult();
      }
      const snapLevel = spacing.snap;
      const keyFor = spacing.key;
      const nextUpLevel = spacing.nextUp;
      const nextDownLevel = spacing.nextDown;
      const stepsBetween = spacing.stepsBetween;
      const priceTolerance = spacing.priceTolerance ?? 1e-9;
      const usePercentSpacing = spacing.type === 'percent';
      const shouldRatchetUp = usePercentSpacing && spacing.anchorMode === 'ratchet_up' && typeof spacing.setAnchor === 'function' && typeof spacing.getAnchor === 'function';
      const refreshEntryRungs = () => {
        pendingBuys.forEach(entry => {
          if (entry) entry.rungIndex = computeRungIndex(entry.level);
        });
        pendingSells.forEach(entry => {
          if (entry) entry.buyRung = computeRungIndex(entry.buyPrice);
        });
      };
      const ratchetAnchorIfNeeded = (candidate) => {
        if (!shouldRatchetUp || !Number.isFinite(candidate)) return;
        const currentAnchor = spacing.getAnchor && spacing.getAnchor();
        if (!Number.isFinite(currentAnchor)) return;
        const tolerance = priceTolerance * Math.max(1, candidate);
        if (candidate <= currentAnchor + tolerance) return;
        const snapped = snapLevel(candidate);
        spacing.setAnchor(snapped);
        refreshEntryRungs();
      };
      const initialBaseLevel = snapLevel(basePrice);
      resolveBaseLevel = () => {
        if (usePercentSpacing && typeof spacing.getAnchor === 'function') {
          const anchor = spacing.getAnchor();
          if (Number.isFinite(anchor)) return anchor;
        }
        return initialBaseLevel;
      };
      const currentBaseLevel = () => {
        if (usePercentSpacing && typeof spacing.getAnchor === 'function') {
          const anchor = spacing.getAnchor();
          if (Number.isFinite(anchor)) return anchor;
        }
        return initialBaseLevel;
      };
      const computeRungIndex = (level) => {
        const anchor = currentBaseLevel();
        if (!Number.isFinite(level) || !Number.isFinite(anchor)) return 0;
        const diff = stepsBetween(anchor, level);
        if (!Number.isFinite(diff)) return 0;
        return Math.round(diff);
      };

      const minGridLevel = spacing.floor(minPrice);

      let cash = 0;
      let minCashBalance = cash;
      const initialEquity = cash;
      let fundedLevels = 0;
      let openPositions = 0;
      const firstEquityTime = rows[0]?.caldt instanceof Date ? new Date(rows[0].caldt.getTime()) : null;
      let lastEquityTime = firstEquityTime;
      let shares = 0;
      let realizedProfit = 0;
      let cumulativeRetained = 0;
      let prevPrice = firstPrice;
      let peakEquity = cash + shares * firstPrice;
      let maxDrawdown = 0;
      let maxDrawdownPct = 0;
      let maxSharesHeld = shares;

      const pendingBuys = new Map(); // key -> { key, level, groupId, direction }
      const pendingSells = new Set(); // entries with level, qty, buyPrice, buyTime
      let sellSeq = 1;
      let buyGroupSeq = 1;

      const queueBuy = (price, groupId = 0, direction = 'neutral') => {
        const level = snapLevel(price);
        if (!Number.isFinite(level) || level <= 0) return null;
        buyLevelSet.add(level);
        const key = keyFor(level);
        if (pendingBuys.has(key)) {
          const existing = pendingBuys.get(key);
          if (groupId > 0) existing.groupId = groupId;
          if (direction) existing.direction = direction;
          return existing;
        }
        const entry = { key, level, groupId: groupId > 0 ? groupId : 0, direction, rungIndex: computeRungIndex(level) };
        pendingBuys.set(key, entry);
        return entry;
      };

      const queueSell = (price, qty, buyPrice, buyTime, rungIndex) => {
        const level = snapLevel(price);
        if (!Number.isFinite(level) || level <= 0) return null;
        sellLevelSet.add(level);
        const entry = {
          id: sellSeq++,
          level,
          qty,
          buyPrice,
          buyTime: buyTime instanceof Date ? new Date(buyTime.getTime()) : new Date(),
          buyRung: Number.isFinite(rungIndex) ? rungIndex : computeRungIndex(buyPrice)
        };
        pendingSells.add(entry);
        return entry;
      };

      const ensureDownCoverage = (fromLevel) => {
        let level = snapLevel(fromLevel);
        if (!Number.isFinite(level)) return;
        let safety = 0;
        while (Number.isFinite(level) && level >= minGridLevel - priceTolerance * Math.max(1, level) && safety < 2000) {
          queueBuy(level, 0, 'down');
          const nextLevel = nextDownLevel(level);
          if (!Number.isFinite(nextLevel) || Math.abs(nextLevel - level) <= priceTolerance * Math.max(1, level)) break;
          level = nextLevel;
          safety += 1;
        }
      };

      const hasPendingSellAtOrAbove = (level) => {
        if (!Number.isFinite(level)) return false;
        const tolerance = priceTolerance * Math.max(1, Math.abs(level));
        for (const entry of pendingSells) {
          if (!entry || !Number.isFinite(entry.level)) continue;
          if (entry.level >= level - tolerance) {
            return true;
          }
        }
        return false;
      };

      const executeBuy = (entry, timestamp, contextRow) => {
        if (!entry) return false;
        const price = entry.level;
        if (!passesEntryFilter(price, contextRow, entryFilter)) {
          return false;
        }
        const qtyRaw = tradeValue / price;
        let qty = fractional ? qtyRaw : Math.floor(qtyRaw);
        if (!Number.isFinite(qty) || qty <= 0) return false;
        const neededPositions = openPositions + 1;
        if (neededPositions > fundedLevels) {
          const levelsToAdd = neededPositions - fundedLevels;
          cash += levelsToAdd * tradeValue;
          fundedLevels += levelsToAdd;
          const deployed = fundedLevels * tradeValue;
          if (deployed > summary.maxDeployedCapital) {
            summary.maxDeployedCapital = deployed;
          }
        }
        const cost = qty * price;
        pendingBuys.delete(entry.key);
        if (entry.groupId > 0 && entry.direction === 'down') {
          const keysToRemove = [];
          for (const [otherKey, otherEntry] of pendingBuys.entries()) {
            if (otherEntry.groupId === entry.groupId) keysToRemove.push(otherKey);
          }
          for (const key of keysToRemove) pendingBuys.delete(key);
        }
        cash -= cost;
        if (cash < minCashBalance) minCashBalance = cash;
        shares += qty;
        if (shares > maxSharesHeld) maxSharesHeld = shares;
        openPositions += 1;
        if (openPositions > summary.maxOpenLevels) summary.maxOpenLevels = openPositions;
        const buyTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const sellLevel = nextUpLevel(price);
        if (Number.isFinite(sellLevel) && sellLevel > 0) {
          queueSell(sellLevel, qty, price, buyTime, Number.isFinite(entry?.rungIndex) ? entry.rungIndex : computeRungIndex(price));
        }
        if (entry.direction === 'down') {
          const downLevel = nextDownLevel(price);
          if (Number.isFinite(downLevel) && downLevel > 0) {
            queueBuy(downLevel, buyGroupSeq++, 'down');
          }
        } else if (entry.direction === 'up') {
          const desired = nextDownLevel(price);
          if (Number.isFinite(desired) && desired > 0) {
            const key = keyFor(desired);
            if (!pendingBuys.has(key)) {
              queueBuy(desired, buyGroupSeq++, 'down');
            }
          }
        }
        const coverageOrigin = nextDownLevel(price);
        if (Number.isFinite(coverageOrigin)) {
          ensureDownCoverage(coverageOrigin);
        }
        return true;
      };

      const executeSell = (entry, timestamp) => {
        if (!entry) return false;
        pendingSells.delete(entry);
        const price = entry.level;
        const openQty = shares;
        const desiredRaw = tradeValue / price;
        let desired = fractional ? desiredRaw : Math.floor(desiredRaw);
        const execution = computeSellExecution({
          baseQty: entry.qty,
          desiredQty: desired,
          sharesAvailable: shares,
          mode: retentionMode,
          fractional
        });
        let qty = execution.qty;
        if (qty <= 0) return false;
        const revenue = qty * price;
        const costBasis = qty * entry.buyPrice;
        cash += revenue;
        shares -= qty;
        if (openPositions > 0) openPositions -= 1;
        const profit = revenue - costBasis;
        realizedProfit += profit;
        const qtyRetained = execution.retained;
        cumulativeRetained += qtyRetained;
        const closeQty = shares;
        const closeEquity = cash + shares * price;
        const totalContributed = Math.max(0, openPositions) * tradeValue;
        const runningPnl = closeEquity - totalContributed;
        const nextPeak = Math.max(peakEquity, closeEquity);
        const drawdown = closeEquity - nextPeak;
        peakEquity = nextPeak;
        const sellTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const buyTime = entry.buyTime instanceof Date ? new Date(entry.buyTime.getTime()) : new Date();
        const msHeld = sellTime.getTime() - buyTime.getTime();
        const daysHeld = Number.isFinite(msHeld) ? Math.max(0, msHeld / 86400000) : 0;
        const openTradesCount = pendingSells.size;
        const openLevelSnapshot = openTradesCount + 1;
        if (openLevelSnapshot > summary.maxOpenLevels) {
          summary.maxOpenLevels = openLevelSnapshot;
        }
        const openEquity = openLevelSnapshot * tradeValue;
        trades.push({
          buyTime,
          buyPrice: entry.buyPrice,
          buyQty: entry.qty,
          gridLevel: Number.isFinite(entry.buyRung) ? entry.buyRung : computeRungIndex(entry.buyPrice),
          openLevels: openLevelSnapshot,
          openQty,
          openEquity,
          sellTime,
          sellPrice: price,
          sellQty: qty,
          closeQty,
          closeEquity,
          qtyRetained,
          cumQtyRetained: cumulativeRetained,
          daysHeld,
          profit,
          cumProfit: realizedProfit,
          runningPnl,
          drawdown,
          roiPct: costBasis > 0 ? (profit / costBasis) * 100 : 0
        });
        const groupId = buyGroupSeq++;
        const upLevel = nextUpLevel(price);
        if (Number.isFinite(upLevel) && upLevel > 0 && !hasPendingSellAtOrAbove(upLevel)) {
          queueBuy(upLevel, groupId, 'up');
        }
        const downLevel = nextDownLevel(price);
        if (Number.isFinite(downLevel) && downLevel > 0) queueBuy(downLevel, groupId, 'down');
        if (Number.isFinite(downLevel)) ensureDownCoverage(downLevel);
        return true;
      };

      const getNextSellAbove = (cursor, target) => {
        let best = null;
        for (const entry of pendingSells) {
          const lvl = entry.level;
          const lowerTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(cursor));
          const upperTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(target));
          if (lvl > cursor + lowerTol && lvl <= target + upperTol) {
            if (!best || lvl < best.level) best = entry;
          }
        }
        return best;
      };

      const getNextBuyAbove = (cursor, target) => {
        let best = null;
        for (const entry of pendingBuys.values()) {
          const lvl = entry.level;
          const lowerTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(cursor));
          const upperTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(target));
          if (lvl > cursor + lowerTol && lvl <= target + upperTol) {
            if (!best || lvl < best.level) best = entry;
          }
        }
        return best;
      };

      const getNextBuyBelow = (target, cursor) => {
        let best = null;
        for (const entry of pendingBuys.values()) {
          const lvl = entry.level;
          const upperTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(cursor));
          const lowerTol = priceTolerance * Math.max(1, Math.abs(lvl), Math.abs(target));
          if (lvl < cursor - upperTol && lvl >= target - lowerTol) {
            if (!best || lvl > best.level) best = entry;
          }
        }
        return best;
      };

      const processMove = (start, end, timestamp, contextRow) => {
        const eventTime = timestamp instanceof Date ? new Date(timestamp.getTime()) : new Date();
        const scale = Math.max(1, Math.abs(start), Math.abs(end));
        const threshold = priceTolerance * scale;
        if (end > start + threshold) {
          let cursor = start;
          const target = end;
          let guard = 0;
          while (guard < 2000) {
            guard += 1;
            const nextSell = getNextSellAbove(cursor, target);
            const nextBuy = getNextBuyAbove(cursor, target);
            let nextEntry = null;
            let type = null;
            if (nextSell && nextBuy) {
              const compareTol = priceTolerance * Math.max(1, Math.abs(nextSell.level), Math.abs(nextBuy.level));
              if (nextSell.level <= nextBuy.level + compareTol) {
                nextEntry = nextSell;
                type = 'sell';
              } else {
                nextEntry = nextBuy;
                type = 'buy';
              }
            } else if (nextSell) {
              nextEntry = nextSell;
              type = 'sell';
            } else if (nextBuy) {
              nextEntry = nextBuy;
              type = 'buy';
            } else {
              break;
            }
            cursor = nextEntry.level;
            if (type === 'sell') {
              if (!executeSell(nextEntry, eventTime)) break;
            } else {
              if (!executeBuy(nextEntry, eventTime, contextRow)) break;
            }
          }
          ratchetAnchorIfNeeded(end);
        } else if (end < start - threshold) {
          let cursor = start;
          const target = end;
          let guard = 0;
          while (guard < 2000) {
            guard += 1;
            const nextBuy = getNextBuyBelow(target, cursor);
            if (!nextBuy) break;
            cursor = nextBuy.level;
            if (!executeBuy(nextBuy, eventTime, contextRow)) break;
          }
        }
      };

      const buildPath = (fromPrice, row) => {
        const path = [];
        let start = Number(fromPrice);
        if (!Number.isFinite(start)) start = Number(row.open) || Number(row.close) || 0;
        path.push(start);
        const addPoint = (value) => {
          const num = Number(value);
          if (!Number.isFinite(num)) return;
          if (Math.abs(num - path[path.length - 1]) < priceTolerance * Math.max(1, num)) return;
          path.push(num);
        };
        const open = Number(row.open);
        const high = Number(row.high);
        const low = Number(row.low);
        const close = Number(row.close);
        if (Number.isFinite(open)) addPoint(open);
        const upBar = Number.isFinite(close) && Number.isFinite(open) ? (close >= open) : true;
        if (upBar) {
          if (Number.isFinite(high)) addPoint(high);
          if (Number.isFinite(low)) addPoint(low);
        } else {
          if (Number.isFinite(low)) addPoint(low);
          if (Number.isFinite(high)) addPoint(high);
        }
        if (Number.isFinite(close)) addPoint(close);
        return path;
      };

      const firstRow = Array.isArray(rows) && rows.length ? rows[0] : null;
      const initialTime = firstRow?.caldt instanceof Date ? new Date(firstRow.caldt.getTime()) : new Date();
      const initialBuy = queueBuy(firstPrice, buyGroupSeq++, 'down');
      if (initialBuy) executeBuy(initialBuy, initialTime, firstRow);
      const initialCoverageLevel = nextDownLevel(firstPrice);
      if (Number.isFinite(initialCoverageLevel)) {
        ensureDownCoverage(initialCoverageLevel);
      }

      for (const row of rows) {
        if (!row || !(row.caldt instanceof Date)) continue;
        const path = buildPath(prevPrice, row);
        for (let i = 1; i < path.length; i++) {
          const from = path[i - 1];
          const to = path[i];
          processMove(from, to, row.caldt, row);
        }
        prevPrice = path[path.length - 1];
        const equity = cash + shares * prevPrice;
        const openBuyOrders = pendingBuys.size;
        if (equity > peakEquity) peakEquity = equity;
        const drawdown = equity - peakEquity;
        if (drawdown < maxDrawdown) maxDrawdown = drawdown;
        const drawdownPct = peakEquity > 0 ? drawdown / peakEquity : 0;
        if (drawdownPct < maxDrawdownPct) maxDrawdownPct = drawdownPct;
        lastEquityTime = new Date(row.caldt.getTime());
        ladderHistory.push({
          time: new Date(row.caldt.getTime()),
          buys: pendingBuys.size,
          sells: pendingSells.size,
          queued: 0
        });
        equitySeries.push({
          time: new Date(row.caldt.getTime()),
          equity,
          cash: cash,
          cashDeployed: openBuyOrders * tradeValue,
          capitalBudget: fundedLevels * tradeValue
        });
      }

      const finalEquity = cash + shares * prevPrice;
      const millis = firstEquityTime && lastEquityTime ? (lastEquityTime.getTime() - firstEquityTime.getTime()) : 0;
      const years = millis > 0 ? (millis / (365.25 * 24 * 60 * 60 * 1000)) : 0;
      const maxLevelsUsed = Number.isFinite(summary.maxOpenLevels) ? summary.maxOpenLevels : 0;
      const derivedMaxCapital = (tradeValue > 0 && maxLevelsUsed > 0)
        ? tradeValue * maxLevelsUsed
        : 0;
      const trackedCapital = summary.maxDeployedCapital > 0 ? summary.maxDeployedCapital : (fundedLevels * tradeValue);
      const maxDeployedCapital = Math.max(derivedMaxCapital, trackedCapital);
      const cagrBaseEquity = maxDeployedCapital > 0 ? maxDeployedCapital : initialEquity;
      const cagr = (years > 0 && cagrBaseEquity > 0 && finalEquity > 0)
        ? Math.pow(finalEquity / cagrBaseEquity, 1 / years) - 1
        : 0;
      summary.totalTrades = trades.length;
      summary.netProfit = realizedProfit;
      summary.profitPerLevel = maxLevelsUsed > 0 ? realizedProfit / maxLevelsUsed : 0;
      summary.finalEquity = finalEquity;
      summary.totalRetainedShares = cumulativeRetained;
      summary.cash = cash;
      summary.minCash = minCashBalance;
      summary.shares = shares;
      summary.maxDrawdown = maxDrawdown;
      summary.maxDrawdownPct = maxDrawdownPct * 100;
      summary.maxSharesHeld = maxSharesHeld;
      summary.cagr = cagr;
      summary.maxDeployedCapital = maxDeployedCapital;
      return finalizeResult();
    }

    function runGridBacktest() {
      if (!Array.isArray(ROWS) || !ROWS.length) {
        setGridStatus('Load symbol data before running the backtest.');
        return;
      }
      const params = getGridParamsFromUI();
      const rowsForRun = filterRowsBySelectedMonths(ROWS);
      if (!rowsForRun.length) {
        setGridStatus('No data available for the selected month filter. Clear the filter or load more data.');
        renderGridSummary(null);
        renderGridTrades([], { resetPage: true });
        renderGridEquityChart(null);
        renderLadderChart([]);
        renderFillsPerDayChart([]);
        renderOpenLevelsChart([]);
        renderFillsPerMonthChart([]);
        renderPriceDistributionChart([]);
        renderLevelDistributionChart([]);
        renderCumulativeLevelDistributionChart([]);
        renderGridLevels([], [], null);
        return;
      }
      const uniqueFilteredDays = new Set(rowsForRun.map(row => row?.dayKey).filter(Boolean));
      const entryFilter = params?.entryFilter || 'none';
      const window = getEntryFilterWindow(entryFilter);
      if (window) {
        const info = describeSmaAvailability(entryFilter);
        const available = info?.availableDays || 0;
        if (available <= 0) {
          const totalDays = info?.totalDays ?? DAYS.length;
          setGridStatus(`Entry filter (${window}-day SMA) needs ${window} completed days. Dataset has ${totalDays.toLocaleString()} day${totalDays === 1 ? '' : 's'} — insufficient for this filter.`);
          renderGridSummary(null);
          renderGridTrades([], { resetPage: true });
          renderGridEquityChart(null);
          renderLadderChart([]);
          renderFillsPerDayChart([]);
          renderOpenLevelsChart([]);
          renderFillsPerMonthChart([]);
          renderPriceDistributionChart([]);
          renderLevelDistributionChart([]);
          renderCumulativeLevelDistributionChart([]);
          renderGridLevels([], [], null);
          return;
        }
        if (uniqueFilteredDays.size < window) {
          setGridStatus(`Entry filter (${window}-day SMA) needs ${window} completed day(s), but the current month filter only leaves ${uniqueFilteredDays.size.toLocaleString()} day${uniqueFilteredDays.size === 1 ? '' : 's'}. Adjust the filter or load additional data.`);
          renderGridSummary(null);
          renderGridTrades([], { resetPage: true });
          renderGridEquityChart(null);
          renderLadderChart([]);
          renderFillsPerDayChart([]);
          renderOpenLevelsChart([]);
          renderFillsPerMonthChart([]);
          renderPriceDistributionChart([]);
          renderLevelDistributionChart([]);
          renderCumulativeLevelDistributionChart([]);
          renderGridLevels([], [], null);
          return;
        }
      }
      setGridStatus('Running backtest…');
      try {
        const result = runPullbackGridSimulation(rowsForRun, params) || {};
        const safeResult = {
          trades: Array.isArray(result.trades) ? result.trades : [],
          summary: result.summary || null,
          equitySeries: Array.isArray(result.equitySeries) ? result.equitySeries : [],
          ladderHistory: Array.isArray(result.ladderHistory) ? result.ladderHistory : [],
          buyLevels: Array.isArray(result.buyLevels) ? result.buyLevels : [],
          sellLevels: Array.isArray(result.sellLevels) ? result.sellLevels : [],
          baseLevel: Number.isFinite(result.baseLevel) ? result.baseLevel : null,
          gridLevels: Array.isArray(result.gridLevels) ? result.gridLevels : []
        };
        GRID_STATE = safeResult;
        renderGridSummary(safeResult.summary);
        renderGridTrades(safeResult.trades, { resetPage: true });
        renderGridEquityChart(safeResult.equitySeries);
        renderLadderChart(safeResult.trades);
        renderFillsPerDayChart(safeResult.trades);
        renderOpenLevelsChart(safeResult.ladderHistory);
        renderFillsPerMonthChart(safeResult.trades);
        renderPriceDistributionChart(safeResult.trades);
        renderLevelDistributionChart(safeResult.trades);
        renderCumulativeLevelDistributionChart(safeResult.trades);
        renderGridLevels(safeResult.buyLevels, safeResult.sellLevels, safeResult.baseLevel ?? null);
        setSaveButtonEnabled(!!safeResult.summary);
        if (safeResult.trades.length) {
          const profitLabel = formatCurrency(safeResult.summary?.netProfit ?? 0);
          setGridStatus(`Backtest completed with ${safeResult.trades.length} trade${safeResult.trades.length === 1 ? '' : 's'}. Net profit ${profitLabel}.`);
        } else {
          setGridStatus('No completed trades for the selected parameters.');
        }
      } catch (err) {
        console.error('Buy-the-dip grid backtest error', err);
        setGridStatus('Failed to run backtest. See console for details.');
        renderLadderChart([]);
        renderFillsPerDayChart([]);
        renderOpenLevelsChart([]);
        renderFillsPerMonthChart([]);
        renderPriceDistributionChart([]);
        renderLevelDistributionChart([]);
        renderCumulativeLevelDistributionChart([]);
        renderGridLevels([], [], null);
      }
    }

    function initGridControls() {
      const btn = document.getElementById('btnRunGridBacktest');
      if (btn) {
        btn.addEventListener('click', () => runGridBacktest());
      }
      const saveBtn = document.getElementById('btnSaveGridBacktest');
      if (saveBtn) {
        saveBtn.addEventListener('click', async () => {
          const payload = collectGridBacktestPayload();
          if (!payload || !payload.symbol) {
            setGridStatus('Run a backtest before saving.');
            return;
          }
          setGridStatus('Saving backtest…');
          setSaveButtonEnabled(false);
          try {
            await requestSaveGridBacktest(payload);
            setGridStatus('Backtest saved.');
          } catch (err) {
            const msg = err && err.message ? err.message : String(err);
            setGridStatus(`Save failed: ${msg}`);
          } finally {
            setSaveButtonEnabled(!!GRID_STATE?.summary);
          }
        });
      }
      const downsampleToggle = document.getElementById('toggleDownsample');
      if (downsampleToggle) {
        downsampleToggle.checked = RESAMPLE_INTERVAL_MINUTES > 1;
        downsampleToggle.addEventListener('change', () => {
          RESAMPLE_INTERVAL_MINUTES = downsampleToggle.checked ? DEFAULT_RESAMPLE_INTERVAL_MINUTES : 1;
          applyResamplingFromBase();
          updateLoadedStatus();
          renderDataSummary();
          if (Array.isArray(ROWS) && ROWS.length) {
            updateLoadedGridStatus('Running backtest…');
            runGridBacktest();
          }
        });
      }
      const adhocInput = document.getElementById('inpAdhocSymbol');
      const adhocButton = document.getElementById('btnAdhocGetData');
      if (adhocInput && adhocButton) {
        const kick = async () => {
          const symbol = normalizeSymbolInput(adhocInput.value);
          if (!symbol) {
            setStatus('Enter a symbol (e.g., TSLA) to download data.');
            return;
          }
          setStatus(`Requesting data for ${symbol}…`);
          setGridStatus(`Requesting data for ${symbol}…`);
          setAdhocDownloadBusy(true);
          startAdhocStatusPolling(symbol);
          try {
            const result = await requestAdhocDownload(symbol);
            const rows = Number(result?.rows);
            const note = result?.note;
            if (note === 'up-to-date' || rows === 0) {
              setStatus(`Data up to date for ${symbol}. Loading…`);
            } else {
              const rowLabel = Number.isFinite(rows) && rows > 0 ? `${rows.toLocaleString()} rows` : 'data';
              setStatus(`Downloaded ${rowLabel} for ${symbol}. Loading…`);
            }
            setTicker(symbol);
            await loadSymbolData(symbol);
            populateTickerSegment();
          } catch (err) {
            const msg = err && err.message ? err.message : String(err);
            setStatus(`Download failed for ${symbol}: ${msg}`);
            setGridStatus(`Download failed for ${symbol}: ${msg}`);
          } finally {
            stopAdhocStatusPolling();
            setAdhocDownloadBusy(false);
          }
        };
        adhocButton.addEventListener('click', kick);
        adhocInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') kick();
        });
      }
      const inputs = [
        document.getElementById('selGridType'),
        document.getElementById('selGridSpacing'),
        document.getElementById('selEntryFilter'),
        document.getElementById('selRetentionMode'),
        document.getElementById('inpGridSize'),
        document.getElementById('inpBasePrice'),
        document.getElementById('inpTradeValue'),
        document.getElementById('inpFractionalShares')
      ];
      inputs.forEach(el => {
        if (!el) return;
        const handler = () => {
          if (el.id === 'selGridSpacing') updateGridSizeLabel();
          if (!Array.isArray(ROWS) || !ROWS.length) return;
          runGridBacktest();
        };
        const eventName = el.tagName === 'SELECT' || el.type === 'checkbox' ? 'change' : 'input';
        el.addEventListener(eventName, handler);
      });
      updateGridSizeLabel();
      resetGridOutputs('Load data and run the backtest to populate results.');
      setRunButtonEnabled(false);
      document.querySelectorAll('th[data-sort-key] button').forEach((btn) => {
        btn.addEventListener('click', () => {
          const th = btn.closest('th[data-sort-key]');
          if (!th) return;
          const key = th.getAttribute('data-sort-key');
          if (!key) return;
          if (TRADE_SORT_STATE.key === key) {
            TRADE_SORT_STATE.dir = TRADE_SORT_STATE.dir === 'asc' ? 'desc' : 'asc';
          } else {
            TRADE_SORT_STATE.key = key;
            TRADE_SORT_STATE.dir = 'asc';
          }
          renderGridTrades(GRID_STATE.trades || []);
        });
      });
      updateTradeSortIndicators();
    }

    function initTradeTableControls() {
      const sizeSelect = document.getElementById('tradePageSize');
      if (sizeSelect) {
        sizeSelect.value = String(TRADE_TABLE_STATE.pageSize);
        sizeSelect.addEventListener('change', () => {
          const val = Number(sizeSelect.value);
          if (!Number.isFinite(val)) return;
          TRADE_TABLE_STATE.pageSize = Math.max(25, Math.min(1000, Math.round(val) || 250));
          TRADE_TABLE_STATE.page = 1;
          renderGridTrades(GRID_STATE.trades || []);
        });
      }
      const prev = document.getElementById('tradePagePrev');
      if (prev) {
        prev.addEventListener('click', () => {
          if (TRADE_TABLE_STATE.page <= 1) return;
          TRADE_TABLE_STATE.page -= 1;
          renderGridTrades(GRID_STATE.trades || []);
        });
      }
      const next = document.getElementById('tradePageNext');
      if (next) {
        next.addEventListener('click', () => {
          const trades = GRID_STATE.trades || [];
          const filtered = applyMonthFilter(trades);
          const { totalPages } = clampTradePage(filtered.length);
          if (TRADE_TABLE_STATE.page >= totalPages) return;
          TRADE_TABLE_STATE.page += 1;
          renderGridTrades(trades);
        });
      }
      updateTradePaginationControls(0);
    }


    async function loadSymbolData(sym) {
      const baseSymbol = (sym || '').trim();
      if (!baseSymbol) return false;
      setStatus(`Loading data for ${baseSymbol}…`);
      setGridStatus(`Loading data for ${baseSymbol}…`);
      setRunButtonEnabled(false);
      const candidates = Array.from(new Set([
        baseSymbol,
        baseSymbol.toUpperCase(),
        baseSymbol.toLowerCase()
      ])).filter(Boolean);
      let lastError = null;
      for (const candidate of candidates) {
        const path = `data/${candidate}_1m.csv`;
        try {
          const res = await fetch(path, { cache: 'no-cache' });
          if (!res.ok) {
            lastError = `HTTP ${res.status} loading ${path}`;
            continue;
          }
          const text = await res.text();
          const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
          if (parsed.errors && parsed.errors.length) {
            console.warn('CSV parse warnings:', parsed.errors.slice(0, 3));
          }
          normalizeAndIndex(parsed.data);
          if (!ROWS.length) {
            lastError = 'No valid rows in dataset.';
            continue;
          }
          updateSymbolPrecisionFromRows(baseSymbol, parsed.data);
          updateSymbolBasePriceFromRows(baseSymbol);
          updateLoadedStatus();
          renderGridSummary(null);
          renderGridTrades([], { resetPage: true });
          renderGridEquityChart(null);
          renderLadderChart([]);
          renderFillsPerDayChart([]);
          renderOpenLevelsChart([]);
          renderFillsPerMonthChart([]);
          renderPriceDistributionChart([]);
          renderLevelDistributionChart([]);
          renderCumulativeLevelDistributionChart([]);
          renderDataSummary();
          updateLoadedGridStatus('Running backtest…');
          setRunButtonEnabled(true);
          runGridBacktest();
          return true;
        } catch (err) {
          lastError = err && err.message ? err.message : String(err);
        }
      }
      console.error(`Failed to load ${baseSymbol}: ${lastError || 'not found'}`);
      setStatus(`Error loading ${baseSymbol}: ${lastError || 'File not found.'}`);
      setGridStatus(`Error loading ${baseSymbol}: ${lastError || 'File not found.'}`);
      BASE_ROWS = [];
      ROWS = [];
      DAY_GROUPS = new Map();
      DAYS = [];
      renderGridSummary(null);
      renderGridTrades([], { resetPage: true });
      renderGridEquityChart(null);
      renderLadderChart([]);
      renderFillsPerDayChart([]);
      renderOpenLevelsChart([]);
      renderFillsPerMonthChart([]);
      renderPriceDistributionChart([]);
      renderLevelDistributionChart([]);
      renderCumulativeLevelDistributionChart([]);
      renderGridLevels([], [], null);
      buildMonthFilterOptions();
      setRunButtonEnabled(false);
      renderDataSummary();
      return false;
    }

    function normalizeSymbolEntries(entries) {
      const map = new Map();
      const ordered = [];
      if (!Array.isArray(entries)) return { list: ordered, map };
      for (const entry of entries) {
        let symbol = '';
        let name = '';
        let multiplier = null;
        let basePrice = null;
        let tickSize = null;
        if (typeof entry === 'string') {
          symbol = entry;
          name = entry;
        } else if (entry && typeof entry === 'object') {
          symbol = entry.symbol;
          name = entry.name || entry.symbol || '';
          multiplier = entry.multiplier;
          basePrice = entry.base_price ?? entry.basePrice;
          tickSize = entry.tick_size ?? entry.tickSize;
        } else {
          continue;
        }
        symbol = (symbol || '').toUpperCase().trim();
        if (!symbol || map.has(symbol)) continue;
        const existing = SYMBOL_META.get(symbol) || null;
        const parsedMultiplier = Number(multiplier);
        const finalMultiplier = Number.isFinite(parsedMultiplier) && parsedMultiplier > 0
          ? parsedMultiplier
          : (existing && Number.isFinite(existing.multiplier) ? existing.multiplier : 1);
        const parsedBase = Number(basePrice);
        const finalBasePrice = Number.isFinite(parsedBase) && parsedBase > 0
          ? parsedBase
          : (existing && Number.isFinite(existing.basePrice) ? existing.basePrice : 100);
        const parsedTick = Number(tickSize);
        const finalTickSize = Number.isFinite(parsedTick) && parsedTick > 0
          ? parsedTick
          : (existing && Number.isFinite(existing.tickSize) ? existing.tickSize : 0.01);
        const providedPrecision = entry && typeof entry === 'object' && Number.isInteger(entry.precision) && entry.precision >= 0
          ? Math.min(entry.precision, 8)
          : null;
        const meta = {
          symbol,
          name: (typeof name === 'string' && name.trim()) ? name.trim() : (existing && existing.name ? existing.name : symbol),
          multiplier: finalMultiplier,
          basePrice: finalBasePrice,
          tickSize: finalTickSize,
          precision: providedPrecision != null
            ? providedPrecision
            : (existing && Number.isInteger(existing.precision) ? existing.precision : null)
        };
        map.set(symbol, meta);
        ordered.push(meta);
      }
      return { list: ordered, map };
    }

    async function populateTickerSegment() {
      const container = document.getElementById('tickerSegment');
      if (!container) return;
      container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';
      const render = (entries) => {
        const normalized = normalizeSymbolEntries(entries);
        SYMBOL_META = normalized.map instanceof Map ? normalized.map : new Map();
        const list = Array.isArray(normalized.list) ? normalized.list : [];
        container.innerHTML = '';
        if (!list.length) {
          container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">No symbols available.</span>';
          highlightTickerButton(currentTicker);
          return;
        }
        list.forEach((meta) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'w-full h-full px-3 py-2 text-left bg-white hover:bg-emerald-50 transition flex flex-col justify-center gap-0.5 leading-tight';
          btn.setAttribute('data-symbol', meta.symbol);
          btn.setAttribute('title', meta.name);
          btn.dataset.multiplier = String(meta.multiplier);
          btn.innerHTML = `
            <span class="text-sm font-semibold">${meta.symbol}</span>
            <span class="text-xs text-slate-500" data-symbol-name>${meta.name}</span>
          `;
          container.appendChild(btn);
        });
        highlightTickerButton(currentTicker);
        if (!currentTicker && list[0]) {
          setTicker(list[0].symbol);
          loadSymbolData(list[0].symbol);
        }
      };
      try {
        const res = await fetch('data/index.json', { cache: 'no-cache' });
        if (res.ok) {
          const list = await res.json();
          if (Array.isArray(list) && list.length) { render(list); return; }
        }
      } catch (err) {
        console.warn('Failed to load index.json', err);
      }
      try {
        const res = await fetch('data/', { cache: 'no-cache' });
        if (res.ok) {
          const text = await res.text();
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let files = [];
          if (ct.includes('text/html')) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            files = Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href')).filter(Boolean);
          } else {
            files = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          }
          const regex = /^([A-Za-z0-9-]+)_1m\.csv$/i;
          const syms = [];
          for (const f of files) {
            const name = (f || '').split('/').pop();
            const m = name.match(regex);
            if (m) syms.push({ symbol: m[1].toUpperCase(), name: m[1].toUpperCase(), multiplier: undefined });
          }
          if (syms.length) { render(syms); return; }
        }
      } catch (err) {
        console.warn('Failed to enumerate data directory', err);
      }
      render(['TQQQ', 'TSLA', 'PLTR', 'UVXY']);
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#tickerSegment button[data-symbol]');
      if (!btn) return;
      const symbol = btn.getAttribute('data-symbol');
      if (!symbol) return;
      setTicker(symbol);
      loadSymbolData(symbol);
    });

    document.addEventListener('DOMContentLoaded', () => {
      initGridControls();
      initTradeTableControls();
      populateTickerSegment();
    });

    window.addEventListener('resize', () => {
      if (gridEquityChartInst) {
        try { gridEquityChartInst.resize(); } catch {}
      }
      if (gridLadderChartInst) {
        try { gridLadderChartInst.resize(); } catch {}
      }
      if (fillsPerDayChartInst) {
        try { fillsPerDayChartInst.resize(); } catch {}
      }
      if (openLevelsChartInst) {
        try { openLevelsChartInst.resize(); } catch {}
      }
      if (fillsPerMonthChartInst) {
        try { fillsPerMonthChartInst.resize(); } catch {}
      }
      if (priceDistributionChartInst) {
        try { priceDistributionChartInst.resize(); } catch {}
      }
      if (levelDistributionChartInst) {
        try { levelDistributionChartInst.resize(); } catch {}
      }
      if (cumulativeLevelDistributionChartInst) {
        try { cumulativeLevelDistributionChartInst.resize(); } catch {}
      }
    });
  })();
</script>
</body>
</html>
