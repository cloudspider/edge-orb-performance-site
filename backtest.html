<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ORB Backtest</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.tailframes.com/releases/latest/tailframes.min.js" defer></script>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"
  />
  <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
  <!-- Apache ECharts for interactive charts (mobile pinch-zoom supported) -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
  .num-pos { color: #119d6e !important; }
  .num-neg { color: #ff0000 !important; }
  .pnl-strong { font-size: 1.8rem !important; }
    .sticky-th { position: sticky; top: 0; background: white; z-index: 1; }
    .shadow-soft { box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
    thead th { position: sticky; top: 0; background: white; z-index: 1; }
    /* Hide native spin buttons for our numeric inputs (Safari/Chrome/Firefox) */
    #inp_orb_m::-webkit-outer-spin-button,
    #inp_orb_m::-webkit-inner-spin-button,
    #inp_target_R::-webkit-outer-spin-button,
    #inp_target_R::-webkit-inner-spin-button,
    #inp_stop_R::-webkit-outer-spin-button,
    #inp_stop_R::-webkit-inner-spin-button,
    #inp_risk_pct::-webkit-outer-spin-button,
    #inp_risk_pct::-webkit-inner-spin-button,
    #inp_aum0::-webkit-outer-spin-button,
    #inp_aum0::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    #inp_orb_m,
    #inp_target_R,
    #inp_stop_R,
    #inp_risk_pct,
    #inp_aum0 {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Generic: hide spinners for any number input (fallback and future fields) */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Allow segment controls to wrap within their container */
    #tickerSegment {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      grid-auto-rows: 1fr;
      width: 100%;
      gap: 1px;
    }
    #tickerSegment button {
      width: 100%;
      height: 100%;
    }
    #sessionSegment {
      display: flex;
      flex-wrap: wrap;
      max-width: 100%;
      min-width: 0;
      white-space: normal;
    }
    #sessionSegment button {
      flex: 0 0 auto;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Site navigation -->
  <nav class="bg-white border-b border-slate-200 sticky top-0 z-50 shadow-sm">
  <div class="max-w-screen-2xl mx-auto px-6 py-3 flex items-center gap-3">
      <div class="flex items-center gap-2 font-semibold text-slate-800">
        <svg class="h-5 w-5 text-emerald-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" fill="currentColor" aria-hidden="true"><path d="M192 384L88.5 384C63.6 384 48.3 356.9 61.1 335.5L114 247.3C122.7 232.8 138.3 224 155.2 224L250.2 224C326.3 95.1 439.8 88.6 515.7 99.7C528.5 101.6 538.5 111.6 540.3 124.3C551.4 200.2 544.9 313.7 416 389.8L416 484.8C416 501.7 407.2 517.3 392.7 526L304.5 578.9C283.2 591.7 256 576.3 256 551.5L256 448C256 412.7 227.3 384 192 384L191.9 384zM464 224C464 197.5 442.5 176 416 176C389.5 176 368 197.5 368 224C368 250.5 389.5 272 416 272C442.5 272 464 250.5 464 224z"/></svg>
        <span>ORB</span>
      </div>
      <div class="flex items-center gap-2">
        <a data-nav href="index.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Performance</a>
        <a data-nav href="backtest.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Backtest</a>
        <a data-nav href="results.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Results</a>
      </div>
    </div>
  </nav>
  <script>
    // Activate nav item for current page
    (function(){
      try {
        const file = (location.pathname.split('/').pop() || 'backtest.html').toLowerCase();
        document.querySelectorAll('a[data-nav]').forEach(a => {
          const href = (a.getAttribute('href') || '').toLowerCase();
          const active = href === file || (file === '' && href.endsWith('index.html'));
          a.classList.toggle('bg-slate-800', active);
          a.classList.toggle('text-white', active);
          a.classList.toggle('hover:bg-slate-100', !active);
          if (active) a.setAttribute('aria-current','page'); else a.removeAttribute('aria-current');
        });
      } catch {}
    })();
  </script>

  <div class="max-w-screen-2xl mx-auto p-6 space-y-6">
    <header class="mb-2">
      <h1 id="mainTitle" class="text-2xl md:text-3xl font-semibold">ORB Backtest</h1>
      <p class="text-slate-600 mt-1">Pick a symbol and tweak settings.</p>
    </header>

    <section id="symbolPicker" class="bg-white rounded-2xl shadow-soft p-3 md:p-4">
      <div class="overflow-x-auto -mx-3 md:mx-0 px-3 md:px-0">
        <nav class="flex min-w-max border-b border-slate-200 gap-1" role="tablist">
          <button type="button" class="inline-flex items-center gap-2 border-b-2 border-transparent px-3 py-2 text-sm font-medium text-slate-500 transition hover:text-slate-700" data-mode-tab="backtest">
            <span class="inline-flex h-8 w-8 items-center justify-center text-slate-400">
              <ion-icon name="beaker-outline" class="text-2xl"></ion-icon>
            </span>
            <span>Backtest</span>
          </button>
          <button type="button" class="inline-flex items-center gap-2 border-b-2 border-transparent px-3 py-2 text-sm font-medium text-slate-500 transition hover:text-slate-700" data-mode-tab="auto">
            <span class="inline-flex h-8 w-8 items-center justify-center text-slate-400">
              <ion-icon name="star-outline" class="text-2xl"></ion-icon>
            </span>
            <span>Auto Backtest</span>
          </button>
          <button type="button" class="inline-flex items-center gap-2 border-b-2 border-transparent px-3 py-2 text-sm font-medium text-slate-500 transition hover:text-slate-700" data-mode-tab="portfolio">
            <span class="inline-flex h-8 w-8 items-center justify-center text-slate-400">
              <ion-icon name="briefcase-outline" class="text-2xl"></ion-icon>
            </span>
            <span>Portfolio</span>
          </button>
          <button type="button" class="inline-flex items-center gap-2 border-b-2 border-transparent px-3 py-2 text-sm font-medium text-slate-500 transition hover:text-slate-700" data-mode-tab="favorites">
            <span class="inline-flex h-8 w-8 items-center justify-center text-slate-400">
              <ion-icon name="heart-outline" class="text-2xl"></ion-icon>
            </span>
            <span>Favorites</span>
          </button>
          <button type="button" class="inline-flex items-center gap-2 border-b-2 border-transparent px-3 py-2 text-sm font-medium text-slate-500 transition hover:text-slate-700" data-mode-tab="live">
            <span class="inline-flex h-8 w-8 items-center justify-center text-slate-400">
              <ion-icon name="pulse-outline" class="text-2xl"></ion-icon>
            </span>
            <span>Live</span>
          </button>
        </nav>
      </div>

      <div class="flex-1 min-w-0 mt-4">
        <div class="flex items-center gap-2 mb-2">
          <div class="flex-1 min-w-0">
            <div id="tickerSegment" class="w-full rounded-xl border border-slate-200 bg-slate-200 p-px overflow-hidden">
              <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
            </div>
          </div>
        </div>
        <div id="status" class="text-xs text-slate-500"></div>
      </div>

    </section>


    <!-- ORB settings -->
    <section id="orbSettings" class="bg-white rounded-2xl shadow-soft p-3 md:p-4">
      <div class="mb-3 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
        <h2 class="font-semibold">ORB Settings</h2>
        <div class="flex flex-wrap items-center gap-2 sm:justify-end">
          <div id="sessionSegment" class="inline-flex rounded-xl border border-slate-200 bg-white overflow-hidden">
            <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
          </div>
          <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-500 shadow-sm transition opacity-50 pointer-events-none" id="btnToggleLive" aria-pressed="false" disabled>
            <span data-live-indicator class="h-2.5 w-2.5 rounded-full bg-slate-300"></span>
            <span data-live-label>Live: Off</span>
          </button>
          <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600" id="btnAddFavorite" aria-pressed="false">
            <i class="fa fa-regular fa-heart"></i>
            <span>Favorite</span>
          </button>
          <div class="relative">
            <select id="favoriteSelect" class="appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-8 py-2 text-sm text-slate-600 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60 min-w-[200px]" disabled>
              <option value="">Load Favorite…</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-3 flex items-center text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
            </span>
          </div>
          <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600" id="btnAddPortfolio">
            <i class="fa fa-regular fa-bookmark"></i>
            <span data-portfolio-add-label>Add to Portfolio</span>
          </button>
        </div>
      </div>
      <div class="flex items-start gap-4 flex-col md:flex-row">
  <div class="w-full md:w-full grid grid-cols-3 md:grid-cols-9 gap-3">
          <label class="block">
            <span class="text-sm text-slate-600">orb_m</span>
            <div class="mt-1 relative">
              <input id="inp_orb_m" data-default="25" type="number" min="1" max="120" step="1" value="25" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase orb_m" data-num-target="inp_orb_m" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease orb_m" data-num-target="inp_orb_m" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">target_R</span>
            <div class="mt-1 relative">
              <input id="inp_target_R" data-default="2" type="number" min="0" max="100" step="0.1" value="2" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase target_R" data-num-target="inp_target_R" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease target_R" data-num-target="inp_target_R" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">stop_R</span>
            <div class="mt-1 relative">
              <input id="inp_stop_R" data-default="2" type="number" min="0" max="100" step="0.1" value="2" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase stop_R" data-num-target="inp_stop_R" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease stop_R" data-num-target="inp_stop_R" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">ORB Start</span>
            <div class="mt-1 relative">
              <input id="inp_orb_start" type="time" step="60" value="09:30" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase start time" data-time-target="inp_orb_start" data-time-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease start time" data-time-target="inp_orb_start" data-time-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">ORB End</span>
            <div class="mt-1 relative">
              <input id="inp_orb_end" type="time" step="60" value="15:30" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase end time" data-time-target="inp_orb_end" data-time-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease end time" data-time-target="inp_orb_end" data-time-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">Entry Cutoff</span>
            <div class="mt-1 relative">
              <input id="inp_entry_cutoff" type="time" step="60" value="12:00" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase entry cutoff" data-time-target="inp_entry_cutoff" data-time-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease entry cutoff" data-time-target="inp_entry_cutoff" data-time-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>

          <!-- AUM + At Risk % row under existing fields -->
          <label class="block col-span-3 md:col-span-1">
            <span class="text-sm text-slate-600">AUM</span>
            <div class="mt-1 relative">
              <input id="inp_aum0" data-default="100000" type="number" min="0" max="1000000000" step="1000" value="100000" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase AUM" data-num-target="inp_aum0" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease AUM" data-num-target="inp_aum0" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block col-span-3 md:col-span-1">
            <span class="text-sm text-slate-600">At Risk % (Per Trade)</span>
            <div class="mt-1 relative">
              <input id="inp_risk_pct" data-default="2" type="number" min="0" max="100" step="0.5" value="2" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase risk %" data-num-target="inp_risk_pct" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease risk %" data-num-target="inp_risk_pct" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l-4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block col-span-3 md:col-span-1">
            <span class="text-sm text-slate-600">Min OR %</span>
            <div class="mt-1 relative">
              <input id="inp_min_or_perc" data-default="0.2" type="number" min="0" max="10" step="0.05" value="0.2" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase Min OR %" data-num-target="inp_min_or_perc" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease Min OR %" data-num-target="inp_min_or_perc" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
        </div>
      </div>
    </section>

    <section id="autoBacktestSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 hidden space-y-4" data-tab-panel="auto">
      <div>
        <h2 class="font-semibold inline-flex items-center gap-2 text-slate-700">
          <ion-icon name="star-outline" class="text-emerald-500 text-xl"></ion-icon>
          <span>Auto Backtest</span>
        </h2>
      </div>
      <div class="flex flex-col gap-2">
        <div class="flex flex-col gap-2">
          <div class="flex flex-wrap items-center justify-between gap-3">
            <div class="flex items-center gap-2 text-sm text-slate-600">
              <span>Rank by</span>
              <div class="relative min-w-[180px]">
                <select id="autoSortSelect" class="appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-8 py-2 text-sm text-slate-600 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60 w-full">
                    <option value="winPct">Win %</option>
                    <option value="athDayPct">ATH Day %</option>
                    <option value="sortino">Sortino</option>
                    <option value="mar">MAR</option>
                    <option value="totalPnL">Total PnL</option>
                    <option value="cagr">CAGR</option>
                    <option value="maxDD">Max DD</option>
                </select>
                <span class="pointer-events-none absolute inset-y-0 right-3 inline-flex items-center text-slate-400">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
                </span>
              </div>
              <button id="btnAutoConfig" type="button" class="inline-flex h-9 w-9 items-center justify-center rounded-full border border-slate-200 bg-white text-slate-500 transition hover:border-emerald-500 hover:text-emerald-600 shadow-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/60" title="Configure" aria-pressed="false">
                <ion-icon name="construct-outline" class="text-lg"></ion-icon>
              </button>
            </div>
            <div class="flex items-center gap-2">
              <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-indigo-500 hover:text-indigo-600 opacity-50 pointer-events-none" id="btnAutoBacktest" disabled data-state="idle">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" data-auto-icon="play"><path d="M4.5 3.75a.75.75 0 011.125-.65l9 5.25a.75.75 0 010 1.3l-9 5.25A.75.75 0 014 14.25V5.75a.75.75 0 01.5-.7z"/></svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 hidden" viewBox="0 0 20 20" fill="currentColor" data-auto-icon="pause"><path d="M6.75 4.5a.75.75 0 00-.75.75v9.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75v-9.5a.75.75 0 00-.75-.75h-1.5zm5 0a.75.75 0 00-.75.75v9.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75v-9.5a.75.75 0 00-.75-.75h-1.5z"/></svg>
                <span data-auto-label>Start Backtest</span>
              </button>
              <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-rose-200 bg-white px-3 py-2 text-sm font-medium text-rose-600 shadow-sm transition hover:border-rose-400 hover:text-rose-700 opacity-50 pointer-events-none" id="btnClearAuto" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M6.28 5.22a.75.75 0 10-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 101.06 1.06L10 11.06l3.72 3.72a.75.75 0 101.06-1.06L11.06 10l3.72-3.72a.75.75 0 10-1.06-1.06L10 8.94 6.28 5.22z"/></svg>
                <span>Clear Auto Data</span>
              </button>
            </div>
          </div>
          <div class="text-xs text-slate-500" id="autoResultsStatus">No auto backtest results yet.</div>
        </div>
      </div>
      <div id="autoConfigPanel" class="hidden rounded-2xl border border-dashed border-emerald-300 bg-emerald-50/40 p-4">
        <div class="mt-4">
          <div class="mt-2 grid grid-cols-5 gap-4">

            <!-- Column 1 -->
            <div class="mt-2 space-y-2">
              <h4 class="text-xs font-semibold uppercase tracking-wide text-slate-500">Configure ORB Window</h4>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">Min (minutes)</span>
                <div class="mt-1 relative">
                  <input id="autoOrbMin" type="number" min="1" max="120" step="1" value="5" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm font-mono" />
                  <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase ORB min" data-num-target="autoOrbMin" data-num-step="5">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                    </button>
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease ORB min" data-num-target="autoOrbMin" data-num-step="-5">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                    </button>
                  </div>
                </div>
              </label>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">Max (minutes)</span>
                <div class="mt-1 relative">
                  <input id="autoOrbMax" type="number" min="5" max="240" step="5" value="60" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm font-mono" />
                  <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase ORB max" data-num-target="autoOrbMax" data-num-step="5">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                    </button>
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease ORB max" data-num-target="autoOrbMax" data-num-step="-5">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                    </button>
                  </div>
                </div>
              </label>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">Step (minutes)</span>
                <div class="mt-1 relative">
                  <input id="autoOrbStep" type="number" min="1" max="30" step="1" value="5" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm font-mono" />
                  <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase ORB step" data-num-target="autoOrbStep" data-num-step="1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                    </button>
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease ORB step" data-num-target="autoOrbStep" data-num-step="-1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                    </button>
                  </div>
                </div>
              </label>
            </div>

            <!-- Column 2 -->
            <div class="mt-2 space-y-2">
              <h4 class="text-xs font-semibold uppercase tracking-wide text-slate-500">Configure Target</h4>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">R</span>
                <div class="mt-1 relative">
                  <input id="autoTargetMin" type="number" min="0.1" max="20" step="0.1" value="0.3" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm font-mono" />
                  <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase ORB min" data-num-target="autoTargetMin" data-num-step="1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                    </button>
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease ORB min" data-num-target="autoTargetMin" data-num-step="-1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                    </button>
                  </div>
                </div>
              </label>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">Stop</span>
                <div class="mt-1 relative">
                  <input id="autoTargetMax" type="number" min="0.1" max="20" step="0.1" value="2" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm font-mono" />
                  <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase ORB max" data-num-target="autoTargetMax" data-num-step="1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                    </button>
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease ORB max" data-num-target="autoTargetMax" data-num-step="-1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                    </button>
                  </div>
                </div>
              </label>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">Step</span>
                <div class="mt-1 relative">
                  <input id="autoTargetStep" type="number" min="0.1" max="1" step="0.1" value="0.1" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm font-mono" />
                  <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase Target step" data-num-target="autoTargetStep" data-num-step="1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                    </button>
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease Target step" data-num-target="autoTargetStep" data-num-step="-1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                    </button>
                  </div>
                </div>
              </label>
            </div>

            <!-- Column 3 -->
            <div class="mt-2 space-y-2">
              <h4 class="text-xs font-semibold uppercase tracking-wide text-slate-500">Configure Stop</h4>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">R</span>
                <div class="mt-1 relative">
                  <input id="autoStopMin" type="number" min="0.1" max="20" step="0.1" value="0.3" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm font-mono" />
                  <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase Stop min" data-num-target="autoStopMin" data-num-step="1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                    </button>
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease Stop min" data-num-target="autoStopMin" data-num-step="-1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                    </button>
                  </div>
                </div>
              </label>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">Stop</span>
                <div class="mt-1 relative">
                  <input id="autoStopMax" type="number" min="0.1" max="20" step="0.1" value="2" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm font-mono" />
                  <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase Stop max" data-num-target="autoStopMax" data-num-step="1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                    </button>
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease Stop max" data-num-target="autoStopMax" data-num-step="-1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                    </button>
                  </div>
                </div>
              </label>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">Step</span>
                <div class="mt-1 relative">
                  <input id="autoStopStep" type="number" min="0.1" max="1" step="0.1" value="0.1" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm font-mono" />
                  <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase Stop step" data-num-target="autoStopStep" data-num-step="0.1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                    </button>
                    <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease Stop step" data-num-target="autoStopStep" data-num-step="-0.1">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                    </button>
                  </div>
                </div>
              </label>
            </div>

            <!-- Column 4 - Placeholder -->
            <div>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">Placeholder 4</span>
                <div class="mt-1">
                  <div class="w-full h-[38px] bg-slate-100 rounded-xl border border-slate-300 flex items-center justify-center text-slate-400 text-sm">Placeholder</div>
                </div>
              </label>
            </div>

            <!-- Column 5 - Placeholder -->
            <div>
              <label class="block text-xs text-slate-600">
                <span class="font-semibold text-slate-700">Placeholder 5</span>
                <div class="mt-1">
                  <div class="w-full h-[38px] bg-slate-100 rounded-xl border border-slate-300 flex items-center justify-center text-slate-400 text-sm">Placeholder</div>
                </div>
              </label>
            </div>
          </div>
        </div>

      </div>
      <div class="overflow-x-auto border border-slate-200 rounded-xl max-h-96">
        <table class="min-w-full text-sm">
          <thead class="bg-slate-50 text-slate-600">
            <tr>
              <th class="px-3 py-2 text-left font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="strategyId">
                  <span>Strategy</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="sortino">
                  <span>Sortino</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="mar">
                  <span>MAR</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="totalPnL">
                  <span>Total PnL</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="winPct">
                  <span>Win %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="avgDaily">
                  <span>Avg Daily %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="cagr">
                  <span>CAGR %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="maxDD">
                  <span>Max DD %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="athDayPct">
                  <span>ATH Day %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="orb_m">
                  <span>ORB (m)</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="tp_R">
                  <span>TP R</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="sl_R">
                  <span>SL R</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="start">
                  <span>Start</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="end">
                  <span>End</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="direction">
                  <span>Direction</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
            </tr>
          </thead>
          <tbody id="autoResultsTableBody">
            <tr class="border-b last:border-b-0">
              <td colspan="16" class="px-3 py-4 text-center text-sm text-slate-500">No auto backtest results yet.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <section id="livePanel" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 hidden space-y-4" data-tab-panel="live">
      <div>
        <h2 class="font-semibold inline-flex items-center gap-2 text-slate-700">
          <ion-icon name="pulse-outline" class="text-emerald-500 text-xl"></ion-icon>
          <span>Live Strategies</span>
        </h2>
        <p class="text-sm text-slate-500">Strategies currently marked as live for this symbol.</p>
      </div>
      <div class="overflow-x-auto border border-slate-200 rounded-xl max-h-[65vh]">
        <table class="min-w-full text-sm">
          <thead class="bg-slate-50 text-slate-600">
            <tr>
              <th class="px-3 py-2 text-left font-medium">Strategy</th>
              <th class="px-3 py-2 text-center font-medium">Favorite</th>
              <th class="px-3 py-2 text-right font-medium">Days</th>
              <th class="px-3 py-2 text-right font-medium">Trades</th>
              <th class="px-3 py-2 text-right font-medium">Win %</th>
              <th class="px-3 py-2 text-right font-medium">Total PnL</th>
              <th class="px-3 py-2 text-right font-medium">Avg Daily %</th>
              <th class="px-3 py-2 text-right font-medium">CAGR %</th>
              <th class="px-3 py-2 text-right font-medium">Max DD %</th>
              <th class="px-3 py-2 text-right font-medium">MAR</th>
              <th class="px-3 py-2 text-right font-medium">Sortino</th>
              <th class="px-3 py-2 text-right font-medium">ATH Day %</th>
            </tr>
          </thead>
          <tbody id="liveTableBody">
            <tr class="border-b last:border-b-0">
              <td colspan="12" class="px-3 py-4 text-center text-sm text-slate-500">No live strategies yet for this symbol.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <section id="favoritesPanel" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 hidden space-y-4" data-tab-panel="favorites">
      <div>
        <h2 class="font-semibold inline-flex items-center gap-2 text-slate-700">
          <ion-icon name="heart-outline" class="text-emerald-500 text-xl"></ion-icon>
          <span>Favorite Strategies</span>
        </h2>
        <p class="text-sm text-slate-500">Favorites saved for the currently selected symbol.</p>
      </div>
      <div class="overflow-x-auto border border-slate-200 rounded-xl max-h-[65vh]">
        <table class="min-w-full text-sm">
          <thead class="bg-slate-50 text-slate-600">
            <tr>
              <th class="px-3 py-2 text-left font-medium">Strategy</th>
              <th class="px-3 py-2 text-center font-medium">Live</th>
              <th class="px-3 py-2 text-right font-medium">Days</th>
              <th class="px-3 py-2 text-right font-medium">Trades</th>
              <th class="px-3 py-2 text-right font-medium">Win %</th>
              <th class="px-3 py-2 text-right font-medium">Total PnL</th>
              <th class="px-3 py-2 text-right font-medium">Avg Daily %</th>
              <th class="px-3 py-2 text-right font-medium">CAGR %</th>
              <th class="px-3 py-2 text-right font-medium">Max DD %</th>
              <th class="px-3 py-2 text-right font-medium">MAR</th>
              <th class="px-3 py-2 text-right font-medium">Sortino</th>
              <th class="px-3 py-2 text-right font-medium">ATH Day %</th>
            </tr>
          </thead>
          <tbody id="favoritesTableBody">
            <tr class="border-b last:border-b-0">
              <td colspan="12" class="px-3 py-4 text-center text-sm text-slate-500">No favorites yet for this symbol.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <section id="portfolioPanel" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 hidden" data-tab-panel="portfolio">
      <div id="portfolioSection" class="space-y-4">
        <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
          <div>
            <h2 class="font-semibold inline-flex items-center gap-2 text-slate-700">
              <ion-icon name="briefcase-outline" class="text-emerald-500 text-xl"></ion-icon>
              <span>Portfolio</span>
            </h2>
            <p class="text-sm text-slate-500">Saved backtests are stored locally in IndexedDB.</p>
          </div>
          <div class="flex flex-wrap items-center gap-2 justify-end">
            <button id="btnCreatePortfolio" type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600">
              <i class="fa fa-regular fa-square-plus"></i>
              <span>New Portfolio</span>
            </button>
            <div class="relative min-w-[200px]">
              <select id="portfolioSelect" class="appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-8 py-2 text-sm text-slate-600 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60 min-w-[200px] opacity-50 pointer-events-none" disabled>
                <option value="">Load Portfolio…</option>
              </select>
              <span class="pointer-events-none absolute inset-y-0 right-3 inline-flex items-center text-slate-400">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
            <button id="btnRunPortfolio" type="button" class="inline-flex items-center gap-2 rounded-xl border border-emerald-500/40 bg-emerald-50 px-3 py-2 text-sm font-medium text-emerald-700 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600">
              <i class="fa fa-regular fa-circle-play"></i>
              <span>Run Portfolio</span>
            </button>
            <button id="btnClearPortfolio" type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-rose-500 hover:text-rose-600">
              <span>Clear All</span>
            </button>
          </div>
        </div>
        <div class="overflow-x-auto">
          <table class="min-w-full text-sm">
            <thead class="bg-slate-50 text-slate-600">
              <tr>
                <th class="px-3 py-2 w-10">
                  <label class="inline-flex cursor-pointer items-center justify-center">
                    <input type="checkbox" class="peer sr-only" id="portfolioIncludeAll" aria-label="Toggle all portfolio strategies" checked />
                    <span class="inline-flex h-5 w-5 select-none items-center justify-center rounded-md border border-slate-300 bg-white text-xs font-bold text-transparent transition peer-checked:border-emerald-500 peer-checked:bg-emerald-500 peer-checked:text-white">
                      &#10003;
                    </span>
                  </label>
                </th>
                <th class="px-3 py-2 text-left font-medium">Strategy</th>
                <th class="px-3 py-2 text-center font-medium">Live</th>
                <th class="px-3 py-2 text-right font-medium">Days</th>
                <th class="px-3 py-2 text-right font-medium">Trades</th>
                <th class="px-3 py-2 text-right font-medium">Win %</th>
                <th class="px-3 py-2 text-right font-medium">Total PnL</th>
                <th class="px-3 py-2 text-right font-medium">Avg Daily %</th>
                <th class="px-3 py-2 text-right font-medium">CAGR %</th>
                <th class="px-3 py-2 text-right font-medium">Max DD %</th>
                <th class="px-3 py-2 text-right font-medium">MAR</th>
                <th class="px-3 py-2 text-right font-medium">Actions</th>
              </tr>
            </thead>
            <tbody id="portfolioTableBody">
              <tr>
                <td colspan="12" class="px-3 py-4 text-center text-sm text-slate-500">No saved strategies yet.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- Filters -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6" data-shared-section="filters">
      <h2 class="font-semibold mb-3">Filters</h2>
      <div class="flex flex-wrap items-center gap-3">
        <div id="dirSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden" aria-label="Direction">
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white" data-dir="both">Both</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-l border-slate-200" data-dir="long">Long</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-l border-slate-200" data-dir="short">Short</button>
        </div>

        <div id="dowSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden" aria-label="Weekdays">
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white" data-dow="1">Mon</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="2">Tue</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="3">Wed</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="4">Thu</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="5">Fri</button>
        </div>

        <div class="relative inline-block" aria-label="Months">
          <button id="sumMonthMultiBtn" type="button" class="inline-flex items-center justify-between gap-2 bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm min-w-[160px]">
            <span id="sumMonthMultiLabel" class="truncate">All months</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
          </button>
          <div id="sumMonthMultiMenu" class="absolute z-30 mt-1 w-64 bg-white border border-slate-200 rounded-xl shadow-soft p-2 hidden">
            <div class="sticky top-0 bg-white z-10 px-2 pb-2 border-b border-slate-200 flex items-center justify-between gap-2">
              <button id="sumMonthSelectAll" type="button" class="text-xs font-medium text-emerald-700 hover:text-emerald-900 hover:underline">Select all</button>
              <button id="sumMonthClearAll" type="button" class="text-xs text-slate-600 hover:text-slate-800 hover:underline">Clear</button>
            </div>
            <div id="sumMonthMultiList" class="max-h-64 overflow-auto"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Summary -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <h2 class="font-semibold mb-3" id="summaryTitle">Summary</h2>
      <div id="summary" class="grid sm:grid-cols-2 lg:grid-cols-2 gap-4"></div>
    </section>
    
    <!-- Equity Chart -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <h2 class="font-semibold mb-3" id="equityTitle">Equity Curve</h2>
      <div id="equityChart" class="w-full h-[360px]"></div>
    </section>

    <!-- Drawdown Chart -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-semibold" id="drawdownTitle">Drawdown</h2>
        <div class="inline-flex items-center gap-0.5 rounded-xl bg-slate-100 p-0.5" aria-label="Drawdown mode">
          <button id="ddBtnPct" type="button" class="px-2 py-1 text-xs rounded-lg">%</button>
          <button id="ddBtnUsd" type="button" class="px-2 py-1 text-xs rounded-lg">$</button>
        </div>
      </div>
      <div id="drawdownChart" class="w-full h-[320px]"></div>
    </section>

    <!-- Win/Loss Streaks Chart -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <h2 class="font-semibold mb-3" id="streakTitle">Win/Loss Streaks</h2>
      <div id="streakChart" class="w-full h-[280px]"></div>
    </section>

    <!-- Monthly Performance -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-semibold" id="monthlyTitle">Monthly Performance</h2>
        <div class="inline-flex items-center gap-0.5 rounded-xl bg-slate-100 p-0.5" aria-label="Monthly performance mode">
          <button id="mpBtnPct" type="button" class="px-2 py-1 text-xs rounded-lg">%</button>
          <button id="mpBtnUsd" type="button" class="px-2 py-1 text-xs rounded-lg">$</button>
        </div>
      </div>
      <div id="monthlyPerf"></div>
    </section>

    <!-- Trades Table -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-semibold">Trades</h2>
        <button id="btnExportCSV" type="button" class="px-3 py-1.5 text-sm rounded-lg bg-white ring-1 ring-slate-300 hover:bg-slate-100">Export CSV</button>
      </div>
      <div class="overflow-auto max-h-[65vh] border rounded-xl">
        <table class="min-w-full text-sm">
          <thead>
            <tr class="border-b">
              <th class="px-3 py-2 text-left">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="date">
                  <span>Date</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="orh">
                  <span>ORH</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="orl">
                  <span>ORL</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="range">
                  <span>OR</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="rangePct">
                  <span>OR%</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="side">
                  <span>Side</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="entryTime">
                  <span>EntryTime</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="exitTime">
                  <span>ExitTime</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="entry">
                  <span>Entry</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="exit">
                  <span>Exit</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="stop">
                  <span>LossPrice</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="tp">
                  <span>TPPrice</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="hitType">
                  <span>HitType</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="shares">
                  <span>Shares</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="pnl">
                  <span>PnL</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="pnlR">
                  <span>pnl_R</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="aum">
                  <span>AUM</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right">
                <button type="button" class="inline-flex w-full items-center justify-end gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="dailyReturn">
                  <span>DailyReturn %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-trade-sort="strategy">
                  <span>Strategy</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </section>
  </div>

  <script type="module" src="scripts/optimizer.js"></script>
  <script>
    // -----------------------------
    // Utilities
    // -----------------------------
    const pad2 = (n) => String(n).padStart(2, '0');
    const dateKeyFromStr = (val) => {
      if (val == null) return null;
      if (typeof val === 'string') {
        const m = val.trim().match(/^(\d{4}-\d{2}-\d{2})/);
        if (m) return m[1];
      }
      const d = new Date(val);
      if (isNaN(d)) return null;
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`; // local date key
    };
    const parseTimeHHMM = (hhmm) => { const [h, m] = (hhmm || '').split(':').map(Number); return h * 60 + (m || 0); };
  const toHHMM = (mins) => { const h = Math.floor((mins % (24*60) + 24*60) % (24*60) / 60); const m = ((mins % 60) + 60) % 60; return `${pad2(h)}:${pad2(m)}`; };
    const minutesOfDay = (d) => d.getHours() * 60 + d.getMinutes();
    const fmtNum = (x, digits = 2) => (x == null || isNaN(x) ? '' : Number(x).toFixed(digits));
    const fmtMoney = (x) => (x == null || isNaN(x) ? '' : Number(x).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }));
    const fmtInt = (x) => (x == null || isNaN(x) ? '0' : Math.round(Number(x)).toLocaleString());
    const fmtPct = (x) => (x == null || isNaN(x) ? '' : Number(x).toFixed(2));
    const fmtTime = (d) => d instanceof Date && !isNaN(d) ? `${pad2(d.getHours())}:${pad2(d.getMinutes())}` : '';
    const fmtCompactMoney = (value) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      const abs = Math.abs(num);
      const sign = num < 0 ? '-' : '';
      let scaled = abs;
      let suffix = '';
      if (abs >= 1e12) {
        scaled = abs / 1e12;
        suffix = 'T';
      } else if (abs >= 1e9) {
        scaled = abs / 1e9;
        suffix = 'B';
      } else if (abs >= 1e6) {
        scaled = abs / 1e6;
        suffix = 'M';
      } else if (abs >= 1e3) {
        scaled = abs / 1e3;
        suffix = 'K';
      } else {
        return `${sign}$${Math.round(abs).toLocaleString()}`;
      }
      const digits = scaled >= 10 ? 0 : 1;
      const scaledStr = scaled.toFixed(digits).replace(/\.0$/, '');
      return `${sign}$${scaledStr}${suffix}`;
    };

    const DEFAULT_PRICE_PRECISION = 2;

    const getContractSpec = (symbol) => {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return { multiplier: 1, maxLeverage: null };
      const meta = ensureSymbolMetaEntry(sym);
      if (meta) {
        const mul = Number(meta.multiplier);
        if (Number.isFinite(mul) && mul > 0) {
          return { multiplier: mul, maxLeverage: null };
        }
      }
      return { multiplier: 1, maxLeverage: null };
    };

    // -----------------------------
    // Global state
    // -----------------------------
    let currentTicker = '';
    let ROWS = [];        // current symbol rows
    let DAY_GROUPS = new Map();
    let DAYS = [];
    let SYMBOL_META = new Map();

    function ensureSymbolMetaEntry(symbol) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return null;
      if (!SYMBOL_META.has(sym)) {
        SYMBOL_META.set(sym, { symbol: sym, name: sym, multiplier: 1, precision: null });
      }
      const meta = SYMBOL_META.get(sym);
      if (meta && !meta.symbol) meta.symbol = sym;
      return meta || null;
    }

    function getSymbolPrecision(symbol) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return DEFAULT_PRICE_PRECISION;
      const meta = SYMBOL_META.get(sym);
      const precision = meta && Number.isInteger(meta.precision) && meta.precision >= 0 ? meta.precision : null;
      return Number.isInteger(precision) ? precision : DEFAULT_PRICE_PRECISION;
    }

    function fmtPrice(value, symbol = currentTicker) {
      if (value == null) return '';
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      const precision = Math.min(Math.max(getSymbolPrecision(symbol), 0), 8);
      let str = num.toFixed(precision);
      if (str.startsWith('-0.') && Number(str) === 0) {
        str = str.slice(1);
      }
      return str;
    }

    function countPriceDecimals(value) {
      if (!Number.isFinite(value)) return 0;
      const str = Number(value).toFixed(8).replace(/0+$/,'').replace(/\.$/,'');
      const idx = str.indexOf('.');
      return idx >= 0 ? (str.length - idx - 1) : 0;
    }

    function inferPricePrecisionFromRows(rows) {
      if (!Array.isArray(rows)) return 0;
      let maxDecimals = 0;
      const limit = Math.min(rows.length, 400);
      for (let i = 0; i < limit; i++) {
        const row = rows[i];
        if (!row) continue;
        const values = [row.open, row.high, row.low, row.close];
        for (const val of values) {
          const decimals = countPriceDecimals(val);
          if (decimals > maxDecimals) maxDecimals = decimals;
          if (maxDecimals >= 6) return 6;
        }
      }
      return maxDecimals;
    }

    function updateSymbolPrecisionFromRows(symbol, rows) {
      const sym = (symbol || '').toUpperCase();
      if (!sym) return;
      const inferred = inferPricePrecisionFromRows(rows);
      const precision = Math.min(inferred > 0 ? inferred : DEFAULT_PRICE_PRECISION, 8);
      const meta = ensureSymbolMetaEntry(sym);
      if (meta) {
        meta.precision = precision;
        SYMBOL_META.set(sym, meta);
      }
    }

  let VIEW_DIR = 'both';
  let LAST_OUT = null;
  let CURRENT_STRATEGY_ID = null;
  let CURRENT_STRATEGY_PARAMS = null;
  let CURRENT_STRATEGY_FAVORITE = false;
  let CURRENT_STRATEGY_LIVE = false;
  let CURRENT_SYMBOL_FAVORITES = [];
  let CURRENT_SYMBOL_LIVE = [];
  let CURRENT_MODE_TAB = 'backtest';
  let AUTO_RESULTS_CACHE = new Map();
  let AUTO_RESULTS_LIST = [];
  let AUTO_RESULTS_SORT = { key: 'winPct', direction: 'desc' };
  let TRADES_SORT = { key: 'date', direction: 'desc' };
  const TRADE_SORT_DEFAULT_DIRECTION = {
    date: 'desc',
    side: 'asc',
    entryTime: 'asc',
    exitTime: 'asc',
    hitType: 'asc',
    strategy: 'asc'
  };
  const AUTO_SORT_DEFAULT_DIRECTION = {
    sortino: 'desc',
    athDayPct: 'desc',
    mar: 'desc',
    totalPnL: 'desc',
    cagr: 'desc',
    winPct: 'desc',
    maxDD: 'asc',
    strategyId: 'asc',
    direction: 'asc',
    start: 'asc',
    end: 'asc'
  };
  const AUTO_SORT_LABELS = {
    sortino: 'Sortino',
    athDayPct: 'ATH Day %',
    mar: 'MAR',
    totalPnL: 'Total PnL',
    cagr: 'CAGR %',
    maxDD: 'Max DD %',
    winPct: 'Win %',
    avgDaily: 'Avg Daily %'
  };
  const AUTO_MAX_DD_LIMIT = 30; // percent drawdown ceiling for auto results
  const AUTO_MAX_INDETERMINATE_PCT = 3; // maximum reachable % of indeterminate trades
  const AUTO_SORTINO_CACHE = new WeakMap();
  const AUTO_MAXDD_CACHE = new WeakMap();
  const AUTO_INDET_CACHE = new WeakMap();
  let AUTO_BACKTEST_TOTAL_COUNT = 0;
  let LAST_PORTFOLIO_RUN = false;
  let AUTO_CONFIG_EXPANDED = false;
  const PORTFOLIO_LIST_STORAGE_KEY = 'orbPortfolioList_v1';
  const PORTFOLIO_ACTIVE_STORAGE_KEY = 'orbPortfolioActive_v1';
  let PORTFOLIO_LIST = [];
  let CURRENT_PORTFOLIO_ID = '';
    let PORTFOLIO_CACHE = new Map();
    let PORTFOLIO_INCLUDE_STATE = new Map();
    const AUTO_BACKTEST_STATE_STORAGE_KEY = 'orbAutoBacktestState_v1';
    let AUTO_BACKTEST_RUNNING = false;
    let AUTO_BACKTEST_PAUSE_REQUESTED = false;
    let AUTO_BACKTEST_PAUSED = false;
    let AUTO_BACKTEST_STATE_MAP = loadAutoBacktestState();
    let VIEW_DOW = new Set([1, 2, 3, 4, 5]); // 1=Mon ... 5=Fri
    let VIEW_MONTHS = new Set(); // empty => all
    let AVAILABLE_MONTHS = [];
    let SESSION_OPTIONS = [];
    let CURRENT_SESSION_NAME = null;
  // ECharts instances
  let equityChartInst = null;
  let drawdownChartInst = null;
  let streakChartInst = null;
  let dailyOutcomeChartInst = null;
  let PORTFOLIO_EQUITY_SERIES = null;

  function getAutoSummary(entry) {
    return entry && entry.summary ? entry.summary : {};
  }

  function getAutoSortino(entry) {
    if (!entry) return null;
    if (AUTO_SORTINO_CACHE.has(entry)) return AUTO_SORTINO_CACHE.get(entry);
    const summary = getAutoSummary(entry);
    const val = Number(summary.sortinoRatio);
    if (Number.isFinite(val)) {
      AUTO_SORTINO_CACHE.set(entry, val);
      return val;
    }
    return null;
  }

  function getAutoMaxDD(entry) {
    if (!entry) return null;
    if (AUTO_MAXDD_CACHE.has(entry)) return AUTO_MAXDD_CACHE.get(entry);
    const summary = getAutoSummary(entry);
    const val = Number(summary.maxDDPct);
    if (Number.isFinite(val)) {
      AUTO_MAXDD_CACHE.set(entry, val);
      return val;
    }
    return null;
  }

  function getAutoIndeterminatePct(entry) {
    if (!entry) return null;
    if (AUTO_INDET_CACHE.has(entry)) return AUTO_INDET_CACHE.get(entry);
    const summary = getAutoSummary(entry);
    const tradeCounts = summary && summary.tradeCounts ? summary.tradeCounts : {};
    let pct = tradeCounts && tradeCounts.pct ? Number(tradeCounts.pct.indeterminate) : NaN;
    if (!Number.isFinite(pct)) {
      const total = Number(tradeCounts.total);
      const indetCount = Number(tradeCounts.indeterminate);
      if (Number.isFinite(total) && total > 0 && Number.isFinite(indetCount) && indetCount >= 0) {
        pct = Number(((indetCount / total) * 100).toFixed(2));
      }
    }
    if (Number.isFinite(pct)) {
      AUTO_INDET_CACHE.set(entry, pct);
      return pct;
    }
    return null;
  }

  function autoEntryPassesFilters(entry) {
    const sortino = getAutoSortino(entry);
    const maxDD = getAutoMaxDD(entry);
    const indetPct = getAutoIndeterminatePct(entry);
    if (sortino == null || maxDD == null || indetPct == null) return false;
    if (!(Math.abs(maxDD) <= AUTO_MAX_DD_LIMIT)) return false;
    return indetPct <= AUTO_MAX_INDETERMINATE_PCT;
  }

  function compareAutoEntriesFallback(a, b) {
    const sortinoA = getAutoSortino(a);
    const sortinoB = getAutoSortino(b);
    const scoreA = Number.isFinite(sortinoA) ? sortinoA : -Infinity;
    const scoreB = Number.isFinite(sortinoB) ? sortinoB : -Infinity;
    if (scoreB !== scoreA) return scoreB - scoreA;

    const maxDDA = getAutoMaxDD(a);
    const maxDDB = getAutoMaxDD(b);
    const ddA = Number.isFinite(maxDDA) ? Math.abs(maxDDA) : Infinity;
    const ddB = Number.isFinite(maxDDB) ? Math.abs(maxDDB) : Infinity;
    if (ddA !== ddB) return ddA - ddB; // prefer lower drawdown

    const indetA = getAutoIndeterminatePct(a);
    const indetB = getAutoIndeterminatePct(b);
    const inA = Number.isFinite(indetA) ? indetA : Infinity;
    const inB = Number.isFinite(indetB) ? indetB : Infinity;
    if (inA !== inB) return inA - inB; // prefer fewer indeterminates

    const marA = Number.isFinite(Number(a && a.mar)) ? Number(a.mar) : -Infinity;
    const marB = Number.isFinite(Number(b && b.mar)) ? Number(b.mar) : -Infinity;
    return marB - marA;
  }

  function compareAutoEntries(a, b, sortConfig = AUTO_RESULTS_SORT) {
    const key = sortConfig && sortConfig.key ? sortConfig.key : 'winPct';
    const direction = sortConfig && sortConfig.direction ? sortConfig.direction : (AUTO_SORT_DEFAULT_DIRECTION[key] || 'desc');
    const factor = direction === 'asc' ? 1 : -1;
    const va = getAutoResultValue(a, key);
    const vb = getAutoResultValue(b, key);
    const aNull = va == null || (typeof va === 'number' && !Number.isFinite(va));
    const bNull = vb == null || (typeof vb === 'number' && !Number.isFinite(vb));
    if (aNull && bNull) return compareAutoEntriesFallback(a, b);
    if (aNull) return 1;
    if (bNull) return -1;
    let compA = va;
    let compB = vb;
    if (key === 'maxDD') {
      if (typeof compA === 'number' && Number.isFinite(compA)) compA = Math.abs(compA);
      if (typeof compB === 'number' && Number.isFinite(compB)) compB = Math.abs(compB);
    }
    if (typeof compA === 'string' || typeof compB === 'string') {
      const cmp = String(compA).localeCompare(String(compB), undefined, { numeric: true });
      if (cmp !== 0) return factor * cmp;
    } else if (compA !== compB) {
      if (compA > compB) return factor;
      if (compA < compB) return -factor;
    }
    return compareAutoEntriesFallback(a, b);
  }

  function formatAutoMetricValue(key, value) {
    if (!Number.isFinite(value)) return '—';
    switch (key) {
      case 'athDayPct':
      case 'cagr':
      case 'maxDD':
      case 'winPct':
      case 'avgDaily':
        return `${value.toFixed(2)}%`;
      case 'totalPnL':
        return `$${value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
      case 'sortino':
      case 'mar':
        return value.toFixed(2);
      default:
        return String(value);
    }
  }

  function getBestAutoMetric(entry, sortConfig = AUTO_RESULTS_SORT) {
    const key = sortConfig && sortConfig.key ? sortConfig.key : 'winPct';
    const rawValue = entry ? getAutoResultValue(entry, key) : null;
    const label = AUTO_SORT_LABELS[key] || key;
    if (typeof rawValue === 'string') {
      const trimmed = rawValue.trim();
      return { key, label, raw: null, display: trimmed || '—' };
    }
    const numeric = Number(rawValue);
    const isFiniteVal = Number.isFinite(numeric);
    const display = formatAutoMetricValue(key, isFiniteVal ? numeric : null);
    return { key, label, raw: isFiniteVal ? numeric : null, display };
  }

  function formatAutoRunCount(count) {
    const num = Number(count);
    if (!Number.isFinite(num) || num < 0) return '0';
    try {
      return num.toLocaleString();
    } catch {
      return String(Math.trunc(num));
    }
  }

  function syncAddPortfolioButton() {
    const btn = document.getElementById('btnAddPortfolio');
    if (!btn) return;
    const label = btn.querySelector('[data-portfolio-add-label]');
    const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
    if (label) label.textContent = `Add to ${portfolioName}`;
  }

  function setPortfolioSelectDisabled(disabled) {
    const select = document.getElementById('portfolioSelect');
    if (!select) return;
    select.disabled = !!disabled;
    select.classList.toggle('opacity-50', !!disabled);
    select.classList.toggle('pointer-events-none', !!disabled);
  }

  function applySectionTitle(id, baseLabel) {
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = LAST_PORTFOLIO_RUN ? `${baseLabel} (Portfolio)` : baseLabel;
  }

  function setPortfolioContext(isPortfolio) {
    LAST_PORTFOLIO_RUN = !!isPortfolio;
    applySectionTitle('summaryTitle', 'Summary');
    applySectionTitle('equityTitle', 'Equity Curve');
    applySectionTitle('drawdownTitle', 'Drawdown');
    applySectionTitle('streakTitle', 'Win/Loss Streaks');
    applySectionTitle('monthlyTitle', 'Monthly Performance');
    syncAddPortfolioButton();
  }

  function getDefaultPortfolioName() {
    return 'Portfolio 1';
  }

  function loadPortfolioListFromStorage() {
    if (typeof localStorage === 'undefined') return [];
    try {
      const raw = localStorage.getItem(PORTFOLIO_LIST_STORAGE_KEY);
      const parsed = raw ? JSON.parse(raw) : [];
      return Array.isArray(parsed) ? parsed.filter(Boolean) : [];
    } catch {
      return [];
    }
  }

  function savePortfolioListToStorage(list) {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem(PORTFOLIO_LIST_STORAGE_KEY, JSON.stringify(list));
    } catch {}
  }

  function saveActivePortfolio(id) {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem(PORTFOLIO_ACTIVE_STORAGE_KEY, id || '');
    } catch {}
  }

  function ensurePortfolioListLoaded() {
    if (!PORTFOLIO_LIST.length) {
      const stored = loadPortfolioListFromStorage();
      const list = stored.length ? stored.slice() : [getDefaultPortfolioName()];
      if (!list.includes(getDefaultPortfolioName())) list.unshift(getDefaultPortfolioName());
      PORTFOLIO_LIST = list;
    }
    let active = CURRENT_PORTFOLIO_ID && PORTFOLIO_LIST.includes(CURRENT_PORTFOLIO_ID) ? CURRENT_PORTFOLIO_ID : null;
    if (!active && typeof localStorage !== 'undefined') {
      try {
        const storedActive = localStorage.getItem(PORTFOLIO_ACTIVE_STORAGE_KEY);
        if (storedActive && PORTFOLIO_LIST.includes(storedActive)) {
          active = storedActive;
        }
      } catch {}
    }
    if (!active) {
      active = PORTFOLIO_LIST[0] || getDefaultPortfolioName();
    }
    if (!PORTFOLIO_LIST.includes(active)) PORTFOLIO_LIST.unshift(active);
    CURRENT_PORTFOLIO_ID = active;
    savePortfolioListToStorage(PORTFOLIO_LIST);
    saveActivePortfolio(CURRENT_PORTFOLIO_ID);
    syncAddPortfolioButton();
  }

  function populatePortfolioSelect() {
    ensurePortfolioListLoaded();
    const select = document.getElementById('portfolioSelect');
    if (!select) return;
    const frag = document.createDocumentFragment();
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Load Portfolio…';
    frag.appendChild(placeholder);
    PORTFOLIO_LIST.forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      frag.appendChild(opt);
    });
    select.innerHTML = '';
    select.appendChild(frag);
    const target = (CURRENT_PORTFOLIO_ID && PORTFOLIO_LIST.includes(CURRENT_PORTFOLIO_ID)) ? CURRENT_PORTFOLIO_ID : (PORTFOLIO_LIST[0] || '');
    if (target) {
      CURRENT_PORTFOLIO_ID = target;
      select.value = target;
    } else {
      select.value = '';
    }
    saveActivePortfolio(CURRENT_PORTFOLIO_ID);
    setPortfolioSelectDisabled(PORTFOLIO_LIST.length === 0);
    syncAddPortfolioButton();
  }

  function setCurrentPortfolio(id, { refresh = true } = {}) {
    ensurePortfolioListLoaded();
    if (!id) id = PORTFOLIO_LIST[0];
    if (!PORTFOLIO_LIST.includes(id)) {
      PORTFOLIO_LIST.push(id);
      savePortfolioListToStorage(PORTFOLIO_LIST);
    }
    CURRENT_PORTFOLIO_ID = id;
    const select = document.getElementById('portfolioSelect');
    if (select) {
      select.value = CURRENT_PORTFOLIO_ID;
    }
    saveActivePortfolio(CURRENT_PORTFOLIO_ID);
    setPortfolioContext(false);
    syncAddPortfolioButton();
    if (refresh) refreshPortfolioTable().catch(() => {});
  }

  function createNewPortfolio() {
    ensurePortfolioListLoaded();
    const base = 'Portfolio ';
    let maxNum = 0;
    PORTFOLIO_LIST.forEach(name => {
      const match = /^Portfolio\s+(\d+)$/.exec(name);
      if (match) {
        const num = parseInt(match[1], 10);
        if (Number.isFinite(num)) maxNum = Math.max(maxNum, num);
      }
    });
    const nextName = `${base}${maxNum + 1}`;
    PORTFOLIO_LIST.push(nextName);
    savePortfolioListToStorage(PORTFOLIO_LIST);
    populatePortfolioSelect();
    setCurrentPortfolio(nextName);
  }

  setPortfolioContext(false);

  const DEFAULT_VIEW_DOW = [1, 2, 3, 4, 5];
  const DEFAULT_MIN_OR_PERC = 0.2;
  const DB_CONFIG = { name: 'orbBacktestDB', version: 2, store: 'runs', autoStore: 'autoResults' };
  const AUTO_RESULTS_STORE = DB_CONFIG.autoStore;
  const PORTFOLIO_DB_CONFIG = { name: 'orb_portfolio', version: 1, store: 'entries' };
  let dbPromise = null;
  let portfolioDbPromise = null;

  function getDbInstance() {
    if (typeof indexedDB === 'undefined') {
      return Promise.reject(new Error('IndexedDB is not available in this environment'));
    }
    if (!dbPromise) {
      dbPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_CONFIG.name, DB_CONFIG.version);
        request.onerror = () => reject(request.error);
        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains(DB_CONFIG.store)) {
            db.createObjectStore(DB_CONFIG.store, { keyPath: 'id' });
          }
          if (AUTO_RESULTS_STORE && !db.objectStoreNames.contains(AUTO_RESULTS_STORE)) {
            const autoStore = db.createObjectStore(AUTO_RESULTS_STORE, { keyPath: 'id' });
            autoStore.createIndex('symbol', 'symbol', { unique: false });
            autoStore.createIndex('symbol_mar', ['symbol', 'mar'], { unique: false });
          }
        };
        request.onsuccess = () => resolve(request.result);
      }).catch(err => {
        dbPromise = null;
        throw err;
      });
    }
    return dbPromise;
  }

  async function getStrategyRecord(id) {
    if (!id) return null;
    try {
      const db = await getDbInstance();
      if (!db) return null;
      return await new Promise((resolve, reject) => {
        const tx = db.transaction(DB_CONFIG.store, 'readonly');
        const store = tx.objectStore(DB_CONFIG.store);
        const req = store.get(id);
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
      });
    } catch (err) {
      console.error('Failed to read strategy record', err);
      return null;
    }
  }

  async function fetchAutoResults(symbol) {
    if (!symbol || !AUTO_RESULTS_STORE) return [];
    const upper = String(symbol).toUpperCase();
    try {
      const db = await getDbInstance();
      if (!db || !db.objectStoreNames.contains(AUTO_RESULTS_STORE)) return [];
      return await new Promise((resolve, reject) => {
        const tx = db.transaction(AUTO_RESULTS_STORE, 'readonly');
        const store = tx.objectStore(AUTO_RESULTS_STORE);
        const index = store.index('symbol');
        const req = index.getAll(upper);
        req.onsuccess = () => resolve(Array.isArray(req.result) ? req.result : []);
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
    } catch (err) {
      console.error('Failed to fetch auto results', err);
      return [];
    }
  }

  async function updateAutoResultsStore(symbol, newEntries) {
    if (!symbol || !AUTO_RESULTS_STORE) return [];
    const upper = String(symbol).toUpperCase();
    try {
      const db = await getDbInstance();
      if (!db || !db.objectStoreNames.contains(AUTO_RESULTS_STORE)) return [];

      const existing = await fetchAutoResults(upper);
      const map = new Map();
      for (const rec of existing) {
        if (!rec || !rec.strategyId) continue;
        if (!autoEntryPassesFilters(rec)) continue;
        map.set(rec.strategyId, rec);
      }

      const entries = Array.isArray(newEntries) ? newEntries : [];
      for (const entry of entries) {
        if (!entry || !entry.params) continue;
        if (!autoEntryPassesFilters(entry)) continue;
        const strategyId = buildStrategyKey(entry.params);
        if (!strategyId) continue;
        const mar = Number(entry.mar);
        if (!Number.isFinite(mar)) continue;
        const record = {
          id: `${upper}::${strategyId}`,
          symbol: upper,
          strategyId,
          mar,
          params: sanitizeParamsForStorage(entry.params),
          summary: entry.summary || null,
          combo: entry.combo || null,
          elapsedMs: Number.isFinite(entry.elapsedMs) ? Number(entry.elapsedMs) : null,
          updatedAt: new Date().toISOString()
        };
        const existingRec = map.get(strategyId);
        if (!existingRec || compareAutoEntries(existingRec, record, AUTO_RESULTS_SORT) > 0) {
          map.set(strategyId, record);
        }
      }

      const merged = Array.from(map.values())
        .filter(autoEntryPassesFilters)
        .sort((a, b) => compareAutoEntries(a, b, AUTO_RESULTS_SORT))
        .slice(0, 20);

      await new Promise((resolve, reject) => {
        const tx = db.transaction(AUTO_RESULTS_STORE, 'readwrite');
        const store = tx.objectStore(AUTO_RESULTS_STORE);
        const index = store.index('symbol');
        const cursorReq = index.openCursor(upper);
        cursorReq.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            store.delete(cursor.primaryKey);
            cursor.continue();
          } else {
            for (const rec of merged) {
              store.put(rec);
            }
          }
        };
        cursorReq.onerror = () => reject(cursorReq.error || new Error('IndexedDB cursor failed'));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });

      return merged;
    } catch (err) {
      console.error('Failed to update auto results store', err);
      return [];
    }
  }

  async function clearAutoResultsForSymbol(symbol) {
    if (!symbol || !AUTO_RESULTS_STORE) return;
    const upper = String(symbol).toUpperCase();
    try {
      const db = await getDbInstance();
      if (!db || !db.objectStoreNames.contains(AUTO_RESULTS_STORE)) return;
      await new Promise((resolve, reject) => {
        const tx = db.transaction(AUTO_RESULTS_STORE, 'readwrite');
        const store = tx.objectStore(AUTO_RESULTS_STORE);
        const index = store.index('symbol');
        const req = index.openCursor(upper);
        req.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            store.delete(cursor.primaryKey);
            cursor.continue();
          } else {
            resolve();
          }
        };
        req.onerror = () => reject(req.error || new Error('IndexedDB cursor failed'));
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
      AUTO_RESULTS_CACHE = new Map();
      AUTO_RESULTS_LIST = [];
      AUTO_RESULTS_SORT = { key: 'winPct', direction: 'desc' };
    } catch (err) {
      console.error('Failed to clear auto results', err);
    }
  }

  function renderAutoResultsTable(entries) {
    const tbody = document.getElementById('autoResultsTableBody');
    const statusEl = document.getElementById('autoResultsStatus');
    if (!tbody) return;
    tbody.innerHTML = '';

    if (!Array.isArray(entries) || entries.length === 0) {
      if (statusEl) statusEl.textContent = 'No auto backtest results yet.';
      const tr = document.createElement('tr');
      tr.innerHTML = '<td colspan="15" class="px-3 py-4 text-center text-sm text-slate-500">No auto backtest results yet.</td>';
      tbody.appendChild(tr);
      return;
    }

    if (statusEl) {
      const symbolLabel = currentTicker ? currentTicker.toUpperCase() : 'current symbol';
      statusEl.textContent = `Top ${entries.length} result${entries.length === 1 ? '' : 's'} for ${symbolLabel}.`;
    }

    entries.forEach((entry) => {
      const params = entry && entry.params ? entry.params : {};
      const dir = params.direction ? String(params.direction).toUpperCase() : (entry && entry.combo && entry.combo.direction ? String(entry.combo.direction).toUpperCase() : '');
      const mar = Number(entry && entry.mar);
      const orbVal = params.orb_m ?? (entry && entry.combo ? entry.combo.orb_m : null);
      const tpValRaw = params.target_R ?? params.tp_R ?? (entry && entry.combo ? entry.combo.tp_R : null);
      const slValRaw = params.stop_R ?? params.sl_R ?? (entry && entry.combo ? entry.combo.sl_R : null);
      const tpVal = Number(tpValRaw);
      const slVal = Number(slValRaw);
      const tr = document.createElement('tr');
      const summary = entry && entry.summary ? entry.summary : {};
      const totalPnL = Number(summary.totalPnL);
      const avgDaily = Number(summary.avgDailyRet);
      const cagr = Number(summary.cagrPct);
      const maxDD = Number(summary.maxDDPct);
      const sortino = Number(summary.sortinoRatio);
      const athDayPct = Number(summary.athDayPct);
      const tradeCounts = summary && summary.tradeCounts ? summary.tradeCounts : {};
      const tradePct = tradeCounts && tradeCounts.pct ? tradeCounts.pct : {};
      let winPct = Number(tradePct.wins);
      if (!Number.isFinite(winPct)) {
        const totalTrades = Number(tradeCounts.total);
        const winsCount = Number(tradeCounts.wins);
        if (Number.isFinite(totalTrades) && totalTrades > 0 && Number.isFinite(winsCount) && winsCount >= 0) {
          winPct = (winsCount / totalTrades) * 100;
        }
      }
      const winPctDisplay = Number.isFinite(winPct) ? `${winPct.toFixed(2)}%` : '—';
      const totalPnLDisplay = Number.isFinite(totalPnL) ? `$${Math.round(totalPnL).toLocaleString()}` : '—';
      const avgDailyDisplay = Number.isFinite(avgDaily) ? `${avgDaily.toFixed(2)}%` : '—';
      const cagrDisplay = Number.isFinite(cagr) ? `${cagr.toFixed(2)}%` : '—';
      const maxDDDisplay = Number.isFinite(maxDD) ? `${maxDD.toFixed(2)}%` : '—';
      const sortinoDisplay = Number.isFinite(sortino) ? sortino.toFixed(2) : '—';
      const athDayDisplay = Number.isFinite(athDayPct) ? `${athDayPct.toFixed(2)}%` : '—';

      tr.innerHTML = `
        <td class="px-3 py-2 font-mono text-xs break-all"><button type="button" class="text-slate-700 hover:text-indigo-600" data-auto-load="${entry.strategyId || ''}">${entry.strategyId || ''}</button></td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${sortinoDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${Number.isFinite(mar) ? mar.toFixed(2) : ''}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${totalPnLDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${winPctDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${avgDailyDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${cagrDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${maxDDDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${athDayDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${orbVal ?? ''}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${Number.isFinite(tpVal) ? tpVal.toFixed(2) : (tpValRaw ?? '')}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${Number.isFinite(slVal) ? slVal.toFixed(2) : (slValRaw ?? '')}</td>
        <td class="px-3 py-2 text-sm">${params.orb_start_time || params.start_ny || ''}</td>
        <td class="px-3 py-2 text-sm">${params.orb_end_time || params.end_ny || ''}</td>
        <td class="px-3 py-2 text-sm">${dir}</td>`;
      tr.dataset.autostrategy = entry.strategyId || '';
      tr.className = 'border-b last:border-b-0 hover:bg-slate-50';
      tbody.appendChild(tr);
    });
    highlightAutoResultRow();
  }

  function highlightAutoResultRow() {
    document.querySelectorAll('[data-autostrategy]').forEach(row => {
      const active = row.dataset.autostrategy === CURRENT_STRATEGY_ID && CURRENT_STRATEGY_ID;
      row.classList.toggle('bg-indigo-50', active);
      row.classList.toggle('hover:bg-indigo-100', active);
      row.classList.toggle('hover:bg-slate-50', !active);
    });
  }

  function highlightPortfolioRow() {
    document.querySelectorAll('[data-portfolio-strategy]').forEach(row => {
      const active = row.dataset.portfolioStrategy === CURRENT_STRATEGY_ID && CURRENT_STRATEGY_ID;
      row.classList.toggle('bg-emerald-50', !!active);
      row.classList.toggle('hover:bg-emerald-100', !!active);
      row.classList.toggle('hover:bg-slate-50', !active);
      row.classList.toggle('border-emerald-200', !!active);
    });
  }

  function highlightFavoriteRow() {
    document.querySelectorAll('[data-favorite-strategy]').forEach(row => {
      const active = row.dataset.favoriteStrategy === CURRENT_STRATEGY_ID && CURRENT_STRATEGY_ID;
      row.classList.toggle('bg-indigo-50', !!active);
      row.classList.toggle('hover:bg-indigo-100', !!active);
      row.classList.toggle('hover:bg-slate-50', !active);
    });
  }

  function highlightLiveRow() {
    document.querySelectorAll('[data-live-strategy]').forEach(row => {
      const active = row.dataset.liveStrategy === CURRENT_STRATEGY_ID && CURRENT_STRATEGY_ID;
      row.classList.toggle('bg-amber-50', !!active);
      row.classList.toggle('hover:bg-amber-100', !!active);
      row.classList.toggle('hover:bg-slate-50', !active);
    });
  }

  function renderFavoritesTable(entries) {
    const tbody = document.getElementById('favoritesTableBody');
    if (!tbody) return;
    tbody.innerHTML = '';

    const sorted = Array.isArray(entries)
      ? entries.slice().sort((a, b) => {
          const ta = a && a.updatedAt ? new Date(a.updatedAt).getTime() : 0;
          const tb = b && b.updatedAt ? new Date(b.updatedAt).getTime() : 0;
          return tb - ta;
        })
      : [];

    if (!sorted.length) {
      const tr = document.createElement('tr');
      tr.innerHTML = '<td colspan="12" class="px-3 py-4 text-center text-sm text-slate-500">No favorites yet for this symbol.</td>';
      tbody.appendChild(tr);
      highlightFavoriteRow();
      return;
    }

    const formatMoneyDisplay = (val) => {
      const num = Number(val);
      if (!Number.isFinite(num)) return '—';
      const rounded = Math.round(num);
      return `$${rounded.toLocaleString()}`;
    };
    const formatPercentDisplay = (val) => {
      const num = Number(val);
      return Number.isFinite(num) ? `${num.toFixed(2)}%` : '—';
    };
    const formatNumberDisplay = (val, digits = 2) => {
      const num = Number(val);
      return Number.isFinite(num) ? num.toFixed(digits) : '—';
    };

    sorted.forEach(entry => {
      const summary = entry && entry.summary ? entry.summary : {};
      const trades = summary && summary.tradeCounts ? summary.tradeCounts : {};
      const tradePct = trades && trades.pct ? trades.pct : {};
      const totalTrades = Number(trades.total);
      let winPct = Number(tradePct.wins);
      if (!Number.isFinite(winPct) && Number.isFinite(totalTrades) && totalTrades > 0) {
        const wins = Number(trades.wins);
        if (Number.isFinite(wins) && wins >= 0) {
          winPct = (wins / totalTrades) * 100;
        }
      }
      const strategyId = entry && entry.id ? entry.id : (entry && entry.strategyId ? entry.strategyId : '');
      const live = !!(entry && entry.live);
      const liveBadge = live
        ? '<span class="inline-flex items-center rounded-full bg-amber-100 px-2 py-0.5 text-xs font-semibold text-amber-700">On</span>'
        : '<span class="inline-flex items-center rounded-full bg-slate-100 px-2 py-0.5 text-xs font-semibold text-slate-500">Off</span>';
      const tr = document.createElement('tr');
      tr.className = 'border-b last:border-b-0 hover:bg-slate-50';
      tr.dataset.favoriteStrategy = strategyId || '';

      tr.innerHTML = `
        <td class="px-3 py-2 font-mono text-xs md:text-sm break-all"><button type="button" class="text-slate-700 hover:text-indigo-600" data-favorite-load="${strategyId || ''}">${strategyId || ''}</button></td>
        <td class="px-3 py-2 text-center">${liveBadge}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(summary.totalDays)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(trades.total)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(winPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatMoneyDisplay(summary.totalPnL)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.avgDailyRet)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.cagrPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.maxDDPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatNumberDisplay(summary.mar, 2)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatNumberDisplay(summary.sortinoRatio, 2)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.athDayPct)}</td>`;

      tbody.appendChild(tr);
    });

    highlightFavoriteRow();
  }

  function renderLiveTable(entries) {
    const tbody = document.getElementById('liveTableBody');
    if (!tbody) return;
    tbody.innerHTML = '';

    const sorted = Array.isArray(entries)
      ? entries.slice().sort((a, b) => {
          const ta = a && a.updatedAt ? new Date(a.updatedAt).getTime() : 0;
          const tb = b && b.updatedAt ? new Date(b.updatedAt).getTime() : 0;
          return tb - ta;
        })
      : [];

    if (!sorted.length) {
      const tr = document.createElement('tr');
      tr.innerHTML = '<td colspan="12" class="px-3 py-4 text-center text-sm text-slate-500">No live strategies yet for this symbol.</td>';
      tbody.appendChild(tr);
      highlightLiveRow();
      return;
    }

    const formatMoneyDisplay = (val) => {
      const num = Number(val);
      if (!Number.isFinite(num)) return '—';
      const rounded = Math.round(num);
      return `$${rounded.toLocaleString()}`;
    };
    const formatPercentDisplay = (val) => {
      const num = Number(val);
      return Number.isFinite(num) ? `${num.toFixed(2)}%` : '—';
    };
    const formatNumberDisplay = (val, digits = 2) => {
      const num = Number(val);
      return Number.isFinite(num) ? num.toFixed(digits) : '—';
    };

    sorted.forEach(entry => {
      const summary = entry && entry.summary ? entry.summary : {};
      const trades = summary && summary.tradeCounts ? summary.tradeCounts : {};
      const tradePct = trades && trades.pct ? trades.pct : {};
      const totalTrades = Number(trades.total);
      let winPct = Number(tradePct.wins);
      if (!Number.isFinite(winPct) && Number.isFinite(totalTrades) && totalTrades > 0) {
        const wins = Number(trades.wins);
        if (Number.isFinite(wins) && wins >= 0) {
          winPct = (wins / totalTrades) * 100;
        }
      }
      const strategyId = entry && entry.id ? entry.id : (entry && entry.strategyId ? entry.strategyId : '');
      const isFavorite = !!(entry && entry.favorite);
      const favoriteBadge = isFavorite
        ? '<span class="inline-flex items-center rounded-full bg-emerald-100 px-2 py-0.5 text-xs font-semibold text-emerald-700">Yes</span>'
        : '<span class="inline-flex items-center rounded-full bg-slate-100 px-2 py-0.5 text-xs font-semibold text-slate-500">No</span>';
      const tr = document.createElement('tr');
      tr.className = 'border-b last:border-b-0 hover:bg-slate-50';
      tr.dataset.liveStrategy = strategyId || '';

      tr.innerHTML = `
        <td class="px-3 py-2 font-mono text-xs md:text-sm break-all"><button type="button" class="text-slate-700 hover:text-amber-600" data-live-load="${strategyId || ''}">${strategyId || ''}</button></td>
        <td class="px-3 py-2 text-center">${favoriteBadge}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(summary.totalDays)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(trades.total)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(winPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatMoneyDisplay(summary.totalPnL)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.avgDailyRet)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.cagrPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.maxDDPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatNumberDisplay(summary.mar, 2)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatNumberDisplay(summary.sortinoRatio, 2)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.athDayPct)}</td>`;

      tbody.appendChild(tr);
    });

    highlightLiveRow();
  }

  async function loadAutoResultsForSymbol(symbol) {
    const entries = await fetchAutoResults(symbol);
    const filtered = entries.filter(autoEntryPassesFilters).sort(compareAutoEntries);
    AUTO_RESULTS_CACHE = new Map();
    AUTO_RESULTS_LIST = filtered.slice(0, 20);
    AUTO_RESULTS_LIST.forEach(entry => {
      if (entry && entry.strategyId) AUTO_RESULTS_CACHE.set(entry.strategyId, entry);
    });
    if (!AUTO_RESULTS_SORT || !AUTO_RESULTS_SORT.key) {
      AUTO_RESULTS_SORT = { key: 'winPct', direction: 'desc' };
    }
    applyAutoResultsSort();
    syncAutoBacktestButton();
    return AUTO_RESULTS_LIST;
  }

  function getAutoResultValue(entry, key) {
    const params = entry && entry.params ? entry.params : {};
    const summary = entry && entry.summary ? entry.summary : {};
    switch (key) {
      case 'strategyId':
        return entry && entry.strategyId ? String(entry.strategyId) : '';
      case 'sortino':
        return Number(summary.sortinoRatio);
      case 'mar':
        return Number(entry && entry.mar);
      case 'totalPnL':
        return Number(summary.totalPnL);
      case 'winPct': {
        const tradeCounts = summary && summary.tradeCounts ? summary.tradeCounts : {};
        const pctWins = tradeCounts && tradeCounts.pct ? Number(tradeCounts.pct.wins) : NaN;
        if (Number.isFinite(pctWins)) return pctWins;
        const totalTrades = Number(tradeCounts.total);
        const wins = Number(tradeCounts.wins);
        if (Number.isFinite(totalTrades) && totalTrades > 0 && Number.isFinite(wins) && wins >= 0) {
          return (wins / totalTrades) * 100;
        }
        return null;
      }
      case 'avgDaily':
        return Number(summary.avgDailyRet);
      case 'cagr':
        return Number(summary.cagrPct);
      case 'maxDD':
        return Number(summary.maxDDPct);
      case 'athDayPct':
        return Number(summary.athDayPct);
      case 'orb_m':
        return Number(params.orb_m ?? (entry && entry.combo ? entry.combo.orb_m : null));
      case 'tp_R':
        return Number(params.target_R ?? params.tp_R ?? (entry && entry.combo ? entry.combo.tp_R : null));
      case 'sl_R':
        return Number(params.stop_R ?? params.sl_R ?? (entry && entry.combo ? entry.combo.sl_R : null));
      case 'start':
        return parseTimeHHMM(params.orb_start_time || params.start_ny || '00:00');
      case 'end':
        return parseTimeHHMM(params.orb_end_time || params.end_ny || '00:00');
      case 'direction':
        return (params.direction || (entry && entry.combo ? entry.combo.direction : '') || '').toUpperCase();
      default:
        return null;
    }
  }

  function applyAutoResultsSort() {
    if (!Array.isArray(AUTO_RESULTS_LIST)) {
      renderAutoResultsTable([]);
      return;
    }
    const sorted = AUTO_RESULTS_LIST.slice().sort((a, b) => compareAutoEntries(a, b, AUTO_RESULTS_SORT));
    AUTO_RESULTS_LIST = sorted;
    updateAutoSortHeaders();
    AUTO_RESULTS_CACHE = new Map();
    sorted.forEach(entry => {
      if (entry && entry.strategyId) AUTO_RESULTS_CACHE.set(entry.strategyId, entry);
    });
    renderAutoResultsTable(sorted);
  }

  function syncAutoSortSelect() {
    const select = document.getElementById('autoSortSelect');
    if (!select) return;
    const key = AUTO_RESULTS_SORT && AUTO_RESULTS_SORT.key;
    if (!key) return;
    const hasOption = Array.from(select.options || []).some(opt => opt.value === key);
    if (hasOption) {
      select.value = key;
    }
  }

  function updateAutoSortHeaders() {
    document.querySelectorAll('[data-auto-sort]').forEach(btn => {
      const key = btn.getAttribute('data-auto-sort');
      const indicator = btn.querySelector('[data-sort-indicator]');
      const active = AUTO_RESULTS_SORT && AUTO_RESULTS_SORT.key === key;
      btn.classList.toggle('text-slate-900', active);
      btn.classList.toggle('text-slate-600', !active);
      if (indicator) {
        if (active) {
          indicator.style.opacity = '1';
          indicator.textContent = AUTO_RESULTS_SORT.direction === 'asc' ? '▲' : '▼';
        } else {
          indicator.style.opacity = '0';
          indicator.textContent = '▲';
        }
      }
    });
    syncAutoSortSelect();
  }

  function initAutoSortSelect() {
    const select = document.getElementById('autoSortSelect');
    if (!select) return;
    const currentKey = AUTO_RESULTS_SORT && AUTO_RESULTS_SORT.key;
    if (currentKey) {
      select.value = currentKey;
    }
    select.addEventListener('change', (e) => {
      const key = e.target.value;
      if (!key) return;
      const direction = AUTO_SORT_DEFAULT_DIRECTION[key] || 'desc';
      AUTO_RESULTS_SORT = { key, direction };
      applyAutoResultsSort();
    });
  }

  function highlightTickerButton(symbol) {
    const seg = document.getElementById('tickerSegment');
    if (!seg) return;
    const upper = (symbol || '').toUpperCase();
    seg.querySelectorAll('button[data-symbol]').forEach(btn => {
      const active = (btn.getAttribute('data-symbol') || '').toUpperCase() === upper;
      btn.classList.toggle('bg-emerald-600', active);
      btn.classList.toggle('text-white', active);
      btn.classList.toggle('hover:bg-emerald-600', active);
      btn.classList.toggle('bg-white', !active);
      btn.classList.toggle('hover:bg-emerald-50', !active);
      const nameSpan = btn.querySelector('[data-symbol-name]');
      if (nameSpan) {
        nameSpan.classList.toggle('text-emerald-100', active);
        nameSpan.classList.toggle('text-slate-500', !active);
      }
    });
  }

  async function ensureSymbolLoaded(symbol) {
    if (!symbol) return true;
    const upper = symbol.toUpperCase();
    const already = currentTicker === upper;
    if (!already) {
      setTicker(upper);
    }
    highlightTickerButton(upper);
    if (!already) {
      const ok = await loadSymbolData(upper);
      if (!ok) return false;
      buildMonthOptions();
    }
    return true;
  }

  function syncSecondaryNav(name) {
    const secondaryButtons = document.querySelectorAll('[data-secondary-nav]');
    if (!secondaryButtons.length) return;
    secondaryButtons.forEach(btn => {
      const isActive = btn.getAttribute('data-secondary-nav') === name;
      btn.classList.toggle('text-slate-900', isActive);
      btn.classList.toggle('text-slate-500', !isActive);
      if (isActive) {
        btn.setAttribute('aria-current', 'page');
      } else {
        btn.removeAttribute('aria-current');
      }
      const underline = btn.querySelector('[data-secondary-underline]');
      if (underline) {
        underline.classList.toggle('opacity-100', isActive);
        underline.classList.toggle('opacity-0', !isActive);
      }
    });
  }

  function activateModeTab(name) {
    CURRENT_MODE_TAB = name;
    document.querySelectorAll('[data-mode-tab]').forEach(btn => {
      const active = btn.getAttribute('data-mode-tab') === name;
      btn.classList.toggle('text-slate-900', active);
      btn.classList.toggle('text-slate-500', !active);
      btn.classList.toggle('border-blue-500', active);
      btn.classList.toggle('border-transparent', !active);
      const iconWrapper = btn.querySelector('span.inline-flex');
      if (iconWrapper) {
        iconWrapper.classList.toggle('text-emerald-500', active);
        iconWrapper.classList.toggle('text-slate-400', !active);
      }
      btn.querySelectorAll('span > svg, span > ion-icon').forEach(icon => {
        icon.classList.toggle('text-emerald-500', active);
        icon.classList.toggle('text-slate-400', !active);
      });
    });
    document.querySelectorAll('[data-tab-panel]').forEach(panel => {
      const active = panel.getAttribute('data-tab-panel') === name;
      panel.classList.toggle('hidden', !active);
    });
    document.querySelectorAll('[data-shared-section]').forEach(section => {
      const onlyBacktest = section.getAttribute('data-shared-section') === 'filters';
      section.classList.toggle('hidden', onlyBacktest && name !== 'backtest');
    });
    syncSecondaryNav(name);
  }

  function initModeTabs() {
    const buttons = document.querySelectorAll('[data-mode-tab]');
    if (!buttons.length) return;
    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        activateModeTab(btn.getAttribute('data-mode-tab'));
      });
    });
    activateModeTab(CURRENT_MODE_TAB);
    updateAutoSortHeaders();
  }

  function initSecondaryNav() {
    const buttons = document.querySelectorAll('[data-secondary-nav]');
    if (!buttons.length) return;
    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        activateModeTab(btn.getAttribute('data-secondary-nav'));
      });
    });
    syncSecondaryNav(CURRENT_MODE_TAB);
  }

  function setAutoConfigExpanded(expanded) {
    AUTO_CONFIG_EXPANDED = !!expanded;
    const panel = document.getElementById('autoConfigPanel');
    const btn = document.getElementById('btnAutoConfig');
    if (panel) {
      panel.classList.toggle('hidden', !AUTO_CONFIG_EXPANDED);
    }
    if (btn) {
      btn.setAttribute('aria-pressed', AUTO_CONFIG_EXPANDED ? 'true' : 'false');
      btn.classList.toggle('border-emerald-500', AUTO_CONFIG_EXPANDED);
      btn.classList.toggle('text-emerald-600', AUTO_CONFIG_EXPANDED);
      btn.classList.toggle('bg-emerald-50', AUTO_CONFIG_EXPANDED);
    }
  }

  function initAutoConfigPanel() {
    const btn = document.getElementById('btnAutoConfig');
    setAutoConfigExpanded(false);
    if (!btn) return;
    btn.addEventListener('click', () => {
      setAutoConfigExpanded(!AUTO_CONFIG_EXPANDED);
    });
  }

  async function applyAutoResult(entry) {
    if (AUTO_BACKTEST_RUNNING) {
      setAutoStatus('Wait for Auto Backtest to finish before loading a result.');
      return;
    }
    if (!entry || !entry.params) return;
    const params = entry.params;
    if (params.symbol) {
      const ok = await ensureSymbolLoaded(params.symbol);
      if (!ok) {
        setAutoStatus(`Failed to load data for ${params.symbol}.`);
        return;
      }
    }
    setInputValue('inp_orb_m', params.orb_m);
    setInputValue('inp_target_R', params.target_R ?? params.tp_R);
    setInputValue('inp_stop_R', params.stop_R ?? params.sl_R);
    setInputValue('inp_risk_pct', params.risk_pct ?? params.riskPct);
    setInputValue('inp_aum0', params.AUM_0 ?? params.aum_0);
    setInputValue('inp_orb_start', params.orb_start_time ?? params.start_ny);
    setInputValue('inp_orb_end', params.orb_end_time ?? params.end_ny);
    setInputValue('inp_entry_cutoff', params.entry_cutoff_time ?? params.cutoff_time);
    const autoMinRaw = params.min_or_perc ?? params.min_or_pct;
    const autoMin = normalizeMinOr(autoMinRaw);
    const effectiveAutoMin = autoMin != null ? autoMin : DEFAULT_MIN_OR_PERC;
    setInputValue('inp_min_or_perc', effectiveAutoMin);
    syncSessionSelectionFromInputs();
    setDirectionFromFavorite(params.direction);
    const canonicalId = canonicalizeStrategyKey(entry.strategyId || '') || null;
    CURRENT_STRATEGY_ID = canonicalId;
    CURRENT_STRATEGY_PARAMS = { ...params, min_or_perc: effectiveAutoMin };
    CURRENT_STRATEGY_FAVORITE = false;
    CURRENT_STRATEGY_LIVE = false;
    syncFavoriteButton();
    highlightAutoResultRow();
    highlightPortfolioRow();
    highlightFavoriteRow();
    await runBacktestIfReady();
  }

  async function fetchFavoriteRunsForSymbol(symbol) {
    if (!symbol) return [];
    try {
      const db = await getDbInstance();
      if (!db) return [];
      let runs = await new Promise((resolve, reject) => {
        const tx = db.transaction(DB_CONFIG.store, 'readonly');
        const store = tx.objectStore(DB_CONFIG.store);
        const req = store.getAll();
        req.onsuccess = () => resolve(Array.isArray(req.result) ? req.result : []);
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
      const canonicalized = [];
      for (const rec of runs) {
        if (!rec || !rec.id) continue;
        const canonicalId = canonicalizeStrategyKey(rec.id);
        if (canonicalId !== rec.id) {
          const migrated = await migrateStrategyRecord(rec.id, canonicalId, rec);
          if (migrated) {
            canonicalized.push(migrated);
            continue;
          }
        }
        canonicalized.push(rec);
      }
      runs = canonicalized;
      const symUpper = String(symbol || '').toUpperCase();
      return runs.filter(r => {
        if (!r || !r.favorite) return false;
        const params = r.params || {};
        const storedSym = (params.symbol || '').toUpperCase();
        return storedSym === symUpper;
      });
    } catch (err) {
      console.error('Failed to fetch favorite strategies', err);
      return [];
    }
  }

  async function fetchLiveRunsForSymbol(symbol) {
    if (symbol === undefined) symbol = null;
    try {
      const db = await getDbInstance();
      if (!db) return [];
      let runs = await new Promise((resolve, reject) => {
        const tx = db.transaction(DB_CONFIG.store, 'readonly');
        const store = tx.objectStore(DB_CONFIG.store);
        const req = store.getAll();
        req.onsuccess = () => resolve(Array.isArray(req.result) ? req.result : []);
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
      const normalizedRuns = [];
      for (const rec of runs) {
        if (!rec || !rec.id) continue;
        const canonicalId = canonicalizeStrategyKey(rec.id);
        if (canonicalId !== rec.id) {
          const migrated = await migrateStrategyRecord(rec.id, canonicalId, rec);
          if (migrated) {
            normalizedRuns.push(migrated);
            continue;
          }
        }
        normalizedRuns.push(rec);
      }
      runs = normalizedRuns;
      const targetSym = symbol ? String(symbol).toUpperCase() : null;
      return runs.filter(r => {
        if (!r || !r.live) return false;
        const params = r.params || {};
        const storedSym = (params.symbol || '').toUpperCase();
        return targetSym ? storedSym === targetSym : !!storedSym;
      });
    } catch (err) {
      console.error('Failed to fetch live strategies', err);
      return [];
    }
  }

  function getPortfolioDbInstance() {
    if (typeof indexedDB === 'undefined') {
      return Promise.reject(new Error('IndexedDB is not available in this environment'));
    }
    if (!portfolioDbPromise) {
      portfolioDbPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(PORTFOLIO_DB_CONFIG.name, PORTFOLIO_DB_CONFIG.version);
        request.onerror = () => reject(request.error);
        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains(PORTFOLIO_DB_CONFIG.store)) {
            db.createObjectStore(PORTFOLIO_DB_CONFIG.store, { keyPath: 'id' });
          }
        };
        request.onsuccess = () => resolve(request.result);
      }).catch(err => {
        portfolioDbPromise = null;
        throw err;
      });
    }
    return portfolioDbPromise;
  }

  function isDefaultFilterState() {
    if (VIEW_MONTHS.size !== 0) return false;
    if (VIEW_DOW.size !== DEFAULT_VIEW_DOW.length) return false;
    return DEFAULT_VIEW_DOW.every(d => VIEW_DOW.has(d));
  }

  function formatNumberForKey(val) {
    if (val == null || val === '') return '0';
    const num = Number(val);
    if (!Number.isFinite(num)) return '0';
    const str = `${num}`;
    return str.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
  }

  function formatTimeForKey(timeStr) {
    if (typeof timeStr !== 'string' || !timeStr.includes(':')) return timeStr || '';
    return timeStr.replace(':', '.');
  }

  function normalizeMinOr(value) {
    if (value === undefined || value === null || value === '') return null;
    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }

  function defaultMinSegment() {
    return formatNumberForKey(DEFAULT_MIN_OR_PERC);
  }

  function canonicalizeStrategyKey(id) {
    if (!id) return id;
    const parts = String(id).split('_');
    if (parts.length < 2) return id;
    const penultimate = parts[parts.length - 2];
    if (penultimate !== defaultMinSegment()) return id;
    const riskPart = parts[parts.length - 1];
    const baseParts = parts.slice(0, -2);
    baseParts.push(riskPart);
    return baseParts.join('_');
  }

  function keyWithDefaultMin(id) {
    if (!id) return null;
    const parts = String(id).split('_');
    if (parts.length < 2) return null;
    const defaultSegment = defaultMinSegment();
    if (parts[parts.length - 2] === defaultSegment) return null;
    const riskPart = parts.pop();
    parts.push(defaultSegment);
    parts.push(riskPart);
    return parts.join('_');
  }

  async function migrateStrategyRecord(fromId, toId, record) {
    if (!fromId || !toId || fromId === toId) return record || null;
    try {
      const db = await getDbInstance();
      if (!db) return record || null;
      let source = record;
      if (!source) {
        source = await getStrategyRecord(fromId);
        if (!source) return null;
      }
      const payload = { ...source, id: toId };
      await new Promise((resolve, reject) => {
        const tx = db.transaction(DB_CONFIG.store, 'readwrite');
        const store = tx.objectStore(DB_CONFIG.store);
        store.delete(fromId);
        store.put(payload);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
      return payload;
    } catch (err) {
      console.error('Failed to migrate strategy record', err);
      return record || null;
    }
  }

  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj || {}, key);
  }

  function buildStrategyKey(params) {
    if (!params || !params.symbol) return '';
    const dirLetter = params.direction === 'long' ? 'L' : params.direction === 'short' ? 'S' : 'B';
    const riskPct = Number.isFinite(params.risk) ? params.risk * 100 : 0;
    const hasMinOrParam = hasOwn(params, 'min_or_perc') || hasOwn(params, 'min_or_pct');
    const normalizedMinOr = hasMinOrParam ? normalizeMinOr(params.min_or_perc ?? params.min_or_pct) : null;
    const parts = [
      (params.symbol || '').toUpperCase(),
      dirLetter,
      formatNumberForKey(params.orb_m),
      formatNumberForKey(params.target_R),
      formatNumberForKey(params.stop_R),
      formatTimeForKey(params.orb_start_time),
      formatTimeForKey(params.orb_end_time),
      formatTimeForKey(params.entry_cutoff_time)
    ];
    if (normalizedMinOr != null && Math.abs(normalizedMinOr - DEFAULT_MIN_OR_PERC) > 1e-9) {
      parts.push(formatNumberForKey(normalizedMinOr));
    }
    parts.push(formatNumberForKey(riskPct));
    return parts.join('_');
  }

  function sanitizeParamsForStorage(params) {
    if (!params) return null;
    return {
      symbol: (params.symbol || '').toUpperCase(),
      direction: params.direction,
      orb_m: params.orb_m,
      target_R: params.target_R,
      stop_R: params.stop_R,
      orb_start_time: params.orb_start_time,
      orb_end_time: params.orb_end_time,
      entry_cutoff_time: params.entry_cutoff_time,
      risk_pct: Number.isFinite(params.risk) ? Number((params.risk * 100).toFixed(4)) : null,
      AUM_0: params.AUM_0,
      commission: params.commission,
      breakout_buffer: params.breakout_buffer,
      min_or_perc: normalizeMinOr(params.min_or_perc)
    };
  }

  function sanitizeTradeValue(value) {
    if (value instanceof Date) {
      return isNaN(value.getTime()) ? null : value.toISOString();
    }
    if (typeof value === 'number') {
      return Number.isFinite(value) ? value : null;
    }
    if (Array.isArray(value)) {
      return value.map(item => sanitizeTradeValue(item));
    }
    if (value && typeof value === 'object') {
      const obj = {};
      for (const [key, val] of Object.entries(value)) {
        obj[key] = sanitizeTradeValue(val);
      }
      return obj;
    }
    return value == null ? null : value;
  }

  function sanitizeTradesForStorage(rows) {
    if (!Array.isArray(rows)) return [];
    return rows.map((row = {}) => {
      const clean = {};
      for (const [key, value] of Object.entries(row)) {
        clean[key] = sanitizeTradeValue(value);
      }
      return clean;
    });
  }

  function parseDateSafe(val) {
    if (!val) return null;
    if (val instanceof Date && !isNaN(val)) return val;
    const parsed = new Date(val);
    return isNaN(parsed) ? null : parsed;
  }

  function hydrateTradeRow(row, strategyId) {
    const clone = { ...(row || {}) };
    const dateFields = ['EntryTime', 'ExitTime', 'caldt'];
    for (const field of dateFields) {
      if (clone[field]) {
        const parsed = parseDateSafe(clone[field]);
        if (parsed) clone[field] = parsed;
      }
    }
    clone.StrategyId = strategyId;
    clone.SourceStrategyId = strategyId;
    clone.PortfolioRun = true;
    return clone;
  }

  function combinePortfolioTrades(entries) {
    if (!Array.isArray(entries) || entries.length === 0) return { trades: [], strategySeries: [] };
    const combined = [];
    const strategySeries = new Map();
    for (const entry of entries) {
      const strategyId = entry && entry.id ? entry.id : 'UNKNOWN';
      const trades = Array.isArray(entry && entry.trades) ? entry.trades.slice() : [];
      trades.sort((a, b) => {
        const tA = parseDateSafe(a && (a.EntryTime || a.caldt || a.Date));
        const tB = parseDateSafe(b && (b.EntryTime || b.caldt || b.Date));
        return (tA ? tA.getTime() : 0) - (tB ? tB.getTime() : 0);
      });
      if (!strategySeries.has(strategyId)) strategySeries.set(strategyId, []);
      const series = strategySeries.get(strategyId);
      for (const trade of trades) {
        const dateKey = trade && trade.Date ? trade.Date : (trade && trade.EntryTime ? dateKeyFromStr(trade.EntryTime) : null);
        const aumVal = trade && Number.isFinite(Number(trade.AUM)) ? Number(trade.AUM) : null;
        if (dateKey) {
          series.push([dateKey, aumVal]);
        }
        const hydrated = hydrateTradeRow(trade, strategyId);
        combined.push(hydrated);
      }
    }

    const sortKey = (row) => {
      const entryTime = parseDateSafe(row.EntryTime);
      if (entryTime) return entryTime.getTime();
      const caldt = parseDateSafe(row.caldt);
      if (caldt) return caldt.getTime();
      if (typeof row.Date === 'string') {
        const d = Date.parse(row.Date);
        if (!Number.isNaN(d)) return d;
      }
      return 0;
    };

    combined.sort((a, b) => sortKey(a) - sortKey(b));

    const totalInitialAUM = entries.reduce((sum, entry) => {
      const params = entry && entry.params;
      const aum0 = params && Number(params.AUM_0);
      return sum + (Number.isFinite(aum0) ? aum0 : 0);
    }, 0);

    let runningAUM = Number.isFinite(totalInitialAUM) && totalInitialAUM > 0 ? totalInitialAUM : 0;
    for (const row of combined) {
      const pnl = Number(row.PnL);
      const prevAUM = Number.isFinite(runningAUM) ? runningAUM : 0;
      const originalAUM = Number(row.AUM);
      if (Number.isFinite(originalAUM)) {
        row.StrategyAUM = originalAUM;
      }
      const nextAUM = prevAUM + (Number.isFinite(pnl) ? pnl : 0);
      runningAUM = nextAUM;
      row.AUM = Number.isFinite(nextAUM) ? Number(nextAUM.toFixed(2)) : nextAUM;
      if (!Number.isFinite(row.pnl_R)) {
        row.pnl_R = Number.isFinite(prevAUM) && prevAUM !== 0
          ? Number((pnl / prevAUM).toFixed(2))
          : 0;
      }
      row.DailyReturn = Number.isFinite(prevAUM) && prevAUM !== 0
        ? Number(((pnl / prevAUM) * 100).toFixed(2))
        : 0;
      row.PortfolioAUM = row.AUM;
    }

    const strategySeriesArr = Array.from(strategySeries.entries()).map(([id, data]) => ({ id, data }));
    return { trades: combined, strategySeries: strategySeriesArr };
  }

  async function evaluateParams(params, options = {}) {
    const { skipPersist = false } = options;
    const start = performance.now();
    const out = backtest(params);
    const summary = computeSummaryMetrics(out);
    if (!skipPersist) {
      await persistStrategyResult(params, out);
    }
    return {
      summary,
      out,
      elapsedMs: performance.now() - start
    };
  }

    function setTicker(sym) {
      currentTicker = (sym || '').toUpperCase();
      const titleEl = document.getElementById('mainTitle');
      if (titleEl) {
        let prefix = '';
        if (currentTicker) {
          const meta = ensureSymbolMetaEntry(currentTicker);
          const namePart = meta && meta.name && meta.name.toUpperCase() !== currentTicker
            ? ` · ${meta.name}`
            : '';
          prefix = `${currentTicker}${namePart} - `;
        }
        const full = prefix + 'ORB Backtest';
        titleEl.textContent = full;
        document.title = full;
      }
      CURRENT_STRATEGY_ID = null;
      CURRENT_STRATEGY_PARAMS = null;
      CURRENT_STRATEGY_FAVORITE = false;
      CURRENT_STRATEGY_LIVE = false;
      syncFavoriteButton();
      loadFavoritesForSymbol(currentTicker).catch(() => {});
      loadLiveStrategiesForSymbol().catch(() => {});
      loadAutoResultsForSymbol(currentTicker).catch(() => {});
      highlightTickerButton(currentTicker);
      const autoState = getAutoBacktestState(currentTicker);
      AUTO_BACKTEST_TOTAL_COUNT = Number.isFinite(autoState.totalProcessed) ? autoState.totalProcessed : 0;
      syncAutoBacktestButton();
    }

  function setStatus(msg) { const el = document.getElementById('status'); if (el) el.textContent = msg || ''; }
  function setAutoStatus(msg) { const el = document.getElementById('autoResultsStatus'); if (el) el.textContent = msg || ''; }

    function syncLiveButton() {
      const btn = document.getElementById('btnToggleLive');
      if (!btn) return;
      const indicator = btn.querySelector('[data-live-indicator]');
      const label = btn.querySelector('[data-live-label]');
      const favoriteActive = !!CURRENT_STRATEGY_FAVORITE;
      const hasId = !!CURRENT_STRATEGY_ID;
      const hasResults = Array.isArray(LAST_OUT) && LAST_OUT.length > 0;
      const enable = favoriteActive && hasId && hasResults;
      const active = enable && !!CURRENT_STRATEGY_LIVE;

      btn.disabled = !enable;
      btn.classList.toggle('opacity-50', !enable);
      btn.classList.toggle('pointer-events-none', !enable);
      btn.setAttribute('aria-pressed', active ? 'true' : 'false');

      btn.classList.remove('bg-amber-500', 'text-white', 'border-amber-500', 'border-slate-200', 'bg-white', 'text-slate-600', 'text-slate-500');
      if (active) {
        btn.classList.add('bg-amber-500', 'text-white', 'border-amber-500');
      } else {
        btn.classList.add('border-slate-200', 'bg-white', enable ? 'text-slate-600' : 'text-slate-500');
      }

      if (indicator) {
        indicator.classList.toggle('bg-amber-300', active);
        indicator.classList.toggle('bg-slate-300', !active);
      }
      if (label) label.textContent = active ? 'Live: On' : 'Live: Off';
    }

    function syncFavoriteButton() {
      const btn = document.getElementById('btnAddFavorite');
      if (!btn) return;
      const active = !!CURRENT_STRATEGY_FAVORITE;
      const hasId = !!CURRENT_STRATEGY_ID;
      btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      btn.classList.remove('bg-emerald-500', 'text-white', 'border-emerald-500');
      btn.classList.remove('opacity-50', 'pointer-events-none');
      btn.disabled = false;
      if (active) {
        btn.classList.remove('border-slate-200', 'bg-white', 'text-slate-600');
        btn.classList.add('bg-emerald-500', 'text-white', 'border-emerald-500');
      } else {
        btn.classList.add('border-slate-200', 'bg-white', 'text-slate-600');
      }
      if (!hasId || !Array.isArray(LAST_OUT) || LAST_OUT.length === 0) {
        btn.disabled = true;
        btn.classList.add('opacity-50', 'pointer-events-none');
      }
      syncLiveButton();
    }

  function syncAutoBacktestButton() {
    const btn = document.getElementById('btnAutoBacktest');
    if (!btn) return;
    const ready = !!currentTicker && Array.isArray(DAYS) && DAYS.length > 0;
    const pausePending = AUTO_BACKTEST_RUNNING && AUTO_BACKTEST_PAUSE_REQUESTED;
    const disableDueToPause = pausePending;
    const disabled = !ready || disableDueToPause;
    btn.disabled = disabled;
    btn.classList.toggle('opacity-50', disabled);
    btn.classList.toggle('pointer-events-none', disabled);

    const running = AUTO_BACKTEST_RUNNING && !AUTO_BACKTEST_PAUSE_REQUESTED;
    const hasResults = (Array.isArray(AUTO_RESULTS_LIST) && AUTO_RESULTS_LIST.length > 0) || (AUTO_RESULTS_CACHE && AUTO_RESULTS_CACHE.size > 0);
    const labelEl = btn.querySelector('[data-auto-label]');
    const playIcon = btn.querySelector('[data-auto-icon="play"]');
    const pauseIcon = btn.querySelector('[data-auto-icon="pause"]');
    let label = 'Start Backtest';
    if (pausePending) {
      label = 'Pausing…';
    } else if (running) {
      label = 'Pause Backtest';
    } else if (hasResults) {
      label = 'Resume Backtest';
    }
    if (labelEl && labelEl.textContent !== label) labelEl.textContent = label;
    if (playIcon && pauseIcon) {
      const showPause = running || pausePending;
      playIcon.classList.toggle('hidden', showPause);
      pauseIcon.classList.toggle('hidden', !showPause);
    }
    const btnState = pausePending ? 'pausing' : (running ? 'running' : (AUTO_BACKTEST_PAUSED && hasResults ? 'paused' : 'idle'));
    btn.setAttribute('data-state', btnState);

    const clearBtn = document.getElementById('btnClearAuto');
    if (clearBtn) {
      const key = (currentTicker || '').toUpperCase();
      const state = AUTO_BACKTEST_STATE_MAP[key];
      const hasStateData = !!(state && (state.initialCompleted || (Number.isFinite(state.sobolIndex) && state.sobolIndex > 0)));
      const hasCacheData = !!(AUTO_RESULTS_CACHE && AUTO_RESULTS_CACHE.size);
      const hasData = hasStateData || hasCacheData;
      const clearDisabled = AUTO_BACKTEST_RUNNING || !currentTicker || !hasData;
      clearBtn.disabled = clearDisabled;
      clearBtn.classList.toggle('opacity-50', clearDisabled);
      clearBtn.classList.toggle('pointer-events-none', clearDisabled);
    }
  }

    function loadAutoBacktestState() {
      if (typeof localStorage === 'undefined') return {};
      try {
        const raw = localStorage.getItem(AUTO_BACKTEST_STATE_STORAGE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
      } catch (err) {
        console.warn('Failed to load auto backtest state', err);
        return {};
      }
    }

    function saveAutoBacktestState() {
      if (typeof localStorage === 'undefined') return;
      try {
        localStorage.setItem(AUTO_BACKTEST_STATE_STORAGE_KEY, JSON.stringify(AUTO_BACKTEST_STATE_MAP));
      } catch (err) {
        console.warn('Failed to save auto backtest state', err);
      }
    }

  function getAutoBacktestState(symbol) {
    const key = (symbol || '').toUpperCase();
    if (!AUTO_BACKTEST_STATE_MAP[key]) {
      AUTO_BACKTEST_STATE_MAP[key] = { initialCompleted: false, sobolIndex: 0, initialIndex: 0, totalProcessed: 0 };
    }
    const state = AUTO_BACKTEST_STATE_MAP[key];
    if (typeof state.initialCompleted !== 'boolean') state.initialCompleted = false;
    if (!Number.isFinite(state.sobolIndex)) state.sobolIndex = 0;
    if (!Number.isFinite(state.initialIndex)) state.initialIndex = 0;
    if (!Number.isFinite(state.totalProcessed)) state.totalProcessed = 0;
    return state;
  }

  function resetAutoBacktestState(symbol) {
    const key = (symbol || '').toUpperCase();
    if (AUTO_BACKTEST_STATE_MAP[key]) {
      delete AUTO_BACKTEST_STATE_MAP[key];
      saveAutoBacktestState();
    }
    AUTO_BACKTEST_PAUSED = false;
    AUTO_BACKTEST_PAUSE_REQUESTED = false;
    AUTO_BACKTEST_TOTAL_COUNT = 0;
  }

    async function refreshFavoriteState(id) {
      if (!id) {
        CURRENT_STRATEGY_FAVORITE = false;
        CURRENT_STRATEGY_LIVE = false;
        syncFavoriteButton();
        const select = document.getElementById('favoriteSelect');
        if (select) select.value = '';
        return;
      }
      const canonicalId = canonicalizeStrategyKey(id);
      let record = await getStrategyRecord(canonicalId);
      let migrated = false;
      if (!record) {
        const legacyId = keyWithDefaultMin(canonicalId);
        if (legacyId) {
          const legacyRecord = await getStrategyRecord(legacyId);
          if (legacyRecord) {
            record = await migrateStrategyRecord(legacyId, canonicalId, legacyRecord);
            migrated = true;
          }
        }
      }
      CURRENT_STRATEGY_ID = canonicalId;
      CURRENT_STRATEGY_FAVORITE = !!(record && record.favorite);
      CURRENT_STRATEGY_LIVE = CURRENT_STRATEGY_FAVORITE && !!(record && record.live);
      syncFavoriteButton();
      const select = document.getElementById('favoriteSelect');
      if (select) {
        if (CURRENT_STRATEGY_FAVORITE && Array.from(select.options).some(opt => opt.value === canonicalId)) {
          select.value = canonicalId;
        } else if (!CURRENT_STRATEGY_FAVORITE && select.value === canonicalId) {
          select.value = '';
        }
      }
      if (migrated) {
        await loadFavoritesForSymbol(currentTicker).catch(() => {});
      }
    }

    function setFavoriteSelectDisabled(disabled) {
      const select = document.getElementById('favoriteSelect');
      if (!select) return;
      select.disabled = !!disabled;
      select.classList.toggle('opacity-50', !!disabled);
      select.classList.toggle('pointer-events-none', !!disabled);
    }

    async function loadFavoritesForSymbol(symbol) {
      const select = document.getElementById('favoriteSelect');
      if (!select) return;
      CURRENT_SYMBOL_FAVORITES = [];
      const placeholder = '<option value="">Load Favorite…</option>';
      select.innerHTML = placeholder;
      setFavoriteSelectDisabled(true);
      if (!symbol) {
        renderFavoritesTable([]);
        return;
      }
      const favorites = await fetchFavoriteRunsForSymbol(symbol);
      CURRENT_SYMBOL_FAVORITES = favorites;
      renderFavoritesTable(favorites);
      if (!favorites.length) {
        return;
      }
      const frag = document.createDocumentFragment();
      const optionDefault = document.createElement('option');
      optionDefault.value = '';
      optionDefault.textContent = 'Load Favorite…';
      frag.appendChild(optionDefault);
      favorites.forEach(fav => {
        const opt = document.createElement('option');
        opt.value = fav.id || '';
        opt.textContent = fav.id || '(unnamed)';
        frag.appendChild(opt);
      });
      select.innerHTML = '';
      select.appendChild(frag);
      setFavoriteSelectDisabled(false);
      if (CURRENT_STRATEGY_ID && favorites.some(f => f.id === CURRENT_STRATEGY_ID)) {
        select.value = CURRENT_STRATEGY_ID;
      } else {
        select.value = '';
      }
    }

    async function loadLiveStrategiesForSymbol() {
      CURRENT_SYMBOL_LIVE = [];
      const entries = await fetchLiveRunsForSymbol();
      CURRENT_SYMBOL_LIVE = entries;
      renderLiveTable(entries);
    }

  function setDirectionFromFavorite(dir) {
    const seg = document.getElementById('dirSegment');
    const normalized = (dir || 'both').toLowerCase();
    VIEW_DIR = ['long', 'short'].includes(normalized) ? normalized : 'both';
    if (!seg) return;
      seg.querySelectorAll('button[data-dir]').forEach(btn => {
        const val = (btn.getAttribute('data-dir') || '').toLowerCase();
        const active = val === VIEW_DIR;
        btn.classList.toggle('bg-slate-800', active);
        btn.classList.toggle('text-white', active);
        btn.classList.toggle('focus:outline-none', active);
        btn.classList.toggle('bg-white', !active);
        btn.classList.toggle('hover:bg-slate-100', !active);
      });
    }

    function setInputValue(id, value) {
      const el = document.getElementById(id);
      if (!el || value === undefined || value === null || value === '') return;
      el.value = String(value);
    }

    function normalizeSessionList(rawSessions) {
      if (!Array.isArray(rawSessions)) return [];
      const cleaned = [];
      for (const entry of rawSessions) {
        if (!entry) continue;
        const name = typeof entry.name === 'string' ? entry.name.trim() : '';
        if (!name) continue;
        const start = typeof entry.orb_start_ny === 'string' && entry.orb_start_ny.trim()
          ? entry.orb_start_ny.trim()
          : (typeof entry.start_ny === 'string' ? entry.start_ny.trim() : '');
        const end = typeof entry.orb_end_ny === 'string' && entry.orb_end_ny.trim()
          ? entry.orb_end_ny.trim()
          : (typeof entry.end_ny === 'string' ? entry.end_ny.trim() : '');
        const cutoff = typeof entry.entry_cutoff_ny === 'string' && entry.entry_cutoff_ny.trim()
          ? entry.entry_cutoff_ny.trim()
          : (typeof entry.orb_cutoff === 'string' && entry.orb_cutoff.trim()
            ? entry.orb_cutoff.trim()
            : (typeof entry.cutoff_time === 'string' ? entry.cutoff_time.trim() : ''));
        if (!start || !end || !cutoff) continue;
        cleaned.push({
          name,
          orbStart: start,
          orbEnd: end,
          entryCutoff: cutoff,
        });
      }
      return cleaned;
    }

    function syncSessionSegmentUI() {
      const container = document.getElementById('sessionSegment');
      if (!container) return;
      container.querySelectorAll('button[data-session-name]').forEach(btn => {
        const name = btn.getAttribute('data-session-name') || '';
        const active = !!CURRENT_SESSION_NAME && name === CURRENT_SESSION_NAME;
        btn.classList.toggle('bg-slate-800', active);
        btn.classList.toggle('text-white', active);
        btn.classList.toggle('bg-white', !active);
        btn.classList.toggle('text-slate-600', !active);
        btn.classList.toggle('hover:bg-slate-100', !active);
      });
    }

    function clearSessionSelection() {
      CURRENT_SESSION_NAME = null;
      syncSessionSegmentUI();
    }

    function syncSessionSelectionFromInputs() {
      if (!SESSION_OPTIONS.length) {
        clearSessionSelection();
        return;
      }
      const tStart = document.getElementById('inp_orb_start');
      const tEnd = document.getElementById('inp_orb_end');
      const tCut = document.getElementById('inp_entry_cutoff');
      if (!tStart || !tEnd || !tCut) return;
      const startVal = (tStart.value || '').trim();
      const endVal = (tEnd.value || '').trim();
      const cutVal = (tCut.value || '').trim();
      if (!startVal || !endVal || !cutVal) {
        clearSessionSelection();
        return;
      }
      const match = SESSION_OPTIONS.find(session =>
        session
        && session.orbStart === startVal
        && session.orbEnd === endVal
        && session.entryCutoff === cutVal
      );
      if (match) {
        if (CURRENT_SESSION_NAME !== match.name) {
          setActiveSession(match.name, { applyTimes: false });
        } else {
          syncSessionSegmentUI();
        }
      } else {
        clearSessionSelection();
      }
    }

    function setActiveSession(name, { applyTimes = true } = {}) {
      const session = SESSION_OPTIONS.find(item => item && item.name === name);
      if (!session) {
        clearSessionSelection();
        return;
      }
      CURRENT_SESSION_NAME = session.name;
      if (applyTimes) {
        setInputValue('inp_orb_start', session.orbStart);
        setInputValue('inp_orb_end', session.orbEnd);
        setInputValue('inp_entry_cutoff', session.entryCutoff);
        scheduleRun();
      }
      syncSessionSegmentUI();
    }

    async function populateSessionSegment() {
      const container = document.getElementById('sessionSegment');
      if (!container) return;
      container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';
      try {
        const res = await fetch('settings.json', { cache: 'no-cache' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        SESSION_OPTIONS = normalizeSessionList(data && data.sessions);
        if (!SESSION_OPTIONS.length) {
          clearSessionSelection();
          container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">No sessions configured.</span>';
          return;
        }
        const frag = document.createDocumentFragment();
        SESSION_OPTIONS.forEach((session, idx) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = session.name;
          btn.setAttribute('data-session-name', session.name);
          btn.classList.add('px-3', 'py-1.5', 'text-sm', 'font-medium', 'bg-white', 'text-slate-600', 'hover:bg-slate-100');
          if (idx > 0) btn.classList.add('border-l', 'border-slate-200');
          frag.appendChild(btn);
        });
        container.innerHTML = '';
        container.appendChild(frag);
        syncSessionSelectionFromInputs();
      } catch (err) {
        console.error('Failed to load sessions', err);
        SESSION_OPTIONS = [];
        clearSessionSelection();
        container.innerHTML = '<span class="px-3 py-1.5 text-sm text-rose-600">Failed to load sessions.</span>';
      }
    }

    async function applyFavoriteStrategy(record) {
      if (!record || !record.params) return;
      const params = record.params;
      if (params.symbol) {
        const ok = await ensureSymbolLoaded(params.symbol);
        if (!ok) {
          setStatus(`Failed to load data for ${params.symbol}.`);
          return;
        }
      }
      setInputValue('inp_orb_m', params.orb_m);
      setInputValue('inp_target_R', params.target_R);
      setInputValue('inp_stop_R', params.stop_R);
      setInputValue('inp_risk_pct', params.risk_pct);
      setInputValue('inp_aum0', params.AUM_0);
      setInputValue('inp_orb_start', params.orb_start_time);
      setInputValue('inp_orb_end', params.orb_end_time);
      setInputValue('inp_entry_cutoff', params.entry_cutoff_time);
      const favoriteMin = params.min_or_perc ?? params.min_or_pct;
      const normalizedMin = normalizeMinOr(favoriteMin);
      const effectiveMin = normalizedMin != null ? normalizedMin : DEFAULT_MIN_OR_PERC;
      setInputValue('inp_min_or_perc', effectiveMin);
      syncSessionSelectionFromInputs();
      setDirectionFromFavorite(params.direction);
      const canonicalId = canonicalizeStrategyKey(record.id || '') || null;
      CURRENT_STRATEGY_ID = canonicalId;
      CURRENT_STRATEGY_PARAMS = { ...params, min_or_perc: effectiveMin };
      CURRENT_STRATEGY_FAVORITE = !!record.favorite;
      CURRENT_STRATEGY_LIVE = CURRENT_STRATEGY_FAVORITE && !!record.live;
      syncFavoriteButton();
      highlightLiveRow();
      highlightPortfolioRow();
      const select = document.getElementById('favoriteSelect');
      if (select && canonicalId) {
        select.value = canonicalId;
      }
      await runBacktestIfReady();
    }

    function getNextAutoBacktestBatch(state, optimizer) {
      if (!state || !optimizer) return null;
      if (!state.initialCompleted && optimizer.getInitialGridCombos) {
        const combos = optimizer.getInitialGridCombos ? optimizer.getInitialGridCombos() : [];
        const totalInitial = Array.isArray(combos) ? combos.length : 0;
        const startIndex = Math.min(Math.max(Number(state.initialIndex) || 0, 0), totalInitial);
        if (!totalInitial || startIndex >= totalInitial) {
          state.initialCompleted = true;
          state.initialIndex = totalInitial;
          return getNextAutoBacktestBatch(state, optimizer);
        }
        return {
          mode: 'initial',
          modeLabel: 'Seed grid',
          combos: combos.slice(startIndex),
          initialTotal: totalInitial,
          initialStartIndex: startIndex
        };
      }
      if (optimizer.getSobolBatch) {
        const batchSize = optimizer.SOBOL_DEFAULT_BATCH || 500;
        const startIndex = Number(state.sobolIndex) || 0;
        const sobolInfo = optimizer.getSobolBatch(batchSize, startIndex) || {};
        const combos = Array.isArray(sobolInfo.combos) ? sobolInfo.combos : [];
        const nextIndex = Number.isFinite(sobolInfo.nextIndex) ? sobolInfo.nextIndex : startIndex + combos.length;
        if (!combos.length) return null;
        return {
          mode: 'sobol',
          modeLabel: 'Sobol',
          combos,
          sobolStartIndex: startIndex,
          sobolNextIndex: nextIndex
        };
      }
      return null;
    }

    async function runAutoBacktestBatch(batch, state) {
      if (!batch || !Array.isArray(batch.combos) || batch.combos.length === 0) {
        setAutoStatus('No parameter combinations available for Auto Backtest.');
        return { processed: 0, total: 0, completed: true, paused: false, hadError: false };
      }

      const { combos, mode, modeLabel } = batch;
      const total = combos.length;
      const baseParams = getBacktestParams();
      const topResults = [];
      const limit = 20;
      const sortConfig = (AUTO_RESULTS_SORT && AUTO_RESULTS_SORT.key)
        ? { ...AUTO_RESULTS_SORT }
        : { key: 'winPct', direction: 'desc' };
      AUTO_RESULTS_SORT = sortConfig;
      updateAutoSortHeaders();
      const updateTop = (entry) => {
        if (!autoEntryPassesFilters(entry)) return;
        topResults.push(entry);
        topResults.sort((a, b) => compareAutoEntries(a, b, sortConfig));
        if (topResults.length > limit) topResults.length = limit;
      };

      let processed = 0;
      const yieldInterval = 25;
      let hadError = false;

  setAutoStatus(`Auto backtest (${modeLabel}) running… 0/${total} (total ${formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT)})`);

      try {
        for (const combo of combos) {
          if (AUTO_BACKTEST_PAUSE_REQUESTED) break;
          const params = {
            ...baseParams,
            days: Array.isArray(baseParams.days) ? baseParams.days.slice() : baseParams.days,
            orb_m: combo.orb_m,
            target_R: combo.tp_R,
            stop_R: combo.sl_R,
            orb_start_time: combo.start_ny,
            orb_end_time: combo.end_ny,
            direction: (combo.direction || 'BOTH').toLowerCase()
          };

          const { summary, elapsedMs } = await evaluateParams(params, { skipPersist: true });
          const marValue = summary && Number.isFinite(Number(summary.mar)) ? Number(summary.mar) : null;
          if (marValue !== null) {
            updateTop({ combo, params: { ...params }, summary, mar: marValue, elapsedMs });
          }
          processed += 1;
          AUTO_BACKTEST_TOTAL_COUNT += 1;
          state.totalProcessed = (Number.isFinite(state.totalProcessed) ? state.totalProcessed : 0) + 1;

          if (AUTO_BACKTEST_PAUSE_REQUESTED) {
            setAutoStatus(`Pausing auto backtest… finishing current combo (${processed}/${total}, total ${formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT)}).`);
          } else if (processed % yieldInterval === 0) {
            const bestEntry = topResults.length ? topResults[0] : null;
            const bestMetric = getBestAutoMetric(bestEntry, sortConfig);
            const bestId = bestEntry && bestEntry.params ? buildStrategyKey(bestEntry.params) : '—';
            setAutoStatus(`Auto backtest (${modeLabel}) ${processed}/${total} (total ${formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT)}) (best ${bestMetric.label} ${bestMetric.display}, ${bestId})`);
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }
      } catch (err) {
        hadError = true;
        console.error('Auto backtest failed', err);
        setAutoStatus('Auto backtest encountered an error. See console for details.');
      }

      const bestEntry = topResults.length ? topResults[0] : null;
      const bestMetric = getBestAutoMetric(bestEntry, sortConfig);
      const bestId = bestEntry && bestEntry.params ? buildStrategyKey(bestEntry.params) : '—';
      const completed = processed === total && !AUTO_BACKTEST_PAUSE_REQUESTED && !hadError;

      const totalLabel = formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT);

      if (AUTO_BACKTEST_PAUSE_REQUESTED && !hadError) {
        setAutoStatus(`Auto backtest paused after ${processed}/${total} combos (total ${totalLabel}). Best ${bestMetric.label} ${bestMetric.display}.`);
      } else if (!hadError) {
        if (completed) {
          setAutoStatus(`Auto backtest (${modeLabel}) completed ${processed}/${total} combos (total ${totalLabel}). Best ${bestMetric.label} ${bestMetric.display}. Strategy ${bestId}.`);
        } else {
          setAutoStatus(`Auto backtest (${modeLabel}) stopped after ${processed}/${total} combos (total ${totalLabel}). Best ${bestMetric.label} ${bestMetric.display}.`);
        }
      }

      if (mode === 'initial') {
        const start = batch.initialStartIndex || 0;
        const totalInitial = batch.initialTotal || total;
        state.initialIndex = start + processed;
        if (state.initialIndex >= totalInitial || completed) {
          state.initialIndex = Math.min(state.initialIndex, totalInitial);
          state.initialCompleted = true;
        }
        if (!Number.isFinite(state.sobolIndex)) state.sobolIndex = 0;
      } else if (mode === 'sobol') {
        const start = batch.sobolStartIndex || 0;
        if (AUTO_BACKTEST_PAUSE_REQUESTED || hadError) {
          state.sobolIndex = start + processed;
        } else {
          state.sobolIndex = batch.sobolNextIndex || (start + processed);
        }
        state.initialCompleted = true;
      }

      saveAutoBacktestState();

      const runTop = topResults.slice(0, limit);
      let storedTopRecords = [];
      try {
        storedTopRecords = await updateAutoResultsStore(currentTicker, runTop);
      } catch (err) {
        console.error('Failed to update stored auto results', err);
      }

      saveAutoBacktestState();

      try {
        await loadAutoResultsForSymbol(currentTicker);
      } catch (err) {
        console.error('Failed to refresh auto results table', err);
      }

      window.ORBAutoBacktestResults = {
        timestamp: new Date().toISOString(),
        symbol: currentTicker,
        totalCombos: total,
        processedCombos: processed,
        validResults: topResults.length,
        mode: modeLabel,
        batchMode: mode,
        nextSobolIndex: state.sobolIndex || 0,
        paused: AUTO_BACKTEST_PAUSE_REQUESTED,
        hadError,
        rankingMetric: bestMetric.key,
        rankingDirection: AUTO_RESULTS_SORT && AUTO_RESULTS_SORT.direction ? AUTO_RESULTS_SORT.direction : null,
        bestMetricValue: bestMetric.raw,
        bestMetricLabel: bestMetric.label,
        bestMetricDisplay: bestMetric.display,
        maxDrawdownLimit: AUTO_MAX_DD_LIMIT,
        totalProcessed: Number.isFinite(state.totalProcessed) ? state.totalProcessed : AUTO_BACKTEST_TOTAL_COUNT,
        runTop,
        storedTop: storedTopRecords,
        top: runTop
      };
      if (runTop.length) {
        console.log('Auto backtest top results (session):', runTop);
      }
      if (storedTopRecords.length) {
        console.log('Auto backtest stored top results:', storedTopRecords);
      }

      return { processed, total, completed, paused: AUTO_BACKTEST_PAUSE_REQUESTED, hadError };
    }

    function pauseAutoBacktest() {
      if (!AUTO_BACKTEST_RUNNING || AUTO_BACKTEST_PAUSE_REQUESTED) return;
      AUTO_BACKTEST_PAUSE_REQUESTED = true;
      setAutoStatus(`Pausing auto backtest… finishing current combo (total ${formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT)}).`);
      syncAutoBacktestButton();
    }

    async function startAutoBacktest() {
      if (AUTO_BACKTEST_RUNNING) return;
      if (!currentTicker) { setAutoStatus('Pick a symbol before running Auto Backtest.'); return; }
      if (!Array.isArray(DAYS) || DAYS.length === 0) { setAutoStatus('Load data before running Auto Backtest.'); return; }
      const optimizer = window.ORBOptimizer;
      if (!optimizer || (!optimizer.getInitialGridCombos && !optimizer.getSobolBatch)) {
        setAutoStatus('Optimizer module not available.');
        return;
      }

      const baseParams = getBacktestParams();
      if (optimizer.configureTimeBounds && baseParams) {
        optimizer.configureTimeBounds({
          orbStart: baseParams.orb_start_time ?? baseParams.start_ny,
          orbEnd: baseParams.orb_end_time ?? baseParams.end_ny,
          entryCutoff: baseParams.entry_cutoff_time ?? baseParams.cutoff_time
        });
      }

      const state = getAutoBacktestState(currentTicker);
      AUTO_BACKTEST_TOTAL_COUNT = Number.isFinite(state.totalProcessed) ? state.totalProcessed : 0;
      AUTO_BACKTEST_PAUSE_REQUESTED = false;
      AUTO_BACKTEST_PAUSED = false;
      AUTO_BACKTEST_RUNNING = true;
      syncAutoBacktestButton();

      try {
        while (!AUTO_BACKTEST_PAUSE_REQUESTED) {
          const batch = getNextAutoBacktestBatch(state, optimizer);
          if (!batch) {
            if (!AUTO_BACKTEST_PAUSE_REQUESTED) {
              setAutoStatus('No parameter combinations available for Auto Backtest.');
            }
            break;
          }

          const result = await runAutoBacktestBatch(batch, state);
          if (result.hadError || AUTO_BACKTEST_PAUSE_REQUESTED) break;

          if (batch.mode === 'initial' && result.completed) {
            AUTO_BACKTEST_PAUSE_REQUESTED = true;
            const totalLabel = formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT);
            setAutoStatus(`Auto backtest seed grid completed (total ${totalLabel}). Paused before Sobol sweep. Press Resume Backtest to continue.`);
            break;
          }

          await new Promise(resolve => setTimeout(resolve, 0));
        }
      } finally {
        const wasPaused = AUTO_BACKTEST_PAUSE_REQUESTED;
        AUTO_BACKTEST_RUNNING = false;
        AUTO_BACKTEST_PAUSED = wasPaused;
        AUTO_BACKTEST_PAUSE_REQUESTED = false;
        syncAutoBacktestButton();
        saveAutoBacktestState();
      }
    }

    function normalizeAndIndex(rows) {
      if (!rows || !rows.length) throw new Error('No rows parsed');
      const required = ['caldt', 'day', 'open', 'high', 'low', 'close'];
      const missing = required.filter(c => !(c in rows[0]));
      if (missing.length) throw new Error('Missing columns: ' + missing.join(', '));

      ROWS = rows.map(r => {
        const caldt = new Date(r.caldt);
        const dayKey = dateKeyFromStr(r.day);
        const open = Number(r.open), high = Number(r.high), low = Number(r.low), close = Number(r.close);
        if (!dayKey || isNaN(caldt)) return null;
        if ([open, high, low, close].some(v => !Number.isFinite(v))) return null;
        return { caldt, dayKey, open, high, low, close };
      }).filter(Boolean);

      DAY_GROUPS = new Map();
      for (const row of ROWS) {
        if (!DAY_GROUPS.has(row.dayKey)) DAY_GROUPS.set(row.dayKey, []);
        DAY_GROUPS.get(row.dayKey).push(row);
      }
      for (const [k, arr] of DAY_GROUPS.entries()) arr.sort((a, b) => a.caldt - b.caldt);
      DAYS = Array.from(DAY_GROUPS.keys()).sort();
    }

    async function loadSymbolData(sym) {
      const baseSymbol = (sym || '').trim();
      if (!baseSymbol) return false;
      setStatus(`Loading data for ${baseSymbol}…`);
      const candidates = Array.from(new Set([
        baseSymbol,
        baseSymbol.toUpperCase(),
        baseSymbol.toLowerCase()
      ])).filter(Boolean);
      let lastError = null;
      for (const candidate of candidates) {
        const path = `data/${candidate}_1m.csv`;
        try {
          const res = await fetch(path, { cache: 'no-cache' });
          if (!res.ok) {
            lastError = `HTTP ${res.status} loading ${path}`;
            continue;
          }
          const text = await res.text();
          const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
          if (parsed.errors && parsed.errors.length) {
            console.warn('CSV parse warnings:', parsed.errors.slice(0, 3));
          }
          normalizeAndIndex(parsed.data);
          updateSymbolPrecisionFromRows(baseSymbol, parsed.data);
          setStatus(`Loaded ${ROWS.length} rows across ${DAYS.length} day(s).`);
          syncAutoBacktestButton();
          return true;
        } catch (err) {
          lastError = err.message || String(err);
          continue;
        }
      }
      console.error(`Failed to load ${baseSymbol}: ${lastError || 'not found'}`);
      setStatus(`Error loading ${baseSymbol}: ${lastError || 'File not found.'}`);
      ROWS = []; DAY_GROUPS = new Map(); DAYS = [];
      syncAutoBacktestButton();
      return false;
    }

    // -----------------------------
    // Backtest (JS port)
    // -----------------------------
    function backtest({
      symbol = '',
      days,
      dayGroups,
      orb_m,
      target_R,
      stop_R,
      risk,
      AUM_0,
      commission,
      direction = 'both',
      orb_start_time = '9:30',
      orb_end_time = '15:30',
      entry_cutoff_time = '12:00',
      breakout_buffer = 0.01,
      min_or_perc = 0.2,
    }) {
      const out = [];

      // Convert time strings to minutes-of-day format
      const orbStartMin = parseTimeHHMM(orb_start_time);
      const orbEndMin = parseTimeHHMM(orb_end_time);
      const entryCutoffMin = parseTimeHHMM(entry_cutoff_time);

      const { multiplier: contractMultiplier } = getContractSpec(symbol);

      for (let t = 0; t < days.length; t++) {
        const dayKey = days[t];
        const prev_AUM = t > 0 && out[t - 1]?.AUM != null ? out[t - 1].AUM : AUM_0;

        const rowOut = {
          Date: dayKey, ORH: NaN, ORL: NaN, Side: '',
          EntryTime: null, Entry: NaN, ExitTime: null, Exit: NaN,
          StopPrice: NaN, TPPrice: NaN, HitType: '', Shares: NaN,
          PnL: NaN, pnl_R: 0, AUM: prev_AUM, DailyReturn: 0,
        };

        const rawDay = dayGroups && typeof dayGroups.get === 'function' ? dayGroups.get(dayKey) : null;
        const df_day = Array.isArray(rawDay)
          ? rawDay.filter(bar => bar && bar.caldt instanceof Date && !isNaN(bar.caldt.getTime()))
          : [];
        if (!df_day.length) {
          rowOut.HitType = 'NotEnoughBars';
          rowOut.Shares = 0;
          out.push(rowOut);
          continue;
        }

        // Identify the ORB (Opening Range Breakout) window
        const startIdx = df_day.findIndex(r => minutesOfDay(r.caldt) >= orbStartMin);
        if (startIdx < 0 || (startIdx + orb_m) > df_day.length) {
          rowOut.HitType = 'NotEnoughBars';
          rowOut.Shares = 0;
          out.push(rowOut);
          continue;
        }

        // Calculate Opening Range High (ORH) and Low (ORL)
        let ORH = -Infinity, ORL = Infinity;
        let windowValid = true;
        for (let k = startIdx; k < startIdx + orb_m; k++) {
          const bar = df_day[k];
          if (!bar || !Number.isFinite(bar.high) || !Number.isFinite(bar.low)) {
            windowValid = false;
            break;
          }
          ORH = Math.max(ORH, bar.high);
          ORL = Math.min(ORL, bar.low);
        }
        if (!windowValid || !Number.isFinite(ORH) || !Number.isFinite(ORL)) {
          rowOut.HitType = 'NotEnoughBars';
          rowOut.Shares = 0;
          out.push(rowOut);
          continue;
        }
        rowOut.ORH = ORH;
        rowOut.ORL = ORL;

        // Check if Opening Range % is too small
        const OR_range = ORH - ORL;
        const OR_perc = OR_range / ORL;

        if (OR_perc < (min_or_perc / 100)) {
          rowOut.HitType = 'ORTooSmall';
          rowOut.Shares = 0;
          out.push(rowOut);
          continue;
        }

        // Entry logic
        let entryIdx = null, entry_side = 0, entry_price = NaN, entry_time = null;

        for (let i = startIdx + orb_m; i < df_day.length; i++) {
          const r = df_day[i];
          if (!r || !(r.caldt instanceof Date)) continue;
          if (!Number.isFinite(r.high) || !Number.isFinite(r.low)) continue;
          if (minutesOfDay(r.caldt) >= entryCutoffMin) break;

          const long_hit = r.high > (ORH + breakout_buffer);
          const short_hit = r.low < (ORL - breakout_buffer);

          if (
            (direction === 'long' && !long_hit) ||
            (direction === 'short' && !short_hit) ||
            (direction === 'both' && !(long_hit || short_hit))
          ) {
            continue;
          }

          // Decide direction
          if (long_hit && !short_hit) entry_side = 1;
          else if (short_hit && !long_hit) entry_side = -1;
          else entry_side = direction === 'short' ? -1 : 1;

          entry_price = entry_side === 1 ? (ORH + breakout_buffer) : (ORL - breakout_buffer);
          entryIdx = i;
          entry_time = new Date(r.caldt);

          rowOut.Side = entry_side === 1 ? 'Long' : 'Short';
          rowOut.EntryTime = entry_time;
          rowOut.Entry = entry_price;
          break;
        }

        if (entryIdx == null) {
          rowOut.HitType = 'NoBreak';
          rowOut.Shares = 0;
          out.push(rowOut);
          continue;
        }

        // Calculate stop loss and target levels
        const R_price = (ORH - ORL) / 2;
        const stop_price = entry_side === 1 ? entry_price - stop_R * R_price : entry_price + stop_R * R_price;
        const target_price = entry_side === 1 ? entry_price + target_R * R_price : entry_price - target_R * R_price;

        rowOut.StopPrice = stop_price;
        rowOut.TPPrice = target_price;

        // Risk management: position sizing
        const stop_frac = (stop_R * R_price) / entry_price;
        const max_risk_contracts = stop_frac > 0
          ? (prev_AUM * risk) / (entry_price * stop_frac * contractMultiplier)
          : 0;

        const shares = Math.floor(max_risk_contracts);

        rowOut.Shares = shares;
        if (!(shares > 0)) {
          rowOut.HitType = 'NoSize';
          out.push(rowOut);
          continue;
        }

        // Exit logic
        let exitIdx = null, hit = 'EOD', exit_time = null, exit_price = NaN;
        let indeterminate = false;

        for (let j = entryIdx + 1; j < df_day.length; j++) {
          const r2 = df_day[j];
          if (!r2 || !(r2.caldt instanceof Date)) continue;
          if (!Number.isFinite(r2.high) || !Number.isFinite(r2.low)) continue;
          const tp_hit = entry_side === 1 ? r2.high >= target_price : r2.low <= target_price;
          const st_hit = entry_side === 1 ? r2.low <= stop_price : r2.high >= stop_price;

          if (tp_hit && st_hit) {
            exitIdx = j;
            hit = 'Indeterminate';
            indeterminate = true;
            break;
          }
          if (tp_hit) { exitIdx = j; hit = 'TP'; break; }
          if (st_hit) { exitIdx = j; hit = 'Stop'; break; }
        }

        if (indeterminate) {
          const bar = df_day[exitIdx];
          if (bar && bar.caldt instanceof Date) {
            rowOut.ExitTime = new Date(bar.caldt);
          } else {
            rowOut.ExitTime = null;
          }
          rowOut.HitType = 'Indeterminate';
          out.push(rowOut);
          continue;
        }

        // No exit signal: exit at EOD
        if (exitIdx == null) {
          const eodIdx = df_day.findLastIndex(r => r && r.caldt instanceof Date && minutesOfDay(r.caldt) === orbEndMin);
          exitIdx = eodIdx >= 0 ? eodIdx : df_day.length - 1;
          const r_eod = df_day[exitIdx];
          if (r_eod && r_eod.caldt instanceof Date) {
            exit_time = new Date(r_eod.caldt);
          } else {
            exit_time = entry_time;
          }
          exit_price = r_eod && Number.isFinite(r_eod.close) ? r_eod.close : entry_price;
        } else {
          const r_exit = df_day[exitIdx];
          exit_time = r_exit && r_exit.caldt instanceof Date ? new Date(r_exit.caldt) : entry_time;
          const fallbackExit = Number.isFinite(exit_price) ? exit_price : entry_price;
          const o_exit = r_exit && Number.isFinite(r_exit.open) ? r_exit.open : fallbackExit;

          exit_price = (hit === 'TP')
            ? (entry_side === 1 ? Math.max(target_price, o_exit) : Math.min(target_price, o_exit))
            : (entry_side === 1 ? Math.min(stop_price, o_exit) : Math.max(stop_price, o_exit));
        }

        rowOut.ExitTime = exit_time;
        rowOut.Exit = exit_price;
        rowOut.HitType = hit;

        // PnL calculation
        const pnl = entry_side === 1
          ? (exit_price - entry_price) * shares * contractMultiplier
          : (entry_price - exit_price) * shares * contractMultiplier;

        const new_AUM = prev_AUM + pnl - (shares * commission * 2);

        rowOut.PnL = pnl;
        rowOut.AUM = new_AUM;
        rowOut.pnl_R = risk * prev_AUM !== 0 ? Number((pnl / (risk * prev_AUM)).toFixed(2)) : 0;
        rowOut.DailyReturn = prev_AUM !== 0 ? Number(((pnl / prev_AUM) * 100).toFixed(2)) : 0;

        out.push(rowOut);
      }

      return out;
    }

    function computeSummaryMetrics(out) {
      if (!Array.isArray(out) || out.length === 0) return null;
      const trades = out.filter(r => r.Shares > 0 && !['NotEnoughBars', 'NoBreak', 'NoSize'].includes(r.HitType));
      let totalTrades = 0;
      let tpWins = 0;
      let stops = 0;
      let eodCount = 0;
      let eodWin = 0;
      let eodLoss = 0;
      let indeterminate = 0;
      for (const trade of trades) {
        totalTrades += 1;
        const hit = trade.HitType;
        if (hit === 'TP') tpWins += 1;
        else if (hit === 'Stop') stops += 1;
        else if (hit === 'EOD') {
          eodCount += 1;
          if (Number(trade.PnL) > 0) eodWin += 1;
          else if (Number(trade.PnL) < 0) eodLoss += 1;
        } else if (hit === 'Indeterminate') {
          indeterminate += 1;
        }
      }
      const wins = tpWins + eodWin;
      const losses = stops + eodLoss;

      let totalPnL = 0;
      let totalDailyReturn = 0;
      let dailyReturnCount = 0;
      let sumDailyReturnDecimal = 0;
      let downsideSumSquares = 0;
      for (const row of out) {
        if (Number.isFinite(row.PnL)) totalPnL += row.PnL;
        if (Number.isFinite(row.DailyReturn)) {
          totalDailyReturn += row.DailyReturn;
          dailyReturnCount += 1;
          const dailyDec = Number(row.DailyReturn) / 100;
          if (Number.isFinite(dailyDec)) {
            sumDailyReturnDecimal += dailyDec;
            if (dailyDec < 0) {
              downsideSumSquares += dailyDec * dailyDec;
            }
          }
        }
      }
      const avgDailyRet = dailyReturnCount ? totalDailyReturn / dailyReturnCount : 0;
      const avgDailyRetDecimal = dailyReturnCount ? sumDailyReturnDecimal / dailyReturnCount : 0;
      const downsideDeviation = dailyReturnCount ? Math.sqrt(downsideSumSquares / dailyReturnCount) : null;
      const sortinoRatio = (downsideDeviation && downsideDeviation > 0)
        ? (avgDailyRetDecimal * Math.sqrt(252)) / downsideDeviation
        : null;

      const lastRow = out[out.length - 1] || {};
      const lastAUM = Number.isFinite(lastRow.AUM) ? lastRow.AUM : null;

      let cagrPct = 0;
      let maxDDPct = 0;
      let athDays = 0;
      let athDayPct = null;
      if (out.length > 1) {
        const firstRow = out[0] || {};
        const startAUM = Number.isFinite(firstRow.AUM) ? firstRow.AUM : null;
        const endAUM = Number.isFinite(lastRow.AUM) ? lastRow.AUM : null;
        const firstDate = firstRow.Date ? new Date(firstRow.Date) : null;
        const lastDate = lastRow.Date ? new Date(lastRow.Date) : null;
        const firstDateValid = firstDate && !isNaN(firstDate);
        const lastDateValid = lastDate && !isNaN(lastDate);
        if (startAUM !== null && endAUM !== null && startAUM > 0 && endAUM > 0 && firstDateValid && lastDateValid) {
          const days = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
          const years = days / 365.25;
          if (years > 0) {
            cagrPct = (Math.pow(endAUM / startAUM, 1 / years) - 1) * 100;
          }
        }
        let peak = Number.isFinite(startAUM) ? startAUM : null;
        let mdd = 0;
        let totalEquityPoints = 0;
        let athCounter = 0;
        for (const row of out) {
          const a = Number(row.AUM);
          if (!Number.isFinite(a)) continue;
          totalEquityPoints += 1;
          if (!Number.isFinite(peak) || a > peak) {
            peak = a;
          }
          const peakValid = Number.isFinite(peak) && peak !== 0;
          const tolerance = peakValid ? Math.max(Math.abs(peak) * 1e-8, 1e-6) : 1e-6;
          if (peakValid && Math.abs(a - peak) <= tolerance) {
            athCounter += 1;
          }
          if (peakValid) {
            const ddPct = ((a / peak) - 1) * 100;
            if (ddPct < mdd) mdd = ddPct;
          }
        }
        if (totalEquityPoints > 0 && totalTrades > 0) {
          athDays = athCounter;
          athDayPct = (athCounter / totalEquityPoints) * 100;
        } else {
          athDays = 0;
          athDayPct = null;
        }
        maxDDPct = mdd;
      }

      const mar = (Number.isFinite(cagrPct) && maxDDPct < 0) ? cagrPct / Math.abs(maxDDPct) : null;

      const pctOrZero = (count) => totalTrades > 0 ? Number(((count / totalTrades) * 100).toFixed(2)) : 0;

      return {
        totalDays: out.length,
        finalAUM: lastAUM,
        totalPnL,
        avgDailyRet,
        cagrPct,
        maxDDPct,
        mar,
        sortinoRatio,
        downsideDeviation: (downsideDeviation != null) ? downsideDeviation : null,
        athDays,
        athDayPct,
        tradeCounts: {
          total: totalTrades,
          wins,
          losses,
          eodCount,
          eodWin,
          eodLoss,
          indeterminate,
          pct: {
            wins: pctOrZero(wins),
            losses: pctOrZero(losses),
            eod: pctOrZero(eodCount),
            eodWin: pctOrZero(eodWin),
            eodLoss: pctOrZero(eodLoss),
            indeterminate: pctOrZero(indeterminate)
          }
        }
      };
    }

    function formatOutcomeLabel(wins, losses) {
      const plural = (count, word) => {
        if (count === 1) return `${count} ${word}`;
        if (word === 'loss') return `${count} losses`;
        return `${count} ${word}s`;
      };
      if (wins > 0 && losses > 0) {
        return `${plural(wins, 'win')} / ${plural(losses, 'loss')}`;
      }
      if (wins > 0) return plural(wins, 'win');
      if (losses > 0) return plural(losses, 'loss');
      return 'No trades';
    }

    function computeDailyOutcomeDistribution(rows) {
      if (!Array.isArray(rows) || rows.length === 0) return null;
      const dayMap = new Map();
      for (const row of rows) {
        if (!row) continue;
        const pnl = Number(row.PnL);
        if (!Number.isFinite(pnl) || pnl === 0) continue;
        const rawDate = row.Date || row.EntryTime || row.ExitTime || row.caldt;
        const dayKey = dateKeyFromStr(rawDate);
        if (!dayKey) continue;
        let ref = dayMap.get(dayKey);
        if (!ref) {
          ref = { wins: 0, losses: 0 };
          dayMap.set(dayKey, ref);
        }
        if (pnl > 0) ref.wins += 1;
        else if (pnl < 0) ref.losses += 1;
      }

      const categoryMap = new Map();
      let maxTrades = 0;
      for (const { wins, losses } of dayMap.values()) {
        const trades = wins + losses;
        if (trades === 0) continue;
        maxTrades = Math.max(maxTrades, trades);
        const key = `${wins}|${losses}`;
        if (!categoryMap.has(key)) {
          categoryMap.set(key, { wins, losses, count: 0 });
        }
        categoryMap.get(key).count += 1;
      }

      if (categoryMap.size === 0) return null;

      let totalDays = 0;
      const categories = Array.from(categoryMap.values()).map(({ wins, losses, count }) => {
        totalDays += count;
        return { wins, losses, count };
      });
      if (totalDays === 0) return null;

      categories.sort((a, b) => {
        const diff = (a.wins - a.losses) - (b.wins - b.losses);
        if (diff !== 0) return diff;
        const totalDiff = (b.wins + b.losses) - (a.wins + a.losses);
        if (totalDiff !== 0) return totalDiff;
        if (b.wins !== a.wins) return b.wins - a.wins;
        return b.count - a.count;
      });

      const withPct = categories.map((item) => ({
        ...item,
        pct: (item.count / totalDays) * 100,
        label: formatOutcomeLabel(item.wins, item.losses)
      }));

      return {
        totalDays,
        maxTrades,
        categories: withPct
      };
    }

    function renderSummary(out) {
      const summary = document.getElementById('summary');
      if (!summary) return;
      applySectionTitle('summaryTitle', 'Summary');
      const metrics = computeSummaryMetrics(out);
      if (!metrics) { summary.innerHTML = ''; return; }

      const {
        totalDays,
        finalAUM,
        totalPnL,
        avgDailyRet,
        cagrPct,
        maxDDPct,
        mar,
        sortinoRatio,
        athDays,
        athDayPct,
        tradeCounts
      } = metrics;
      const { total, wins, losses, eodCount, eodWin, eodLoss, indeterminate, pct: tradePct = {} } = tradeCounts;

      const athDaysRounded = Number.isFinite(athDays) ? Math.round(athDays) : null;
      const athDaysTitle = athDaysRounded != null
        ? `${fmtInt(athDaysRounded)} ATH day${athDaysRounded === 1 ? '' : 's'}`
        : 'ATH days unavailable';
      const cards = [
        { label: 'Days Backtested', value: fmtInt(totalDays) },
        { label: 'Final AUM', value: `$${fmtInt(finalAUM)}` },
        { label: 'CAGR', value: `${fmtPct(cagrPct)}%` },
        { label: 'Avg Daily Return', value: `${fmtPct(avgDailyRet)}%` },
        { label: 'Total PnL', value: `$${fmtInt(totalPnL)}`, cls: ((totalPnL > 0) ? 'num-pos' : 'num-neg') + ' text-3xl' },
        { label: 'Max DD', value: `${fmtPct(maxDDPct)}%` },
        { label: 'Sortino (ann.)', value: sortinoRatio == null ? '—' : `${fmtNum(sortinoRatio, 2)}x` },
        { label: 'MAR', value: mar == null ? '—' : `${fmtNum(mar, 2)}x` },
        { label: 'ATH Day %', value: athDayPct == null ? '—' : `${fmtPct(athDayPct)}%`, title: athDaysTitle },
      ];

      const gridHtml = `<div class="grid sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">${cards.map(c => {
        const baseValCls = 'text-xl font-semibold tabular-nums font-mono text-right';
        const valCls = (c.label === 'Total PnL') ? `${baseValCls} text-3xl pnl-strong` : baseValCls;
        const titleAttr = c.title ? ` title="${String(c.title).replace(/"/g, '&quot;')}"` : '';
        return `<div class=\"rounded-2xl border p-4\"${titleAttr}><div class=\"text-xs text-slate-500\">${c.label}</div><div class=\"${valCls} ${c.cls || ''}\">${c.value}</div></div>`;
      }).join('')
        }</div>`;

      const pct = (val) => {
        const num = Number(val);
        if (!Number.isFinite(num)) return '0.00%';
        return `${fmtPct(num)}%`;
      };
      const tableHtml = `
      <div class="rounded-2xl border p-3 overflow-auto">
        <div class="text-xs text-slate-500 mb-2">Trades breakdown</div>
        <table class="min-w-full text-sm">
          <thead class="bg-slate-50">
            <tr>
      <th class="px-3 py-2 text-left">Total</th>
      <th class="px-3 py-2 text-right">Win</th>
      <th class="px-3 py-2 text-right">Loss</th>
      <th class="px-3 py-2 text-right">EOD</th>
      <th class="px-3 py-2 text-right">EOD Win</th>
      <th class="px-3 py-2 text-right">EOD Loss</th>
            </tr>
          </thead>
          <tbody>
            <tr class="border-b">
      <td class="px-3 py-2">${fmtInt(total)}</td>
      <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(wins)}</td>
      <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(losses)}</td>
      <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(eodCount)}</td>
      <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(eodWin)}</td>
          <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(eodLoss)}</td>
            </tr>
            <tr>
      <td class="px-3 py-2 text-slate-600">100.0%</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.wins)}</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.losses)}</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.eod)}</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.eodWin)}</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.eodLoss)}</td>
            </tr>
          </tbody>
        </table>
        ${indeterminate > 0 ? `<p class="text-xs text-slate-500 mt-2">${fmtInt(indeterminate)} (${pct(tradePct.indeterminate)}) Indeterminate trades: bar range touched both target and stop within the same minute, so the outcome is unknowable at 1-min resolution.</p>` : ''}
      </div>
    `;

      let chartHtml = '';
      if (LAST_PORTFOLIO_RUN) {
        chartHtml = `
        <div class="rounded-2xl border p-4 mt-4 sm:col-span-2 lg:col-span-2">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-sm font-semibold text-slate-600">Daily Outcome Distribution</h3>
            <span id="dailyOutcomeMeta" class="text-xs text-slate-500"></span>
          </div>
          <div id="dailyOutcomeChart" class="h-72 w-full"></div>
        </div>`;
      }

      summary.innerHTML = gridHtml + tableHtml + chartHtml;
      if (LAST_PORTFOLIO_RUN) {
        requestAnimationFrame(() => renderDailyOutcomeChart(out));
      } else if (dailyOutcomeChartInst) {
        try { dailyOutcomeChartInst.dispose(); } catch {}
        dailyOutcomeChartInst = null;
      }
    }

    function renderDailyOutcomeChart(rows) {
      const container = document.getElementById('dailyOutcomeChart');
      const metaEl = document.getElementById('dailyOutcomeMeta');
      if (!container) {
        if (dailyOutcomeChartInst) {
          try { dailyOutcomeChartInst.dispose(); } catch {}
          dailyOutcomeChartInst = null;
        }
        return;
      }
      const distribution = computeDailyOutcomeDistribution(rows);
      if (!distribution || !distribution.categories.length) {
        if (metaEl) metaEl.textContent = 'Not enough data to chart daily outcomes.';
        container.innerHTML = '<div class="text-sm text-slate-500">Not enough data to chart daily outcomes.</div>';
        if (dailyOutcomeChartInst) {
          try { dailyOutcomeChartInst.dispose(); } catch {}
          dailyOutcomeChartInst = null;
        }
        return;
      }

      const { totalDays, maxTrades, categories } = distribution;
      const metaParts = [];
      metaParts.push(`${totalDays} day${totalDays === 1 ? '' : 's'}`);
      if (maxTrades > 0) {
        metaParts.push(`Up to ${maxTrades} trade${maxTrades === 1 ? '' : 's'}/day`);
      }
      metaParts.push('Zero-PnL trades excluded');
      if (metaEl) metaEl.textContent = metaParts.join(' • ');

      const labels = categories.map(item => item.label);
      const rotation = labels.length > 6 ? 24 : 0;
      const seriesData = categories.map(item => ({
        value: Number(item.pct.toFixed(2)),
        count: item.count,
        wins: item.wins,
        losses: item.losses
      }));
      const tooltipFormatter = (params) => {
        if (!Array.isArray(params) || !params.length) return '';
        const p = params[0];
        const data = p.data || {};
        const pctVal = Number.isFinite(p.value) ? Number(p.value).toFixed(2) : '0.00';
        const count = Number.isFinite(data.count) ? data.count : 0;
        const wins = Number.isFinite(data.wins) ? data.wins : 0;
        const losses = Number.isFinite(data.losses) ? data.losses : 0;
        const winLabel = `${wins} win${wins === 1 ? '' : 's'}`;
        const lossLabel = `${losses} loss${losses === 1 ? '' : 's'}`;
        return `
          <div><strong>${p.name}</strong></div>
          <div>${pctVal}% of days</div>
          <div>${count} day${count === 1 ? '' : 's'} (${winLabel}, ${lossLabel})</div>
        `;
      };

      if (dailyOutcomeChartInst && dailyOutcomeChartInst.getDom && dailyOutcomeChartInst.getDom() !== container) {
        try { dailyOutcomeChartInst.dispose(); } catch {}
        dailyOutcomeChartInst = null;
      }
      if (!dailyOutcomeChartInst) {
        container.innerHTML = '';
        dailyOutcomeChartInst = echarts.init(container);
      }

      const option = {
        animation: true,
        grid: { left: 60, right: 20, top: 40, bottom: 80 },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'shadow' },
          formatter: tooltipFormatter
        },
        xAxis: {
          type: 'category',
          data: labels,
          axisLabel: { interval: 0, rotate: rotation }
        },
        yAxis: {
          type: 'value',
          name: 'Percent of days',
          axisLabel: { formatter: (val) => `${val}%` },
          splitLine: { show: true, lineStyle: { type: 'dashed', color: '#cbd5f5' } }
        },
        series: [{
          name: 'Daily outcomes',
          type: 'bar',
          data: seriesData,
          barWidth: '50%',
          itemStyle: {
            borderRadius: [8, 8, 0, 0],
            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
              { offset: 0, color: '#fbbf24' },
              { offset: 0.6, color: '#f59e0b' },
              { offset: 1, color: '#d97706' }
            ])
          },
          label: {
            show: true,
            position: 'top',
            formatter: ({ value }) => `${Number(value).toFixed(1)}%`,
            color: '#334155',
            fontSize: 11
          }
        }]
      };

      dailyOutcomeChartInst.setOption(option, true);
    }

    async function persistStrategyResult(params, out, opts = {}) {
      if (!params || !Array.isArray(out) || out.length === 0) return;
      const { force = false, favoriteOverride, liveOverride } = opts;
      if (!isDefaultFilterState() && !force) return;
      const key = buildStrategyKey(params);
      if (!key) return;
      const summaryMetrics = computeSummaryMetrics(out);
      if (!summaryMetrics) return;

      const existing = await getStrategyRecord(key);
      const favoriteFlag = (favoriteOverride != null)
        ? !!favoriteOverride
        : !!(existing && existing.favorite);
      const liveFlag = favoriteFlag
        ? ((liveOverride != null) ? !!liveOverride : !!(existing && existing.live))
        : false;

      const nowIso = new Date().toISOString();
      const savedAt = existing && existing.savedAt ? existing.savedAt : nowIso;

      const record = {
        id: key,
        savedAt,
        updatedAt: nowIso,
        params: sanitizeParamsForStorage(params),
        summary: summaryMetrics,
        favorite: favoriteFlag,
        live: liveFlag
      };

      try {
        const db = await getDbInstance();
        if (!db) return;
        await new Promise((resolve, reject) => {
          const tx = db.transaction(DB_CONFIG.store, 'readwrite');
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
          tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
          tx.objectStore(DB_CONFIG.store).put(record);
        });
      } catch (err) {
        console.error('Failed to persist backtest result', err);
      }
    }

  async function persistPortfolioEntry(params, trades) {
    if (!params || !Array.isArray(trades) || trades.length === 0) return;
    ensurePortfolioListLoaded();
    const strategyId = buildStrategyKey(params);
    if (!strategyId) return;
    const portfolioId = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
    const summary = computeSummaryMetrics(trades);
    if (!summary) return;

    const record = {
      id: `${portfolioId}::${strategyId}`,
      portfolioId,
      strategyId,
      savedAt: new Date().toISOString(),
      params: sanitizeParamsForStorage(params),
      summary,
      trades: sanitizeTradesForStorage(trades)
    };

    try {
      const db = await getPortfolioDbInstance();
      if (!db) return;
      await new Promise((resolve, reject) => {
        const tx = db.transaction(PORTFOLIO_DB_CONFIG.store, 'readwrite');
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
        tx.objectStore(PORTFOLIO_DB_CONFIG.store).put(record);
      });
    } catch (err) {
      console.error('Failed to save portfolio entry', err);
      throw err;
    }
    return record;
  }

  async function fetchPortfolioEntries(portfolioId = CURRENT_PORTFOLIO_ID) {
    try {
      const db = await getPortfolioDbInstance();
      if (!db) return [];
      const activeId = portfolioId || getDefaultPortfolioName();
      return await new Promise((resolve, reject) => {
        const tx = db.transaction(PORTFOLIO_DB_CONFIG.store, 'readonly');
        const store = tx.objectStore(PORTFOLIO_DB_CONFIG.store);
        const req = store.getAll();
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
        req.onsuccess = () => {
          const all = Array.isArray(req.result) ? req.result : [];
          let listChanged = false;
          const normalized = all.map(rec => {
            if (rec && !rec.portfolioId) {
              rec.portfolioId = getDefaultPortfolioName();
            }
            if (rec && rec.portfolioId && !PORTFOLIO_LIST.includes(rec.portfolioId)) {
              PORTFOLIO_LIST.push(rec.portfolioId);
              listChanged = true;
            }
            if (rec && !rec.strategyId) {
              const rawId = rec.id ? String(rec.id) : '';
              const parts = rawId.split('::');
              rec.strategyId = parts.length > 1 ? parts[parts.length - 1] : rawId || '';
            }
            if (rec && rec.portfolioId && rec.strategyId && !rec.id) {
              rec.id = `${rec.portfolioId}::${rec.strategyId}`;
            }
            return rec;
          });
          if (listChanged) {
            savePortfolioListToStorage(PORTFOLIO_LIST);
          }
          resolve(normalized.filter(rec => rec && rec.portfolioId === activeId));
        };
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
      });
    } catch (err) {
      console.error('Failed to load portfolio entries', err);
      return [];
    }
  }

  function renderPortfolioTable(entries) {
    const tbody = document.getElementById('portfolioTableBody');
    if (!tbody) return;
    tbody.innerHTML = '';
    PORTFOLIO_CACHE = new Map();

    const rows = Array.isArray(entries)
      ? entries.slice().sort((a, b) => {
          const da = a && a.savedAt ? new Date(a.savedAt).getTime() : 0;
          const db = b && b.savedAt ? new Date(b.savedAt).getTime() : 0;
          return db - da;
        })
      : [];

    if (!rows.length) {
      const emptyPrefix = `${CURRENT_PORTFOLIO_ID || getDefaultPortfolioName()}::`;
      for (const key of Array.from(PORTFOLIO_INCLUDE_STATE.keys())) {
        if (key.startsWith(emptyPrefix)) PORTFOLIO_INCLUDE_STATE.delete(key);
      }
      const tr = document.createElement('tr');
      tr.innerHTML = '<td colspan="12" class="px-3 py-4 text-center text-sm text-slate-500">No saved strategies yet.</td>';
      tbody.appendChild(tr);
      const headerToggle = document.getElementById('portfolioIncludeAll');
      if (headerToggle) headerToggle.checked = false;
      return;
    }

    const seenIds = new Set();

    const formatIntDisplay = (val) => {
      const num = Number(val);
      return Number.isFinite(num) ? Math.round(num).toLocaleString() : '—';
    };
    const formatMoneyDisplay = (val) => {
      const num = Number(val);
      if (!Number.isFinite(num)) return '—';
      const rounded = Math.round(num);
      return `$${rounded.toLocaleString()}`;
    };
    const formatPercentDisplay = (val) => {
      const num = Number(val);
      return Number.isFinite(num) ? `${num.toFixed(2)}%` : '—';
    };
    const formatNumberDisplay = (val, digits = 2) => {
      const num = Number(val);
      return Number.isFinite(num) ? num.toFixed(digits) : '—';
    };

    for (const entry of rows) {
      const summary = entry && entry.summary ? entry.summary : {};
      const trades = summary && summary.tradeCounts ? summary.tradeCounts : {};
      const tradePct = trades && trades.pct ? trades.pct : {};
      let winPct = Number(tradePct.wins);
      if (!Number.isFinite(winPct)) {
        const totalTrades = Number(trades.total);
        const winsCount = Number(trades.wins);
        if (Number.isFinite(totalTrades) && totalTrades > 0 && Number.isFinite(winsCount) && winsCount >= 0) {
          winPct = (winsCount / totalTrades) * 100;
        }
      }
      const idValue = entry && entry.id ? String(entry.id) : '';
      if (idValue) {
        PORTFOLIO_CACHE.set(idValue, entry);
        seenIds.add(idValue);
        if (!PORTFOLIO_INCLUDE_STATE.has(idValue)) {
          PORTFOLIO_INCLUDE_STATE.set(idValue, true);
        }
      }
      const include = idValue ? PORTFOLIO_INCLUDE_STATE.get(idValue) !== false : true;
      const displayId = entry && entry.strategyId ? entry.strategyId : (idValue ? idValue.split('::').pop() : '—');
      const strategyKey = entry && entry.strategyId ? String(entry.strategyId) : (idValue ? String(idValue).split('::').pop() : null);
      const strategyKeyUpper = strategyKey ? strategyKey.toUpperCase() : '';
      const isLive = strategyKeyUpper && Array.isArray(CURRENT_SYMBOL_LIVE) && CURRENT_SYMBOL_LIVE.some(item => {
        if (!item) return false;
        const liveId = (item.id || item.strategyId || '').toString().toUpperCase();
        return liveId === strategyKeyUpper;
      });
      const liveBadge = isLive
        ? '<span class="inline-flex items-center rounded-full bg-amber-100 px-2 py-0.5 text-xs font-semibold text-amber-700">On</span>'
        : '<span class="inline-flex items-center rounded-full bg-slate-100 px-2 py-0.5 text-xs font-semibold text-slate-500">Off</span>';
      const tr = document.createElement('tr');
      tr.className = 'border-b last:border-b-0 hover:bg-slate-50';
      if (!include) tr.classList.add('opacity-60');
      tr.innerHTML = `
        <td class="px-3 py-2 align-top">
          ${idValue ? `<label class="inline-flex cursor-pointer items-center justify-center">
            <input type="checkbox" class="peer sr-only" data-portfolio-include="${idValue}" aria-label="Include ${displayId}" ${include ? 'checked' : ''} />
            <span class="inline-flex h-5 w-5 select-none items-center justify-center rounded-md border border-slate-300 bg-white text-xs font-bold text-transparent transition peer-checked:border-emerald-500 peer-checked:bg-emerald-500 peer-checked:text-white">
              &#10003;
            </span>
          </label>` : ''}
        </td>
        <td class="px-3 py-2 font-mono text-xs md:text-sm break-all">
          <button type="button" class="text-slate-700 hover:text-emerald-600" data-portfolio-load="${idValue}">${displayId}</button>
        </td>
        <td class="px-3 py-2 text-center">${liveBadge}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatIntDisplay(summary.totalDays)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatIntDisplay(trades.total)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(winPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatMoneyDisplay(summary.totalPnL)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.avgDailyRet)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.cagrPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.maxDDPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatNumberDisplay(summary.mar, 2)}</td>
        <td class="px-3 py-2 text-right">
          <button type="button" class="inline-flex items-center gap-1 rounded-lg border border-slate-200 bg-white px-2 py-1 text-xs font-medium text-slate-600 shadow-sm transition hover:border-rose-500 hover:text-rose-600" ${idValue ? `data-portfolio-delete="${idValue}"` : 'disabled'}>
            Delete
          </button>
        </td>
      `;
      tr.dataset.portfolioStrategy = entry && entry.strategyId ? entry.strategyId : '';
      tr.dataset.portfolioInclude = include ? '1' : '0';
      tbody.appendChild(tr);
    }
    const includePrefix = `${CURRENT_PORTFOLIO_ID || getDefaultPortfolioName()}::`;
    for (const key of Array.from(PORTFOLIO_INCLUDE_STATE.keys())) {
      if (key.startsWith(includePrefix) && !seenIds.has(key)) {
        PORTFOLIO_INCLUDE_STATE.delete(key);
      }
    }
    const headerToggle = document.getElementById('portfolioIncludeAll');
    if (headerToggle) {
      const checkboxes = Array.from(tbody.querySelectorAll('input[data-portfolio-include]'));
      headerToggle.checked = checkboxes.length > 0 && checkboxes.every(cb => cb.checked);
    }
    highlightPortfolioRow();
  }

  async function refreshPortfolioTable() {
    ensurePortfolioListLoaded();
    await loadLiveStrategiesForSymbol();
    const entries = await fetchPortfolioEntries(CURRENT_PORTFOLIO_ID);
    populatePortfolioSelect();
    renderPortfolioTable(entries);
  }

  async function deletePortfolioEntry(id) {
    if (!id) return false;
    try {
      const db = await getPortfolioDbInstance();
      if (!db) return false;
      await new Promise((resolve, reject) => {
        const tx = db.transaction(PORTFOLIO_DB_CONFIG.store, 'readwrite');
        const store = tx.objectStore(PORTFOLIO_DB_CONFIG.store);
        const req = store.delete(id);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
      });
      PORTFOLIO_INCLUDE_STATE.delete(id);
      return true;
    } catch (err) {
      console.error('Failed to delete portfolio entry', err);
      throw err;
    }
  }

  async function clearPortfolioEntries() {
    try {
      const db = await getPortfolioDbInstance();
      if (!db) return false;
      const activeId = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
      await new Promise((resolve, reject) => {
        const tx = db.transaction(PORTFOLIO_DB_CONFIG.store, 'readwrite');
        const store = tx.objectStore(PORTFOLIO_DB_CONFIG.store);
        const cursorReq = store.openCursor();
        cursorReq.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            const value = cursor.value || {};
            const recPortfolio = value.portfolioId || getDefaultPortfolioName();
            if (recPortfolio === activeId) {
              cursor.delete();
            }
            cursor.continue();
          } else {
            resolve();
          }
        };
        cursorReq.onerror = () => reject(cursorReq.error || new Error('IndexedDB cursor failed'));
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
      PORTFOLIO_CACHE = new Map();
      const clearedPrefix = `${CURRENT_PORTFOLIO_ID || getDefaultPortfolioName()}::`;
      for (const key of Array.from(PORTFOLIO_INCLUDE_STATE.keys())) {
        if (key.startsWith(clearedPrefix)) PORTFOLIO_INCLUDE_STATE.delete(key);
      }
      return true;
    } catch (err) {
      console.error('Failed to clear portfolio entries', err);
      throw err;
    }
  }

  async function runPortfolio() {
    const statusEl = document.getElementById('status');
    const previousMsg = statusEl ? statusEl.textContent : '';
    CURRENT_STRATEGY_ID = null;
    CURRENT_STRATEGY_PARAMS = null;
    CURRENT_STRATEGY_FAVORITE = false;
    CURRENT_STRATEGY_LIVE = false;
    syncFavoriteButton();
    loadFavoritesForSymbol(currentTicker).catch(() => {});
    try {
      await loadLiveStrategiesForSymbol();
      ensurePortfolioListLoaded();
      const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
      const entries = await fetchPortfolioEntries(portfolioName);
      if (!entries.length) {
        PORTFOLIO_EQUITY_SERIES = null;
        setPortfolioContext(false);
        setStatus(`${portfolioName} is empty. Nothing to run.`);
        if (statusEl) {
          setTimeout(() => {
            if (statusEl.textContent === `${portfolioName} is empty. Nothing to run.`) {
              statusEl.textContent = previousMsg;
            }
          }, 3000);
        }
        return;
      }
      const activeEntries = entries.filter(entry => {
        const idValue = entry && entry.id ? String(entry.id) : '';
        if (!idValue) return true;
        if (!PORTFOLIO_INCLUDE_STATE.has(idValue)) return true;
        return PORTFOLIO_INCLUDE_STATE.get(idValue) !== false;
      });

      if (!activeEntries.length) {
        PORTFOLIO_EQUITY_SERIES = null;
        setPortfolioContext(false);
        setStatus('All strategies are excluded. Nothing to run.');
        if (statusEl) {
          setTimeout(() => {
            if (statusEl.textContent === 'All strategies are excluded. Nothing to run.') {
              statusEl.textContent = previousMsg;
            }
          }, 3000);
        }
        return;
      }

      const { trades: combined, strategySeries } = combinePortfolioTrades(activeEntries);
      if (!combined.length) {
        PORTFOLIO_EQUITY_SERIES = null;
        setPortfolioContext(false);
        setStatus(`No trades found across ${portfolioName}.`);
        if (statusEl) {
          setTimeout(() => {
            if (statusEl.textContent === `No trades found across ${portfolioName}.`) {
              statusEl.textContent = previousMsg;
            }
          }, 3000);
        }
        return;
      }
      LAST_OUT = combined;
      PORTFOLIO_EQUITY_SERIES = Array.isArray(strategySeries) && strategySeries.length ? strategySeries : null;
      setPortfolioContext(true);
      renderSummary(LAST_OUT);
      renderTable(LAST_OUT);
      renderEquityChart(LAST_OUT);
      renderDrawdownChart(LAST_OUT);
      renderStreakChart(LAST_OUT);
      renderMonthlyPerf(LAST_OUT);
      const msg = `Ran ${portfolioName} across ${activeEntries.length} strategies (${combined.length} rows).`;
      setStatus(msg);
      if (statusEl) {
        setTimeout(() => {
          if (statusEl.textContent === msg) {
            statusEl.textContent = previousMsg;
          }
        }, 3000);
      }
    } catch (err) {
      console.error('Failed to run portfolio', err);
      PORTFOLIO_EQUITY_SERIES = null;
      setStatus('Failed to run portfolio.');
      if (statusEl) {
        setTimeout(() => {
          if (statusEl.textContent === 'Failed to run portfolio.') {
            statusEl.textContent = previousMsg;
          }
        }, 4000);
      }
    }
  }

  function getTradeSortValue(row, key) {
    if (!row) return null;
    const num = (val) => {
      const parsed = Number(val);
      return Number.isFinite(parsed) ? parsed : null;
    };
    switch (key) {
      case 'date':
        return row.Date || '';
      case 'orh':
        return num(row.ORH);
      case 'orl':
        return num(row.ORL);
      case 'range': {
        const high = num(row.ORH);
        const low = num(row.ORL);
        return high != null && low != null ? high - low : null;
      }
      case 'rangePct': {
        const high = num(row.ORH);
        const low = num(row.ORL);
        if (high == null || low == null || low === 0) return null;
        return ((high - low) / low) * 100;
      }
      case 'side':
        return (row.Side || '').toString().toUpperCase();
      case 'entryTime': {
        const val = row.EntryTime;
        if (val instanceof Date && !isNaN(val)) return minutesOfDay(val);
        if (typeof val === 'number' && Number.isFinite(val)) return val;
        if (typeof val === 'string' && val) return parseTimeHHMM(val);
        return null;
      }
      case 'exitTime': {
        const val = row.ExitTime;
        if (val instanceof Date && !isNaN(val)) return minutesOfDay(val);
        if (typeof val === 'number' && Number.isFinite(val)) return val;
        if (typeof val === 'string' && val) return parseTimeHHMM(val);
        return null;
      }
      case 'entry':
        return num(row.Entry);
      case 'exit':
        return num(row.Exit);
      case 'stop':
        return num(row.StopPrice);
      case 'tp':
        return num(row.TPPrice);
      case 'hitType':
        return (row.HitType === 'Stop' ? 'Loss' : row.HitType || '').toString().toUpperCase();
      case 'shares':
        return num(row.Shares);
      case 'pnl':
        return num(row.PnL);
      case 'pnlR':
        return num(row.pnl_R);
      case 'aum':
        return num(row.AUM);
      case 'dailyReturn':
        return num(row.DailyReturn);
      case 'strategy': {
        const strategyId = row.SourceStrategyId || row.StrategyId || '';
        return strategyId.toString().toUpperCase();
      }
      default:
        return null;
    }
  }

  function updateTradeSortHeaders() {
    document.querySelectorAll('[data-trade-sort]').forEach(btn => {
      const key = btn.getAttribute('data-trade-sort');
      const indicator = btn.querySelector('[data-sort-indicator]');
      const active = TRADES_SORT && TRADES_SORT.key === key;
      btn.classList.toggle('text-slate-900', active);
      btn.classList.toggle('text-slate-600', !active);
      if (indicator) {
        if (active) {
          indicator.style.opacity = '1';
          indicator.textContent = TRADES_SORT.direction === 'asc' ? '▲' : '▼';
        } else {
          indicator.style.opacity = '0';
          indicator.textContent = '▲';
        }
      }
    });
  }

  function renderTable(out) {
      const tb = document.getElementById('tbody');
      if (!tb) {
        updateTradeSortHeaders();
        return;
      }
      tb.innerHTML = '';
      let rows = Array.isArray(out) ? (VIEW_DIR === 'both' ? out.slice() : out.filter(r => (r.Shares > 0) && ((VIEW_DIR === 'long' && r.Side === 'Long') || (VIEW_DIR === 'short' && r.Side === 'Short')))) : [];
      const { key = 'date', direction = 'desc' } = TRADES_SORT || {};
      const factor = direction === 'asc' ? 1 : -1;
      rows.sort((a, b) => {
        const va = getTradeSortValue(a, key);
        const vb = getTradeSortValue(b, key);
        const aNull = va == null || (typeof va === 'number' && !Number.isFinite(va));
        const bNull = vb == null || (typeof vb === 'number' && !Number.isFinite(vb));
        if (aNull && bNull) return 0;
        if (aNull) return 1;
        if (bNull) return -1;
        const numA = typeof va === 'number' ? va : Number(va);
        const numB = typeof vb === 'number' ? vb : Number(vb);
        const bothNumeric = Number.isFinite(numA) && Number.isFinite(numB);
        if (bothNumeric) {
          if (numA > numB) return factor;
          if (numA < numB) return -factor;
        } else {
          const sa = String(va);
          const sb = String(vb);
          const cmp = sa.localeCompare(sb, undefined, { numeric: true });
          if (cmp !== 0) return factor * cmp;
        }
        const da = getTradeSortValue(a, 'date') || '';
        const db = getTradeSortValue(b, 'date') || '';
        if (da === db) return 0;
        return da < db ? 1 : -1;
      });
      const frag = document.createDocumentFragment();
      for (const r of rows) {
        const tr = document.createElement('tr');
        // Highlight rows based on HitType and pnl_R
        let highlight = '';
        if (r.HitType === 'TP') {
          highlight = ' bg-emerald-300';
        } else if (r.HitType === 'Indeterminate') {
          highlight = ' bg-amber-100';
        } else if (r.HitType === 'EOD' && Number(r.pnl_R) > 0) {
          highlight = ' bg-emerald-100';
        }
        tr.className = ('border-b' + (highlight ? highlight : ' hover:bg-slate-50'));
  const orHigh = Number(r.ORH);
  const orLow = Number(r.ORL);
  const OR_val = (Number.isFinite(orHigh) && Number.isFinite(orLow)) ? (orHigh - orLow) : NaN;
  const OR_pct = (Number.isFinite(OR_val) && Number.isFinite(orLow) && orLow !== 0) ? ((OR_val / orLow) * 100) : NaN;
  const strategyLabel = r.SourceStrategyId || r.StrategyId || '';
  tr.innerHTML = `
  <td class="px-3 py-2">${r.Date}</td>
  <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtPrice(r.ORH)}</td>
  <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtPrice(r.ORL)}</td>
  <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtPrice(OR_val)}</td>
  <td class="px-3 py-2 text-right">${fmtPct(OR_pct)}</td>
  <td class="px-3 py-2">${r.Side || ''}</td>
  <td class="px-3 py-2">${fmtTime(r.EntryTime)}</td>
  <td class="px-3 py-2">${fmtTime(r.ExitTime)}</td>
  <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtPrice(r.Entry)}</td>
  <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtPrice(r.Exit)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtPrice(r.StopPrice)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtPrice(r.TPPrice)}</td>
        <td class="px-3 py-2">${r.HitType === 'Stop' ? 'Loss' : r.HitType}</td>
        <td class="px-3 py-2 text-right">${Number.isFinite(r.Shares) ? r.Shares : ''}</td>
        <td class="px-3 py-2 text-right">${fmtNum(r.PnL)}</td>
        <td class="px-3 py-2 text-right">${fmtNum(r.pnl_R)}</td>
        <td class="px-3 py-2 text-right">${fmtNum(r.AUM)}</td>
        <td class="px-3 py-2 text-right">${fmtPct(r.DailyReturn)}</td>
        <td class="px-3 py-2 text-left text-xs font-mono">${strategyLabel}</td>`;
        frag.appendChild(tr);
      }
      tb.appendChild(frag);
      updateTradeSortHeaders();
    }

    function renderEquityChart(out){
      applySectionTitle('equityTitle', 'Equity Curve');
      const el = document.getElementById('equityChart');
      if (!el) return;
      if (!out || !out.length) {
        try { if (equityChartInst) { equityChartInst.dispose(); equityChartInst = null; } } catch {}
        el.innerHTML = '<div class="text-sm text-slate-500">No data</div>';
        return;
      }
      // Prepare data as [time,value]
      const portfolioData = out.map(r => [r.Date, Number.isFinite(r.AUM) ? r.AUM : null]).filter(p => p[1] !== null);
      if (!equityChartInst) equityChartInst = echarts.init(el);
      const series = [{
        name: 'Portfolio',
        type: 'line',
        showSymbol: false,
        smooth: false,
        lineStyle: { width: 2, color: '#10b981' },
        data: portfolioData
      }];

      if (Array.isArray(PORTFOLIO_EQUITY_SERIES) && PORTFOLIO_EQUITY_SERIES.length) {
        for (const item of PORTFOLIO_EQUITY_SERIES) {
          const id = item && item.id ? item.id : 'Strategy';
          const dataArr = Array.isArray(item && item.data) ? item.data : [];
          const seriesData = dataArr.map(d => {
            const dateVal = d && d[0];
            const val = d && Number.isFinite(Number(d[1])) ? Number(d[1]) : null;
            return [dateVal, val];
          }).filter(p => p[0] != null);
          series.push({
            name: id,
            type: 'line',
            showSymbol: false,
            smooth: false,
            lineStyle: { width: 1.5 },
            emphasis: { focus: 'series' },
            data: seriesData
          });
        }
      }

      const option = {
        animation: false,
        grid: { left: 56, right: 16, top: 8, bottom: 40 },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'cross' },
          valueFormatter: (v) => (v == null ? '' : `$${Number(v).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2})}`)
        },
        xAxis: { type: 'time', name: 'Date' },
        yAxis: {
          type: 'value', name: 'AUM',
          axisLabel: { formatter: (v) => fmtCompactMoney(v) }
        },
        legend: series.length > 1 ? {
          top: 4,
          left: 'center',
          icon: 'line',
          textStyle: { fontSize: 11 },
          data: series.map(s => s.name)
        } : { show: false },
        dataZoom: [ 
          { type: 'inside', throttle: 50 }, 
          { 
            type: 'slider', 
            fillerColor: 'rgba(0, 0, 0, 0)', 
            height: 40,
            dataBackground: {
              lineStyle: { color: '#50C878' },
              areaStyle: { color: 'rgba(80, 200, 120, 0.2)' }
            }
          },
        ],
        series
      };
      equityChartInst.setOption(option, true);
    }

    function renderDrawdownChart(out) {
      applySectionTitle('drawdownTitle', 'Drawdown');
      const el = document.getElementById('drawdownChart');
      if (!el) return;
      if (!out || !out.length) {
        try { if (drawdownChartInst) { drawdownChartInst.dispose(); drawdownChartInst = null; } } catch {}
        el.innerHTML = '<div class="text-sm text-slate-500">No data</div>';
        return;
      }

      const pctData = [];
      const usdData = [];
      let peak = -Infinity;
      for (const row of out) {
        if (!row || !row.Date) continue;
        const aum = Number(row.AUM);
        if (!Number.isFinite(aum)) continue;
        if (!Number.isFinite(peak) || aum > peak) peak = aum;
        if (!Number.isFinite(peak) || peak <= 0) {
          pctData.push([row.Date, 0]);
          usdData.push([row.Date, 0]);
          continue;
        }
        const ddPct = Math.min(((aum / peak) - 1) * 100, 0);
        const ddUsd = Math.min(aum - peak, 0);
        pctData.push([row.Date, ddPct]);
        usdData.push([row.Date, ddUsd]);
      }

      const mode = (DRAWDOWN_MODE === 'usd') ? 'usd' : 'pct';
      const seriesData = mode === 'usd' ? usdData : pctData;
      const validVals = seriesData.map(p => p[1]).filter(v => Number.isFinite(v));
      if (!validVals.length) {
        try { if (drawdownChartInst) { drawdownChartInst.dispose(); drawdownChartInst = null; } } catch {}
        el.innerHTML = '<div class="text-sm text-slate-500">No data</div>';
        return;
      }

      if (!drawdownChartInst) {
        el.innerHTML = '';
        drawdownChartInst = echarts.init(el);
      }

      const formatCurrency = (val, fractionDigits = 0) => {
        if (!Number.isFinite(val)) return '';
        const abs = Math.abs(val);
        const formatted = abs.toLocaleString(undefined, { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits });
        return `${val < 0 ? '-' : ''}$${formatted}`;
      };

      const option = {
        animation: false,
        grid: { left: 56, right: 16, top: 8, bottom: 40 },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'cross' },
          valueFormatter: (v) => {
            if (v == null) return '';
            return mode === 'usd' ? formatCurrency(Number(v), 2) : `${Number(v).toFixed(2)}%`;
          }
        },
        xAxis: { type: 'time', name: 'Date' },
        yAxis: {
          type: 'value',
          name: mode === 'usd' ? 'Drawdown $' : 'Drawdown %',
          max: 0,
          min: 'dataMin',
          axisLabel: {
            formatter: (v) => {
              if (mode === 'usd') {
                const val = Number(v);
                const digits = Math.abs(val) < 1 ? 2 : 0;
                return formatCurrency(val, digits);
              }
              return `${Number(v).toFixed(0)}%`;
            }
          }
        },
        dataZoom: [
          { type: 'inside', throttle: 50 },
          {
            type: 'slider',
            fillerColor: 'rgba(0, 0, 0, 0)',
            height: 40,
            dataBackground: {
              lineStyle: { color: '#f97316' },
              areaStyle: { color: 'rgba(249, 115, 22, 0.2)' }
            }
          }
        ],
        series: [{
          name: mode === 'usd' ? 'Drawdown ($)' : 'Drawdown (%)',
          type: 'line',
          showSymbol: false,
          smooth: false,
          lineStyle: { width: 2, color: '#ef4444' },
          areaStyle: { color: 'rgba(239, 68, 68, 0.15)' },
          data: seriesData
        }]
      };
      drawdownChartInst.setOption(option, true);
    }

    function computeWinLossStreaks(out) {
      const trades = (out || []).filter(r => r.Shares > 0 && !['NotEnoughBars', 'NoBreak', 'NoSize'].includes(r.HitType));
      const winsX = [], winsY = [], lossX = [], lossY = [];
      let curType = null; let curLen = 0;
      for (let i = 0; i < trades.length; i++) {
        const r = trades[i];
        const isWin = Number(r.PnL) > 0;
        const isLoss = Number(r.PnL) < 0;
        const type = isWin ? 'win' : (isLoss ? 'loss' : null);
        if (!type) {
          if (curType && curLen > 0) { const endDate = trades[i - 1].Date; if (curType === 'win') { winsX.push(endDate); winsY.push(curLen); } else { lossX.push(endDate); lossY.push(curLen); } }
          curType = null; curLen = 0; continue;
        }
        if (curType === null) { curType = type; curLen = 1; continue; }
        if (type === curType) { curLen++; }
        else { const endDate = trades[i - 1].Date; if (curType === 'win') { winsX.push(endDate); winsY.push(curLen); } else { lossX.push(endDate); lossY.push(curLen); } curType = type; curLen = 1; }
      }
      if (curType && curLen > 0 && trades.length > 0) { const endDate = trades[trades.length - 1].Date; if (curType === 'win') { winsX.push(endDate); winsY.push(curLen); } else { lossX.push(endDate); lossY.push(curLen); } }
      return { winsX, winsY, lossX, lossY };
    }

    function renderStreakChart(out) {
      applySectionTitle('streakTitle', 'Win/Loss Streaks');
      const el = document.getElementById('streakChart');
      if (!el) return;
      const { winsX, winsY, lossX, lossY } = computeWinLossStreaks(out);
      if ((winsX.length + lossX.length) === 0) {
        try { if (streakChartInst) { streakChartInst.dispose(); streakChartInst = null; } } catch {}
        el.innerHTML = '<div class="text-sm text-slate-500">No data</div>';
        return;
      }
      if (!streakChartInst) streakChartInst = echarts.init(el);
      const winData = winsX.map((d,i)=>[d, winsY[i]]);
      const lossData = lossX.map((d,i)=>[d, -Math.abs(lossY[i])]);
      const option = {
        animation: false,
        grid: { left: 56, right: 16, top: 8, bottom: 40 },
        tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
        xAxis: { type: 'time', name: 'Date' },
        yAxis: { type: 'value', name: 'Consecutive count' },
        dataZoom: [ 
          { type: 'inside', throttle: 50 }, 
          { 
            type: 'slider',
            fillerColor: 'rgba(0, 0, 0, 0)', 
            height: 40,
            dataBackground: {
              lineStyle: { color: '#50C878' },
              areaStyle: { color: 'rgba(80, 200, 120, 0.2)' }
            }
          } 
        ],
        legend: { show: false },
        series: [
          { name: 'Win streak', type: 'bar', itemStyle: { color: '#10b981' }, data: winData },
          { name: 'Loss streak', type: 'bar', itemStyle: { color: '#ef4444' }, data: lossData }
        ]
      };
      streakChartInst.setOption(option, true);
    }

    // -------- CSV Export (Trades) --------
    function getVisibleRowsForExport() {
      if (!Array.isArray(LAST_OUT)) return [];
      let rows = (VIEW_DIR === 'both') ? LAST_OUT.slice() : LAST_OUT.filter(r => (r.Shares>0) && ((VIEW_DIR==='long' && r.Side==='Long') || (VIEW_DIR==='short' && r.Side==='Short')));
      rows.sort((a,b)=>{
        const da = a && a.Date ? a.Date : '';
        const db = b && b.Date ? b.Date : '';
        if (da===db) return 0;
        return da < db ? 1 : -1;
      });
      return rows;
    }

    function buildAoaFromRows(rows) {
  const headers = ['Date','ORH','ORL','OR','OR%','Side','EntryTime','ExitTime','Entry','Exit','LossPrice','TPPrice','HitType','Shares','PnL','pnl_R','AUM','DailyReturn %','Strategy'];
      const aoa = [headers];
      for (const r of rows) {
        const OR_val = (Number.isFinite(r.ORH) && Number.isFinite(r.ORL)) ? (r.ORH - r.ORL) : NaN;
        const OR_pct = (Number.isFinite(OR_val) && Number.isFinite(r.ORL) && r.ORL !== 0) ? Number(((OR_val / r.ORL) * 100).toFixed(2)) : '';
        aoa.push([
          r.Date,
          Number.isFinite(r.ORH) ? Number(r.ORH) : '',
          Number.isFinite(r.ORL) ? Number(r.ORL) : '',
          Number.isFinite(OR_val) ? Number(OR_val) : '',
          OR_pct,
          r.Side || '',
          (r.EntryTime ? fmtTime(r.EntryTime) : ''),
          (r.ExitTime ? fmtTime(r.ExitTime) : ''),
          Number.isFinite(r.Entry) ? Number(r.Entry) : '',
          Number.isFinite(r.Exit) ? Number(r.Exit) : '',
          Number.isFinite(r.StopPrice) ? Number(r.StopPrice) : '',
          Number.isFinite(r.TPPrice) ? Number(r.TPPrice) : '',
          (r.HitType === 'Stop' ? 'Loss' : (r.HitType || '')),
          Number.isFinite(r.Shares) ? Number(r.Shares) : '',
          Number.isFinite(r.PnL) ? Number(r.PnL) : '',
          Number.isFinite(r.pnl_R) ? Number(r.pnl_R) : '',
          Number.isFinite(r.AUM) ? Number(r.AUM) : '',
          Number.isFinite(r.DailyReturn) ? Number(r.DailyReturn) : '',
          r.SourceStrategyId || r.StrategyId || ''
        ]);
      }
      return aoa;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
    }

    function exportTradesCSV() {
      const rows = getVisibleRowsForExport();
      if (!rows.length) { alert('No rows to export.'); return; }
      const aoa = buildAoaFromRows(rows);
      const csv = aoa.map(row => row.map(cell => {
        const s = (cell === null || cell === undefined) ? '' : String(cell);
        if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
        return s;
      }).join(',')).join('\n');
      downloadBlob(new Blob([csv], { type: 'text/csv;charset=utf-8' }), `trades_${currentTicker || 'SYMBOL'}.csv`);
    }

    // Bind Export CSV button
    (function(){
      const btn = document.getElementById('btnExportCSV');
      if (btn) btn.addEventListener('click', exportTradesCSV);
    })();

    let MONTHLY_PERF_MODE = 'pct'; // 'pct' | 'usd'
    let DRAWDOWN_MODE = 'pct'; // 'pct' | 'usd'

    function computeMonthlyPerf(out){
      // Aggregate by YYYY and month index 1..12: both $ PnL and % return per month
      const agg = new Map(); // year -> { pnl:[12], ret:[12] }
      const monthlyAUM = new Map(); // key YYYY-MM -> {startAUM, endAUM}
      let prevAUM = null;
      for (let i=0;i<(out||[]).length;i++){
        const r = out[i];
        if (!r.Date) continue;
        const [y,m] = r.Date.split('-');
        const key = `${y}-${m}`;
        if (!monthlyAUM.has(key)) monthlyAUM.set(key, { startAUM: (prevAUM ?? r.AUM - (Number.isFinite(r.PnL)?r.PnL:0)), endAUM: r.AUM });
        const rec = monthlyAUM.get(key);
        rec.endAUM = r.AUM;
        prevAUM = r.AUM;
      }
      for (const r of (out||[])){
        if (!r.Date) continue;
        const [y,m] = r.Date.split('-');
        const year = y;
        const monthIdx = parseInt(m,10);
        if (!agg.has(year)) agg.set(year, { pnl: Array(12).fill(0), ret: Array(12).fill(0) });
        const a = agg.get(year);
        a.pnl[monthIdx-1] += (Number.isFinite(r.PnL) ? r.PnL : 0);
      }
      // compute % returns per month from monthlyAUM map
      for (const [ym, v] of monthlyAUM.entries()){
        const [yy,mm] = ym.split('-');
        const year = yy; const idx = parseInt(mm,10)-1;
        if (!agg.has(year)) agg.set(year, { pnl: Array(12).fill(0), ret: Array(12).fill(0) });
        const a = agg.get(year);
        const start = v.startAUM; const end = v.endAUM;
        const ret = (Number.isFinite(start) && start!==0 && Number.isFinite(end)) ? ((end-start)/start)*100 : 0;
        a.ret[idx] = ret;
      }
      const years = Array.from(agg.keys()).sort();
      return { years, data: agg };
    }

    function renderMonthlyPerf(out){
      applySectionTitle('monthlyTitle', 'Monthly Performance');
      const host = document.getElementById('monthlyPerf');
      if (!host) return;
      if (!out || !out.length){ host.innerHTML = '<div class="text-sm text-slate-500">No data</div>'; return; }
      const { years, data } = computeMonthlyPerf(out);
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const shadeGreen = (ratio) => {
        if (ratio > 0.8) return 'bg-emerald-400';
        if (ratio > 0.6) return 'bg-emerald-300';
        if (ratio > 0.4) return 'bg-emerald-200';
        if (ratio > 0.2) return 'bg-emerald-100';
        return 'bg-emerald-50';
      };
      const shadeRed = (ratio) => {
        // Increase minimum shade to >= 150 by flooring at rose-200
        if (ratio > 0.8) return 'bg-rose-400';
        if (ratio > 0.5) return 'bg-rose-300';
        return 'bg-rose-200';
      };
      // compute normalization based on selected mode across all months
      let maxAbs = 0;
      for (const y of years){
        const rec = data.get(y) || { pnl: Array(12).fill(0), ret: Array(12).fill(0) };
        for (let i=0;i<12;i++){
          const v = (MONTHLY_PERF_MODE==='pct') ? rec.ret[i] : rec.pnl[i];
          if (Number.isFinite(v)) maxAbs = Math.max(maxAbs, Math.abs(v));
        }
      }
      const cell = (pnl, ret)=>{
        const v = (MONTHLY_PERF_MODE==='pct') ? ret : pnl;
        if (!Number.isFinite(v) || Math.abs(v) < 1e-9) return '<td class="px-2 py-1 text-right text-slate-500">-</td>';
        const pos = v>0;
        const ratio = maxAbs>0 ? Math.min(Math.abs(v)/maxAbs, 1) : 0;
        const bgCls = pos ? shadeGreen(ratio) : shadeRed(ratio);
        const txtCls = pos ? 'text-emerald-900' : 'text-rose-900';
        const val = (MONTHLY_PERF_MODE==='pct') ? `${fmtPct(v)}%` : `$${fmtInt(v)}`;
        return `<td class="px-2 py-1 text-right tabular-nums font-mono ${bgCls} ${txtCls}">${val}</td>`;
      };
      let html = '<div class="overflow-auto"><table class="min-w-full text-sm"><thead><tr><th class="px-2 py-1 text-left">Year</th>' + months.map(m=>`<th class="px-2 py-1 text-right">${m}</th>`).join('') + '</tr></thead><tbody>';
      for (const y of years){
        const rec = data.get(y) || { pnl: Array(12).fill(0), ret: Array(12).fill(0) };
        html += `<tr class="border-t"><td class="px-2 py-1 font-medium">${y}</td>` + rec.pnl.map((pv, i)=>cell(pv, rec.ret[i])).join('') + '</tr>';
      }
      html += '</tbody></table></div>';
      host.innerHTML = html;
    }

    // -----------------------------
    // Param handling + run
    // -----------------------------
    const riskConst = 0.02, AUM0Const = 100000, commissionConst = 0, directionConst = 'both', breakoutBufferConst = 0.01, orbStartConst = '9:30', orbEndConst = '15:30', entryCutoffConst = '12:00', minOrConst = DEFAULT_MIN_OR_PERC;

    function computeFilteredDays() {
      if (!Array.isArray(DAYS) || DAYS.length === 0) return [];
      // DAYS are keys like YYYY-MM-DD, map to weekday via first row in group
      const out = [];
      for (const dayKey of DAYS) {
        const arr = DAY_GROUPS.get(dayKey);
        if (!arr || !arr.length) continue;
        const dow = arr[0].caldt.getDay(); // 0=Sun..6=Sat
        const mapDow = dow === 0 ? 7 : dow; // 1..7 with 7=Sun
        const monthKey = `${dayKey.slice(5, 7)}/${dayKey.slice(0, 4)}`; // MM/YYYY
        const dowOk = VIEW_DOW.has(mapDow) || (mapDow === 7 && VIEW_DOW.has(7));
        const monOk = (VIEW_MONTHS.size === 0) || VIEW_MONTHS.has(monthKey);
        if (dowOk && monOk) out.push(dayKey);
      }
      return out;
    }

    function getBacktestParams() {
      const orb = document.getElementById('inp_orb_m');
      const trg = document.getElementById('inp_target_R');
      const stp = document.getElementById('inp_stop_R');
      const riskPct = document.getElementById('inp_risk_pct');
      const aum0 = document.getElementById('inp_aum0');
      const tStart = document.getElementById('inp_orb_start');
      const tEnd = document.getElementById('inp_orb_end');
      const tCut = document.getElementById('inp_entry_cutoff');
      const minOr = document.getElementById('inp_min_or_perc');
      const filteredDays = computeFilteredDays();
      return {
        symbol: currentTicker,
        days: filteredDays,
        dayGroups: DAY_GROUPS,
        orb_m: (()=>{ const v = orb ? parseInt(orb.value, 10) : NaN; return Number.isFinite(v) ? v : 25; })(),
        target_R: (()=>{ const v = trg ? parseFloat(trg.value) : NaN; return Number.isFinite(v) ? v : 2; })(),
        stop_R: (()=>{ const v = stp ? parseFloat(stp.value) : NaN; return Number.isFinite(v) ? v : 2; })(),
        risk: (()=>{ const v = riskPct ? parseFloat(riskPct.value) : NaN; return Number.isFinite(v) ? (v/100) : riskConst; })(),
        AUM_0: (()=>{ const v = aum0 ? parseFloat(aum0.value) : NaN; return Number.isFinite(v) ? v : AUM0Const; })(),
        commission: commissionConst,
        direction: VIEW_DIR || directionConst,
        orb_start_time: (tStart && tStart.value) ? tStart.value : orbStartConst,
        orb_end_time: (tEnd && tEnd.value) ? tEnd.value : orbEndConst,
        entry_cutoff_time: (tCut && tCut.value) ? tCut.value : entryCutoffConst,
        breakout_buffer: breakoutBufferConst,
        min_or_perc: (()=>{ const v = minOr ? parseFloat(minOr.value) : NaN; return Number.isFinite(v) ? v : minOrConst; })(),
      };
    }

    let runTimer = null;
    function scheduleRun() {
      if (runTimer) clearTimeout(runTimer);
      runTimer = setTimeout(runBacktestIfReady, 150);
    }

    // Time steppers for ORB Start / End / Entry Cutoff
    (function(){
      function adjustTimeInput(id, deltaMin){
        const el = document.getElementById(id);
        if (!el) return;
        const [hh, mm] = (el.value || '00:00').split(':').map(Number);
        const cur = (Number.isFinite(hh) ? hh : 0) * 60 + (Number.isFinite(mm) ? mm : 0);
        const next = cur + (Number(deltaMin) || 0);
        // wrap within 0..1439
        const wrapped = ((next % (24*60)) + (24*60)) % (24*60);
        el.value = toHHMM(wrapped);
        el.dispatchEvent(new Event('change', { bubbles: true }));
      }
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-time-target][data-time-step]');
        if (!btn) return;
        const id = btn.getAttribute('data-time-target');
        const delta = parseInt(btn.getAttribute('data-time-step'), 10) || 0;
        adjustTimeInput(id, delta);
      });
    })();

    // Numeric steppers for orb_m / target_R / stop_R
    (function(){
      function decimals(stepStr){
        if (!stepStr) return 0;
        const s = String(stepStr);
        const idx = s.indexOf('.');
        return idx === -1 ? 0 : (s.length - idx - 1);
      }
      function roundTo(value, step){
        const d = decimals(step);
        return Number(value.toFixed(d));
      }
      function adjustNumberInput(id, deltaUnits){
        const el = document.getElementById(id);
        if (!el) return;
        const stepAttr = parseFloat(el.getAttribute('step') || '1');
        const step = Number.isFinite(stepAttr) && stepAttr > 0 ? stepAttr : 1;
        const minAttr = parseFloat(el.getAttribute('min'));
        const maxAttr = parseFloat(el.getAttribute('max'));
        const defAttr = parseFloat(el.getAttribute('data-default'));
        const curVal = parseFloat(el.value);
        const base = Number.isFinite(curVal) ? curVal : (Number.isFinite(defAttr) ? defAttr : 0);
        const next = base + (Number(deltaUnits) || 0) * step;
        const clamped = Math.min(Number.isFinite(maxAttr) ? maxAttr : Infinity, Math.max(Number.isFinite(minAttr) ? minAttr : -Infinity, next));
        const rounded = roundTo(clamped, step);
        el.value = String(rounded);
        el.dispatchEvent(new Event('change', { bubbles: true }));
      }
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-num-target][data-num-step]');
        if (!btn) return;
        const id = btn.getAttribute('data-num-target');
        const delta = parseFloat(btn.getAttribute('data-num-step')) || 0;
        adjustNumberInput(id, delta);
      });
    })();

    async function runBacktestIfReady() {
      if (!currentTicker) { setStatus('Pick a symbol.'); return; }
      if (!DAYS.length) { setStatus('No data loaded.'); return; }
      const params = getBacktestParams();
      const t0 = performance.now();
      const out = backtest(params);
      const t1 = performance.now();
      setStatus(`Ran ${out.length} day(s) in ${(t1 - t0).toFixed(0)} ms.`);
      setPortfolioContext(false);
      renderSummary(out);
      LAST_OUT = out;
      PORTFOLIO_EQUITY_SERIES = null;
      CURRENT_STRATEGY_PARAMS = params;
      CURRENT_STRATEGY_ID = buildStrategyKey(params);
      CURRENT_STRATEGY_FAVORITE = false;
      CURRENT_STRATEGY_LIVE = false;
      syncFavoriteButton();
      syncAutoBacktestButton();
      highlightAutoResultRow();
      highlightPortfolioRow();
      highlightFavoriteRow();
      highlightLiveRow();
      renderTable(LAST_OUT);
      renderEquityChart(LAST_OUT);
      renderDrawdownChart(LAST_OUT);
      renderStreakChart(LAST_OUT);
      renderMonthlyPerf(LAST_OUT);
      await persistStrategyResult(params, LAST_OUT);
      await refreshFavoriteState(CURRENT_STRATEGY_ID);
    }

    async function loadAndRunForCurrent() {
      if (!currentTicker) return;
      const ok = await loadSymbolData(currentTicker);
      if (ok) { buildMonthOptions(); runBacktestIfReady(); }
    }

    // Responsive charts: resize on window changes
    window.addEventListener('resize', () => {
      try { if (equityChartInst) equityChartInst.resize(); } catch {}
      try { if (drawdownChartInst) drawdownChartInst.resize(); } catch {}
      try { if (streakChartInst) streakChartInst.resize(); } catch {}
      try { if (dailyOutcomeChartInst) dailyOutcomeChartInst.resize(); } catch {}
    });

    // -----------------------------
    // Symbol segment (existing code with auto-run hook)
    // -----------------------------
    function normalizeSymbolEntries(entries) {
      const map = new Map();
      const ordered = [];
      if (!Array.isArray(entries)) return { list: ordered, map };
      for (const entry of entries) {
        let symbol = '';
        let name = '';
        let multiplier = null;
        if (typeof entry === 'string') {
          symbol = entry;
          name = entry;
        } else if (entry && typeof entry === 'object') {
          symbol = entry.symbol;
          name = entry.name || entry.symbol || '';
          multiplier = entry.multiplier;
        } else {
          continue;
        }
        symbol = (symbol || '').toUpperCase().trim();
        if (!symbol || map.has(symbol)) continue;
        const existing = SYMBOL_META.get(symbol) || null;
        const parsedMultiplier = Number(multiplier);
        const finalMultiplier = Number.isFinite(parsedMultiplier) && parsedMultiplier > 0 ? parsedMultiplier : (existing && Number.isFinite(existing.multiplier) ? existing.multiplier : 1);
        const providedPrecision = entry && typeof entry === 'object' && Number.isInteger(entry.precision) && entry.precision >= 0 ? Math.min(entry.precision, 8) : null;
        const meta = {
          symbol,
          name: (typeof name === 'string' && name.trim()) ? name.trim() : (existing && existing.name ? existing.name : symbol),
          multiplier: finalMultiplier,
          precision: providedPrecision != null ? providedPrecision : (existing && Number.isInteger(existing.precision) ? existing.precision : null)
        };
        map.set(symbol, meta);
        ordered.push(meta);
      }
      return { list: ordered, map };
    }

    async function populateTickerSegment() {
      const container = document.getElementById('tickerSegment');
      if (!container) return;
      container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';
      const render = (entries) => {
        const normalized = normalizeSymbolEntries(entries);
        SYMBOL_META = normalized.map instanceof Map ? normalized.map : new Map();
        const list = Array.isArray(normalized.list) ? normalized.list : [];
        container.innerHTML = '';
        if (!list.length) {
          container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">No symbols available.</span>';
          highlightTickerButton(currentTicker);
          return;
        }
        list.forEach((meta) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'w-full h-full px-3 py-2 text-left bg-white hover:bg-emerald-50 transition flex flex-col justify-center gap-0.5 leading-tight';
          btn.setAttribute('data-symbol', meta.symbol);
          btn.setAttribute('title', meta.name);
          btn.dataset.multiplier = String(meta.multiplier);
          btn.innerHTML = `
            <span class="text-sm font-semibold">${meta.symbol}</span>
            <span class="text-xs text-slate-500" data-symbol-name>${meta.name}</span>
          `;
          container.appendChild(btn);
        });
        highlightTickerButton(currentTicker);
      };
      try {
        const res = await fetch('data/index.json', { cache: 'no-cache' });
        if (res.ok) {
          const list = await res.json();
          if (Array.isArray(list) && list.length) { render(list); return; }
        }
      } catch { }
      try {
        const res = await fetch('data/', { cache: 'no-cache' });
        if (res.ok) {
          const text = await res.text();
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let files = [];
          if (ct.includes('text/html')) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            files = Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href')).filter(Boolean);
          } else { files = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean); }
          const regex = /^([A-Za-z0-9-]+)_1m\.csv$/i;
          const syms = [];
          for (const f of files) { const name = (f || '').split('/').pop(); const m = name.match(regex); if (m) syms.push({ symbol: m[1].toUpperCase(), name: m[1].toUpperCase(), multiplier: undefined }); }
          if (syms.length) { render(syms); return; }
        }
      } catch { }
      render(['TQQQ', 'TSLA', 'PLTR', 'UVXY']);
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#sessionSegment button[data-session-name]');
      if (!btn) return;
      const name = btn.getAttribute('data-session-name');
      if (!name) return;
      setActiveSession(name);
    });

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#tickerSegment button[data-symbol]');
      if (!btn) return;
      const seg = document.getElementById('tickerSegment'); if (!seg) return;
      seg.querySelectorAll('button').forEach(b => { b.classList.remove('bg-slate-800', 'text-white', 'focus:outline-none'); if (!b.classList.contains('bg-white')) b.classList.add('bg-white'); if (!b.classList.contains('hover:bg-slate-100')) b.classList.add('hover:bg-slate-100'); });
      btn.classList.add('bg-slate-800', 'text-white', 'focus:outline-none'); btn.classList.remove('bg-white', 'hover:bg-slate-100');
      setTicker(btn.getAttribute('data-symbol'));
      loadAndRunForCurrent();
    });

    // Direction filter segment handlers
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#dirSegment button[data-dir]');
      if (!btn) return;
      const seg = document.getElementById('dirSegment'); if (!seg) return;
      seg.querySelectorAll('button').forEach(b => { b.classList.remove('bg-slate-800', 'text-white', 'focus:outline-none'); if (!b.classList.contains('bg-white')) b.classList.add('bg-white'); if (!b.classList.contains('hover:bg-slate-100')) b.classList.add('hover:bg-slate-100'); });
      btn.classList.add('bg-slate-800', 'text-white', 'focus:outline-none'); btn.classList.remove('bg-white', 'hover:bg-slate-100');
      VIEW_DIR = (btn.getAttribute('data-dir') || 'both');
      // Re-run so summary and trades reflect the selected direction
      scheduleRun();
    });

    function syncDowUI() {
      const seg = document.getElementById('dowSegment'); if (!seg) return;
      seg.querySelectorAll('button[data-dow]').forEach(b => {
        const n = Number(b.getAttribute('data-dow'));
        const active = VIEW_DOW.has(n);
        b.classList.toggle('bg-slate-800', active);
        b.classList.toggle('text-white', active);
        b.classList.toggle('bg-white', !active);
        b.classList.toggle('hover:bg-slate-100', !active);
      });
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#dowSegment button[data-dow]');
      if (!btn) return;
      const n = Number(btn.getAttribute('data-dow'));
      if (VIEW_DOW.has(n)) VIEW_DOW.delete(n); else VIEW_DOW.add(n);
      // Allow empty selection so user can see zero-trade results
      syncDowUI();
      scheduleRun();
    });

    const favoriteSelectEl = document.getElementById('favoriteSelect');
    if (favoriteSelectEl) {
      favoriteSelectEl.addEventListener('change', async (e) => {
        const select = e.target;
        const id = select.value;
        if (!id) return;
        const record = CURRENT_SYMBOL_FAVORITES.find(item => item && item.id === id);
        if (record) {
          try {
            await applyFavoriteStrategy(record);
          } catch {}
        }
      });
    }

    (function initPortfolioButton(){
      const btn = document.getElementById('btnAddPortfolio');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        if (!Array.isArray(LAST_OUT) || LAST_OUT.length === 0) {
          setStatus('Run a backtest before saving to the portfolio.');
          return;
        }
        const params = getBacktestParams();
        if (!params || !params.symbol) {
          setStatus('Pick a symbol before saving to the portfolio.');
          return;
        }
        ensurePortfolioListLoaded();
        const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
        const statusEl = document.getElementById('status');
        const previousMsg = statusEl ? statusEl.textContent : '';
        try {
          await persistPortfolioEntry(params, LAST_OUT);
          await refreshPortfolioTable();
          setStatus(`Saved to ${portfolioName}.`);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === `Saved to ${portfolioName}.`) {
                statusEl.textContent = previousMsg;
              }
            }, 2000);
          }
        } catch (err) {
          setStatus('Failed to save to portfolio.');
          const errStatusEl = document.getElementById('status');
          if (errStatusEl) {
            setTimeout(() => {
              if (errStatusEl.textContent === 'Failed to save to portfolio.') {
                errStatusEl.textContent = '';
              }
            }, 4000);
          }
        }
      });
    })();

    document.addEventListener('click', async (e) => {
      const favLoadBtn = e.target.closest('[data-favorite-load]');
      const liveLoadBtn = e.target.closest('[data-live-load]');
      if (liveLoadBtn) {
        const strategyId = liveLoadBtn.getAttribute('data-live-load');
        if (strategyId) {
          const record = Array.isArray(CURRENT_SYMBOL_LIVE)
            ? CURRENT_SYMBOL_LIVE.find(item => item && (item.id === strategyId || item.strategyId === strategyId))
            : null;
          if (record) {
            try {
              await applyFavoriteStrategy(record);
            } catch {}
          }
        }
        return;
      }
      if (favLoadBtn) {
        const strategyId = favLoadBtn.getAttribute('data-favorite-load');
        if (strategyId) {
          const record = Array.isArray(CURRENT_SYMBOL_FAVORITES)
            ? CURRENT_SYMBOL_FAVORITES.find(item => item && (item.id === strategyId || item.strategyId === strategyId))
            : null;
          if (record) {
            try {
              await applyFavoriteStrategy(record);
            } catch {}
          }
        }
        return;
      }

      const loadBtn = e.target.closest('[data-portfolio-load]');
      if (loadBtn) {
        const strategyId = loadBtn.getAttribute('data-portfolio-load');
        if (strategyId) {
          const record = PORTFOLIO_CACHE ? PORTFOLIO_CACHE.get(strategyId) : null;
          if (record && record.params) {
            const idForLoad = record.strategyId || strategyId;
            applyFavoriteStrategy({ id: idForLoad, params: record.params, favorite: false }).catch(() => {});
          }
        }
        return;
      }

      const btn = e.target.closest('[data-portfolio-delete]');
      if (!btn) return;
      const id = btn.getAttribute('data-portfolio-delete');
      if (!id) return;
      const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
      if (!window.confirm(`Remove this strategy from ${portfolioName}?`)) return;
      const statusEl = document.getElementById('status');
      const previousMsg = statusEl ? statusEl.textContent : '';
      try {
        await deletePortfolioEntry(id);
        await refreshPortfolioTable();
        setStatus(`Removed from ${portfolioName}.`);
        if (statusEl) {
          setTimeout(() => {
            if (statusEl.textContent === `Removed from ${portfolioName}.`) {
              statusEl.textContent = previousMsg;
            }
          }, 2000);
        }
      } catch (err) {
        setStatus('Failed to delete portfolio entry.');
        const errStatusEl = document.getElementById('status');
        if (errStatusEl) {
          setTimeout(() => {
            if (errStatusEl.textContent === 'Failed to delete portfolio entry.') {
              errStatusEl.textContent = previousMsg;
            }
          }, 4000);
        }
      }
    });

    const portfolioIncludeAll = document.getElementById('portfolioIncludeAll');
    if (portfolioIncludeAll) {
      portfolioIncludeAll.addEventListener('change', () => {
        const tbody = document.getElementById('portfolioTableBody');
        if (!tbody) return;
        const allChecked = !!portfolioIncludeAll.checked;
        const checkboxes = Array.from(tbody.querySelectorAll('input[data-portfolio-include]'));
        checkboxes.forEach(cb => {
          cb.checked = allChecked;
          cb.dispatchEvent(new Event('change', { bubbles: true }));
        });
      });
    }

    document.addEventListener('change', (e) => {
      const cb = e.target.closest('input[data-portfolio-include]');
      if (!cb) return;
      const id = cb.getAttribute('data-portfolio-include');
      if (!id) return;
      const include = !!cb.checked;
      PORTFOLIO_INCLUDE_STATE.set(id, include);
      const row = cb.closest('tr');
      if (row) {
        row.classList.toggle('opacity-60', !include);
        row.dataset.portfolioInclude = include ? '1' : '0';
      }
      const allToggle = document.getElementById('portfolioIncludeAll');
      if (allToggle) {
        const tbody = document.getElementById('portfolioTableBody');
        const checkboxes = tbody ? Array.from(tbody.querySelectorAll('input[data-portfolio-include]')) : [];
        const allChecked = checkboxes.length > 0 && checkboxes.every(box => box.checked);
        allToggle.checked = allChecked;
      }
    });

    document.addEventListener('click', async (e) => {
      const tradeSortBtn = e.target.closest('[data-trade-sort]');
      if (tradeSortBtn) {
        const key = tradeSortBtn.getAttribute('data-trade-sort');
        if (key) {
          if (TRADES_SORT && TRADES_SORT.key === key) {
            TRADES_SORT.direction = TRADES_SORT.direction === 'asc' ? 'desc' : 'asc';
          } else {
            const defaultDir = TRADE_SORT_DEFAULT_DIRECTION[key] || 'desc';
            TRADES_SORT = { key, direction: defaultDir };
          }
          renderTable(LAST_OUT || []);
        }
        return;
      }

      const sortBtn = e.target.closest('[data-auto-sort]');
      if (sortBtn) {
        const key = sortBtn.getAttribute('data-auto-sort');
        if (key) {
          const ascKeys = new Set(['strategyId','direction','start','end']);
          if (AUTO_RESULTS_SORT && AUTO_RESULTS_SORT.key === key) {
            AUTO_RESULTS_SORT.direction = AUTO_RESULTS_SORT.direction === 'desc' ? 'asc' : 'desc';
          } else {
            const defaultDir = AUTO_SORT_DEFAULT_DIRECTION[key] || (ascKeys.has(key) ? 'asc' : 'desc');
            AUTO_RESULTS_SORT = { key, direction: defaultDir };
          }
          applyAutoResultsSort();
        }
        return;
      }

      const btn = e.target.closest('[data-auto-load]');
      if (!btn) return;
      const id = btn.getAttribute('data-auto-load');
      if (!id) return;
      const entry = AUTO_RESULTS_CACHE.get(id);
      if (entry) {
        try {
          await applyAutoResult(entry);
        } catch {}
      }
    });

    (function initFavoriteButton(){
      const btn = document.getElementById('btnAddFavorite');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        if (!CURRENT_STRATEGY_ID || !Array.isArray(LAST_OUT) || LAST_OUT.length === 0) return;
        const params = CURRENT_STRATEGY_PARAMS || getBacktestParams();
        if (!params) return;
        const nextFavorite = !CURRENT_STRATEGY_FAVORITE;
        const nextLive = nextFavorite ? CURRENT_STRATEGY_LIVE : false;
        const statusEl = document.getElementById('status');
        const previousMsg = statusEl ? statusEl.textContent : '';
        try {
          await persistStrategyResult(params, LAST_OUT, { force: true, favoriteOverride: nextFavorite, liveOverride: nextLive });
          CURRENT_STRATEGY_FAVORITE = nextFavorite;
          CURRENT_STRATEGY_LIVE = nextLive;
          syncFavoriteButton();
          const msg = nextFavorite ? 'Marked strategy as favorite.' : 'Removed strategy from favorites.';
          setStatus(msg);
          await Promise.all([
            loadFavoritesForSymbol(currentTicker),
            loadLiveStrategiesForSymbol()
          ]);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === msg) {
                statusEl.textContent = previousMsg;
              }
            }, 2000);
          }
        } catch (err) {
          console.error('Failed to update favorite state', err);
          setStatus('Failed to update favorite.');
          await refreshFavoriteState(CURRENT_STRATEGY_ID);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === 'Failed to update favorite.') {
                statusEl.textContent = previousMsg;
              }
            }, 3000);
          }
        }
      });
    })();

    (function initLiveButton(){
      const btn = document.getElementById('btnToggleLive');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        if (!CURRENT_STRATEGY_ID || !CURRENT_STRATEGY_FAVORITE) return;
        if (!Array.isArray(LAST_OUT) || LAST_OUT.length === 0) return;
        const params = CURRENT_STRATEGY_PARAMS || getBacktestParams();
        if (!params) return;
        const nextLive = !CURRENT_STRATEGY_LIVE;
        const statusEl = document.getElementById('status');
        const previousMsg = statusEl ? statusEl.textContent : '';
        try {
          await persistStrategyResult(params, LAST_OUT, { force: true, favoriteOverride: true, liveOverride: nextLive });
          CURRENT_STRATEGY_LIVE = nextLive;
          syncLiveButton();
          const msg = nextLive ? 'Live strategy enabled.' : 'Live strategy disabled.';
          setStatus(msg);
          await Promise.all([
            loadFavoritesForSymbol(currentTicker),
            loadLiveStrategiesForSymbol()
          ]);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === msg) {
                statusEl.textContent = previousMsg;
              }
            }, 2000);
          }
        } catch (err) {
          console.error('Failed to toggle live state', err);
          setStatus('Failed to update live flag.');
          await refreshFavoriteState(CURRENT_STRATEGY_ID);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === 'Failed to update live flag.') {
                statusEl.textContent = previousMsg;
              }
            }, 3000);
          }
        }
      });
    })();

    (function initPortfolioControls(){
      ensurePortfolioListLoaded();
      populatePortfolioSelect();
      refreshPortfolioTable().catch(()=>{});
      const createBtn = document.getElementById('btnCreatePortfolio');
      if (createBtn) {
        createBtn.addEventListener('click', () => {
          createNewPortfolio();
        });
      }
      const select = document.getElementById('portfolioSelect');
      if (select) {
        select.addEventListener('change', () => {
          const val = select.value;
          if (!val) return;
          setCurrentPortfolio(val);
        });
      }
    })();

    (function initRunPortfolioButton(){
      const btn = document.getElementById('btnRunPortfolio');
      if (!btn) return;
      btn.addEventListener('click', () => {
        runPortfolio();
      });
    })();

    (function initAutoBacktestButton(){
      const btn = document.getElementById('btnAutoBacktest');
      if (!btn) return;
      btn.addEventListener('click', () => {
        if (AUTO_BACKTEST_RUNNING) {
          if (!AUTO_BACKTEST_PAUSE_REQUESTED) {
            pauseAutoBacktest();
          }
          return;
        }
        startAutoBacktest();
      });
      syncAutoBacktestButton();
    })();

    (function initClearAutoButton(){
      const btn = document.getElementById('btnClearAuto');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        if (!currentTicker) { setAutoStatus('Pick a symbol before clearing auto data.'); return; }
        if (!window.confirm('Clear saved auto backtest results for this symbol?')) return;
        const statusEl = document.getElementById('autoResultsStatus');
        const previousMsg = statusEl ? statusEl.textContent : '';
        setAutoStatus('Clearing auto backtest data…');
        try {
          await clearAutoResultsForSymbol(currentTicker);
          resetAutoBacktestState(currentTicker);
          AUTO_RESULTS_CACHE = new Map();
          await loadAutoResultsForSymbol(currentTicker);
          setAutoStatus('Auto backtest data cleared.');
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === 'Auto backtest data cleared.') {
                statusEl.textContent = previousMsg;
              }
            }, 2000);
          }
        } catch (err) {
          console.error('Failed to clear auto backtest data', err);
          setAutoStatus('Failed to clear auto backtest data.');
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === 'Failed to clear auto backtest data.') {
                statusEl.textContent = previousMsg;
              }
            }, 3000);
          }
        } finally {
          syncAutoBacktestButton();
        }
      });
    })();

    (function initClearPortfolioButton(){
      const btn = document.getElementById('btnClearPortfolio');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        ensurePortfolioListLoaded();
        const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
        if (!window.confirm(`Clear all saved strategies from ${portfolioName}?`)) return;
        const statusEl = document.getElementById('status');
        const previousMsg = statusEl ? statusEl.textContent : '';
        try {
          await clearPortfolioEntries();
          await refreshPortfolioTable();
          setPortfolioContext(false);
          setStatus(`${portfolioName} cleared.`);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === `${portfolioName} cleared.`) {
                statusEl.textContent = previousMsg;
              }
            }, 2000);
          }
        } catch (err) {
          setStatus('Failed to clear portfolio.');
          const errStatusEl = document.getElementById('status');
          if (errStatusEl) {
            setTimeout(() => {
              if (errStatusEl.textContent === 'Failed to clear portfolio.') {
                errStatusEl.textContent = previousMsg;
              }
            }, 4000);
          }
        }
      });
    })();

    // -----------------------------
    // Month multi-select helpers
    // -----------------------------
    function monthChoicesFromDays() {
      const set = new Set();
      for (const dayKey of DAYS) {
        const mk = `${dayKey.slice(5,7)}/${dayKey.slice(0,4)}`;
        set.add(mk);
      }
      // Sort descending by year-month
      return Array.from(set).sort((a,b)=>{
        const [am,ay] = a.split('/').map(Number);
        const [bm,by] = b.split('/').map(Number);
        if (ay!==by) return by-ay; // year desc
        return bm-am; // month desc
      });
    }

    function buildMonthOptions() {
      AVAILABLE_MONTHS = monthChoicesFromDays();
      const list = document.getElementById('sumMonthMultiList');
      if (!list) return;
      list.innerHTML = AVAILABLE_MONTHS.map(m => `
        <label class="flex items-center gap-2 px-2 py-1 rounded hover:bg-slate-50 cursor-pointer">
          <input type="checkbox" class="h-4 w-4 rounded border-slate-300" data-month="${m}" ${VIEW_MONTHS.has(m)?'checked':''} />
          <span class="text-sm text-slate-800">${m}</span>
        </label>
      `).join('');
      updateMonthLabel();
    }

    function updateMonthLabel(){
      const lbl = document.getElementById('sumMonthMultiLabel'); if (!lbl) return;
      if (VIEW_MONTHS.size===0 || VIEW_MONTHS.size===AVAILABLE_MONTHS.length) { lbl.textContent = 'All months'; return; }
      if (VIEW_MONTHS.size<=2) { lbl.textContent = Array.from(VIEW_MONTHS).sort().join(', '); return; }
      lbl.textContent = `${VIEW_MONTHS.size} selected`;
    }

    // Toggle dropdown open/close
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#sumMonthMultiBtn');
      const menu = document.getElementById('sumMonthMultiMenu');
      if (btn && menu) { menu.classList.toggle('hidden'); return; }
      // Close when clicking outside
      if (menu && !menu.contains(e.target) && !e.target.closest('#sumMonthMultiBtn')) {
        menu.classList.add('hidden');
      }
    });

    // Select all / Clear
    document.addEventListener('click', (e) => {
      const selAll = e.target.closest('#sumMonthSelectAll');
      const clrAll = e.target.closest('#sumMonthClearAll');
      if (!selAll && !clrAll) return;
      if (selAll) VIEW_MONTHS = new Set(AVAILABLE_MONTHS);
      if (clrAll) VIEW_MONTHS = new Set();
      // sync checkboxes
      document.querySelectorAll('#sumMonthMultiList input[type="checkbox"]').forEach(cb => { const m = cb.getAttribute('data-month'); cb.checked = VIEW_MONTHS.has(m); });
      updateMonthLabel();
      scheduleRun();
    });

    // Checkbox toggles
    document.addEventListener('change', (e) => {
      const cb = e.target.closest('#sumMonthMultiList input[type="checkbox"]');
      if (!cb) return;
      const m = cb.getAttribute('data-month');
      if (cb.checked) VIEW_MONTHS.add(m); else VIEW_MONTHS.delete(m);
      updateMonthLabel();
      scheduleRun();
    });

    // Param input handling: allow clearing on input; clamp on change
    (function () {
      const orb = document.getElementById('inp_orb_m');
      const trg = document.getElementById('inp_target_R');
      const stp = document.getElementById('inp_stop_R');
      const riskPct = document.getElementById('inp_risk_pct');
      const aum0 = document.getElementById('inp_aum0');
      const minOr = document.getElementById('inp_min_or_perc');
      const tStart = document.getElementById('inp_orb_start');
      const tEnd = document.getElementById('inp_orb_end');
      const tCut = document.getElementById('inp_entry_cutoff');
      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
      function onInputNumber(el, def, min, max){
        const raw = el.value;
        if (raw === '') return; // allow clearing; skip run until change/valid
        const v = parseFloat(raw);
        if (!Number.isFinite(v)) return; // ignore partial strings like '-' or '.'
        const clamped = clamp(v, min, max);
        if (clamped !== v) {
          el.value = String(clamped);
        }
        scheduleRun();
      }
      function onChangeNumber(el, def, min, max){
        const v = parseFloat(el.value);
        el.value = String(clamp(Number.isFinite(v) ? v : def, min, max));
        scheduleRun();
      }
      if (orb) {
        orb.addEventListener('input', () => onInputNumber(orb, 25, 1, 120));
        orb.addEventListener('change', () => onChangeNumber(orb, 25, 1, 120));
      }
      if (trg) {
        trg.addEventListener('input', () => onInputNumber(trg, 2, 0, 100));
        trg.addEventListener('change', () => onChangeNumber(trg, 2, 0, 100));
      }
      if (stp) {
        stp.addEventListener('input', () => onInputNumber(stp, 2, 0, 100));
        stp.addEventListener('change', () => onChangeNumber(stp, 2, 0, 100));
      }
      if (riskPct) {
        riskPct.addEventListener('input', () => onInputNumber(riskPct, 2, 0, 100));
        riskPct.addEventListener('change', () => onChangeNumber(riskPct, 2, 0, 100));
      }
      if (aum0) {
        aum0.addEventListener('input', () => onInputNumber(aum0, 100000, 0, 1000000000));
        aum0.addEventListener('change', () => onChangeNumber(aum0, 100000, 0, 1000000000));
      }
      if (minOr) {
        minOr.addEventListener('input', () => onInputNumber(minOr, 0.2, 0, 10));
        minOr.addEventListener('change', () => onChangeNumber(minOr, 0.2, 0, 10));
      }
      const onTimeInput = () => {
        clearSessionSelection();
        scheduleRun();
      };
      const onTimeChange = () => {
        syncSessionSelectionFromInputs();
        scheduleRun();
      };
      if (tStart) {
        tStart.addEventListener('input', onTimeInput);
        tStart.addEventListener('change', onTimeChange);
      }
      if (tEnd) {
        tEnd.addEventListener('input', onTimeInput);
        tEnd.addEventListener('change', onTimeChange);
      }
      if (tCut) {
        tCut.addEventListener('input', onTimeInput);
        tCut.addEventListener('change', onTimeChange);
      }
    })();

    // Inline arrow navigation across primary numeric fields
    (function(){
      const focusField = (el, position) => {
        if (!el || typeof el.focus !== 'function') return;
        const applyFocus = () => {
          el.focus();
          try {
            if (typeof el.setSelectionRange === 'function') {
              const len = (el.value || '').length;
              const offset = position === 'start' ? 0 : len;
              el.setSelectionRange(offset, offset);
            }
          } catch (err) {
            // number inputs may reject setSelectionRange; ignore.
          }
        };
        // Schedule after current event to avoid being overridden by the native handler
        requestAnimationFrame(applyFocus);
      };

      const isArrow = (event, key) => {
        if (!event) return false;
        const normalized = event.key || '';
        return normalized === key || normalized === key.replace('Arrow', '');
      };

      const configs = [
        { id: 'inp_orb_m', next: 'inp_target_R' },
        { id: 'inp_target_R', prev: 'inp_orb_m', next: 'inp_stop_R' },
        { id: 'inp_stop_R', prev: 'inp_target_R', next: 'inp_orb_start' }
      ];

      configs.forEach(cfg => {
        const field = document.getElementById(cfg.id);
        if (!field) return;
        field.addEventListener('keydown', (event) => {
          if (event.shiftKey || event.ctrlKey || event.metaKey || event.altKey) return;
          const raw = field.value == null ? '' : String(field.value);
          let start = raw.length;
          let end = raw.length;
          try {
            const selStart = field.selectionStart;
            const selEnd = field.selectionEnd;
            if (typeof selStart === 'number') start = selStart;
            if (typeof selEnd === 'number') end = selEnd;
          } catch (err) {
            // selectionStart/End may be unsupported; default to assuming caret at end
          }

          if (cfg.next && isArrow(event, 'ArrowRight') && start === end && end === raw.length) {
            event.preventDefault();
            focusField(document.getElementById(cfg.next), 'start');
            return;
          }

          if (cfg.prev && isArrow(event, 'ArrowLeft') && start === 0 && start === end) {
            event.preventDefault();
            focusField(document.getElementById(cfg.prev), 'end');
          }
        });
      });
    })();

    // Drawdown toggle handlers
    (function(){
      const btnPct = document.getElementById('ddBtnPct');
      const btnUsd = document.getElementById('ddBtnUsd');
      function syncUI(){
        if (!btnPct || !btnUsd) return;
        btnPct.classList.toggle('bg-white', DRAWDOWN_MODE === 'pct');
        btnPct.classList.toggle('ring-1', DRAWDOWN_MODE === 'pct');
        btnPct.classList.toggle('ring-slate-300', DRAWDOWN_MODE === 'pct');
        btnUsd.classList.toggle('bg-white', DRAWDOWN_MODE === 'usd');
        btnUsd.classList.toggle('ring-1', DRAWDOWN_MODE === 'usd');
        btnUsd.classList.toggle('ring-slate-300', DRAWDOWN_MODE === 'usd');
      }
      if (btnPct) btnPct.addEventListener('click', () => {
        DRAWDOWN_MODE = 'pct';
        syncUI();
        renderDrawdownChart(LAST_OUT || []);
      });
      if (btnUsd) btnUsd.addEventListener('click', () => {
        DRAWDOWN_MODE = 'usd';
        syncUI();
        renderDrawdownChart(LAST_OUT || []);
      });
      syncUI();
    })();

    // Monthly performance toggle handlers
    (function(){
      const btnPct = document.getElementById('mpBtnPct');
      const btnUsd = document.getElementById('mpBtnUsd');
      function syncUI(){
        if (!btnPct || !btnUsd) return;
        btnPct.classList.toggle('bg-white', MONTHLY_PERF_MODE==='pct');
        btnPct.classList.toggle('ring-1', MONTHLY_PERF_MODE==='pct');
        btnPct.classList.toggle('ring-slate-300', MONTHLY_PERF_MODE==='pct');
        btnUsd.classList.toggle('bg-white', MONTHLY_PERF_MODE==='usd');
        btnUsd.classList.toggle('ring-1', MONTHLY_PERF_MODE==='usd');
        btnUsd.classList.toggle('ring-slate-300', MONTHLY_PERF_MODE==='usd');
      }
      if (btnPct) btnPct.addEventListener('click', ()=>{ MONTHLY_PERF_MODE='pct'; syncUI(); renderMonthlyPerf(LAST_OUT||[]); });
      if (btnUsd) btnUsd.addEventListener('click', ()=>{ MONTHLY_PERF_MODE='usd'; syncUI(); renderMonthlyPerf(LAST_OUT||[]); });
      syncUI();
    })();

    // init
    populateSessionSegment().catch(()=>{});
    populateTickerSegment().catch(()=>{});
    initModeTabs();
    initSecondaryNav();
    initAutoConfigPanel();
    initAutoSortSelect();
    syncFavoriteButton();
    loadFavoritesForSymbol(currentTicker).catch(()=>{});
    loadLiveStrategiesForSymbol().catch(()=>{});
    loadAutoResultsForSymbol(currentTicker).catch(()=>{});
    updateTradeSortHeaders();
  </script>
</body>
</html>
