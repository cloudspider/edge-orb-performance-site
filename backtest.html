<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ORB Backtest</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.tailframes.com/releases/latest/tailframes.min.js" defer></script>
  <script src="https://cdn.plot.ly/plotly-2.31.1.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
  .num-pos { color: #10b981 !important; }
  .num-neg { color: #9f1239 !important; }
    .sticky-th { position: sticky; top: 0; background: white; z-index: 1; }
    .shadow-soft { box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
    thead th { position: sticky; top: 0; background: white; z-index: 1; }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Site navigation -->
  <nav class="bg-white border-b border-slate-200 sticky top-0 z-50 shadow-sm">
  <div class="max-w-screen-2xl mx-auto px-6 py-3 flex items-center gap-3">
      <div class="flex items-center gap-2 font-semibold text-slate-800">
        <svg class="h-5 w-5 text-emerald-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" fill="currentColor" aria-hidden="true"><path d="M192 384L88.5 384C63.6 384 48.3 356.9 61.1 335.5L114 247.3C122.7 232.8 138.3 224 155.2 224L250.2 224C326.3 95.1 439.8 88.6 515.7 99.7C528.5 101.6 538.5 111.6 540.3 124.3C551.4 200.2 544.9 313.7 416 389.8L416 484.8C416 501.7 407.2 517.3 392.7 526L304.5 578.9C283.2 591.7 256 576.3 256 551.5L256 448C256 412.7 227.3 384 192 384L191.9 384zM464 224C464 197.5 442.5 176 416 176C389.5 176 368 197.5 368 224C368 250.5 389.5 272 416 272C442.5 272 464 250.5 464 224z"/></svg>
        <span>ORB</span>
      </div>
      <div class="flex items-center gap-2">
        <a data-nav href="index.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Performance</a>
        <a data-nav href="backtest.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Backtest</a>
      </div>
    </div>
  </nav>
  <script>
    // Activate nav item for current page
    (function(){
      try {
        const file = (location.pathname.split('/').pop() || 'backtest.html').toLowerCase();
        document.querySelectorAll('a[data-nav]').forEach(a => {
          const href = (a.getAttribute('href') || '').toLowerCase();
          const active = href === file || (file === '' && href.endsWith('index.html'));
          a.classList.toggle('bg-slate-800', active);
          a.classList.toggle('text-white', active);
          a.classList.toggle('hover:bg-slate-100', !active);
          if (active) a.setAttribute('aria-current','page'); else a.removeAttribute('aria-current');
        });
      } catch {}
    })();
  </script>

  <div class="max-w-screen-2xl mx-auto p-6 space-y-6">
    <header class="mb-2">
      <h1 id="mainTitle" class="text-2xl md:text-3xl font-semibold">ORB Backtest</h1>
      <p class="text-slate-600 mt-1">Pick a symbol and tweak parameters — results auto-update.</p>
    </header>

    <!-- Symbol segmented control + Params -->
    <section id="symbolPicker" class="bg-white rounded-2xl shadow-soft p-3 md:p-4">
      <h2 class="font-semibold mb-3">ORB Settings</h2>
      <div class="flex items-start gap-4 flex-col md:flex-row">
        <div class="flex-1 min-w-0">
          <div class="flex items-center gap-2 mb-2">
            <div class="flex-1 min-w-0 overflow-x-auto">
              <div id="tickerSegment" class="inline-flex min-w-max rounded-xl border border-slate-200 overflow-hidden whitespace-nowrap">
                <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
              </div>
            </div>
          </div>
          <div id="status" class="text-xs text-slate-500"></div>
        </div>
        <div class="w-full md:w-[860px] grid grid-cols-1 sm:grid-cols-3 md:grid-cols-6 gap-3">
          <label class="block">
            <span class="text-sm text-slate-600">orb_m</span>
            <input id="inp_orb_m" type="number" min="1" max="120" step="1" value="25" class="mt-1 w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm" />
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">target_R</span>
            <input id="inp_target_R" type="number" min="0" max="100" step="0.1" value="2" class="mt-1 w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm" />
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">loss_R</span>
            <input id="inp_stop_R" type="number" min="0" max="100" step="0.1" value="2" class="mt-1 w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm" />
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">ORB Start</span>
            <input id="inp_orb_start" type="time" step="60" value="09:30" class="mt-1 w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm" />
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">ORB End</span>
            <input id="inp_orb_end" type="time" step="60" value="15:30" class="mt-1 w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm" />
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">Entry Cutoff</span>
            <input id="inp_entry_cutoff" type="time" step="60" value="12:00" class="mt-1 w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm" />
          </label>
        </div>
      </div>
    </section>

    <!-- Filters -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <h2 class="font-semibold mb-3">Filters</h2>
      <div class="flex flex-wrap items-center gap-3">
        <div id="dirSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden" aria-label="Direction">
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white" data-dir="both">Both</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-l border-slate-200" data-dir="long">Long</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-l border-slate-200" data-dir="short">Short</button>
        </div>

        <div id="dowSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden" aria-label="Weekdays">
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white" data-dow="1">Mon</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="2">Tue</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="3">Wed</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="4">Thu</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="5">Fri</button>
        </div>

        <div class="relative inline-block" aria-label="Months">
          <button id="sumMonthMultiBtn" type="button" class="inline-flex items-center justify-between gap-2 bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm min-w-[160px]">
            <span id="sumMonthMultiLabel" class="truncate">All months</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
          </button>
          <div id="sumMonthMultiMenu" class="absolute z-30 mt-1 w-64 bg-white border border-slate-200 rounded-xl shadow-soft p-2 hidden">
            <div class="sticky top-0 bg-white z-10 px-2 pb-2 border-b border-slate-200 flex items-center justify-between gap-2">
              <button id="sumMonthSelectAll" type="button" class="text-xs font-medium text-emerald-700 hover:text-emerald-900 hover:underline">Select all</button>
              <button id="sumMonthClearAll" type="button" class="text-xs text-slate-600 hover:text-slate-800 hover:underline">Clear</button>
            </div>
            <div id="sumMonthMultiList" class="max-h-64 overflow-auto"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Summary -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <h2 class="font-semibold mb-3">Summary</h2>
      <div id="summary" class="grid sm:grid-cols-2 lg:grid-cols-2 gap-4"></div>
    </section>

    <!-- Equity Chart -->
      <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
        <h2 class="font-semibold mb-3">Equity</h2>
        <div id="equityChart" class="w-full h-[360px]"></div>
      </section>

      <!-- Win/Loss Streaks Chart -->
      <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
        <h2 class="font-semibold mb-3">Win/Loss Streaks</h2>
        <div id="streakChart" class="w-full h-[280px]"></div>
      </section>

    <!-- Trades Table -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <h2 class="font-semibold mb-3">Trades</h2>
      <div class="overflow-auto max-h-[65vh] border rounded-xl">
        <table class="min-w-full text-sm">
          <thead>
            <tr class="border-b">
              <th class="px-3 py-2 text-left">Date</th>
              <th class="px-3 py-2 text-right">ORH</th>
              <th class="px-3 py-2 text-right">ORL</th>
              <th class="px-3 py-2">Side</th>
              <th class="px-3 py-2">EntryTime</th>
              <th class="px-3 py-2 text-right">Entry</th>
              <th class="px-3 py-2">ExitTime</th>
              <th class="px-3 py-2 text-right">Exit</th>
              <th class="px-3 py-2 text-right">LossPrice</th>
              <th class="px-3 py-2 text-right">TPPrice</th>
              <th class="px-3 py-2">HitType</th>
              <th class="px-3 py-2 text-right">Shares</th>
              <th class="px-3 py-2 text-right">PnL</th>
              <th class="px-3 py-2 text-right">pnl_R</th>
              <th class="px-3 py-2 text-right">AUM</th>
              <th class="px-3 py-2 text-right">DailyReturn %</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </section>
  </div>

  <script>
    // -----------------------------
    // Utilities
    // -----------------------------
    const pad2 = (n) => String(n).padStart(2, '0');
    const dateKeyFromStr = (val) => {
      if (val == null) return null;
      if (typeof val === 'string') {
        const m = val.trim().match(/^(\d{4}-\d{2}-\d{2})/);
        if (m) return m[1];
      }
      const d = new Date(val);
      if (isNaN(d)) return null;
      return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; // local date key
    };
    const parseTimeHHMM = (hhmm) => { const [h,m] = (hhmm||'').split(':').map(Number); return h*60 + (m||0); };
    const minutesOfDay = (d) => d.getHours()*60 + d.getMinutes();
  const fmtNum = (x, digits=2) => (x==null || isNaN(x) ? '' : Number(x).toFixed(digits));
  const fmtMoney = (x) => (x==null || isNaN(x) ? '' : Number(x).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }));
  const fmtInt = (x) => (x==null || isNaN(x) ? '0' : Math.round(Number(x)).toLocaleString());
    const fmtPct = (x) => (x==null || isNaN(x) ? '' : Number(x).toFixed(2));
    const fmtTime = (d) => d instanceof Date && !isNaN(d) ? `${pad2(d.getHours())}:${pad2(d.getMinutes())}` : '';

    // -----------------------------
    // Global state
    // -----------------------------
    let currentTicker = '';
    let ROWS = [];        // current symbol rows
    let DAY_GROUPS = new Map();
    let DAYS = [];
  let VIEW_DIR = 'both';
  let LAST_OUT = null;
  let VIEW_DOW = new Set([1,2,3,4,5]); // 1=Mon ... 5=Fri
  let VIEW_MONTHS = new Set(); // empty => all
  let AVAILABLE_MONTHS = [];

    function setTicker(sym){
      currentTicker = (sym||'').toUpperCase();
      const titleEl = document.getElementById('mainTitle');
      if (titleEl) {
        const prefix = currentTicker ? currentTicker + ' - ' : '';
        const full = prefix + 'ORB Backtest';
        titleEl.textContent = full;
        document.title = full;
      }
    }

    function setStatus(msg){ const el = document.getElementById('status'); if (el) el.textContent = msg || ''; }

    function normalizeAndIndex(rows){
      if (!rows || !rows.length) throw new Error('No rows parsed');
      const required = ['caldt','day','open','high','low','close'];
      const missing = required.filter(c => !(c in rows[0]));
      if (missing.length) throw new Error('Missing columns: ' + missing.join(', '));

      ROWS = rows.map(r => {
        const caldt = new Date(r.caldt);
        const dayKey = dateKeyFromStr(r.day);
        const open = Number(r.open), high = Number(r.high), low = Number(r.low), close = Number(r.close);
        if (!dayKey || isNaN(caldt)) return null;
        if ([open,high,low,close].some(v => !Number.isFinite(v))) return null;
        return { caldt, dayKey, open, high, low, close };
      }).filter(Boolean);

      DAY_GROUPS = new Map();
      for (const row of ROWS) {
        if (!DAY_GROUPS.has(row.dayKey)) DAY_GROUPS.set(row.dayKey, []);
        DAY_GROUPS.get(row.dayKey).push(row);
      }
      for (const [k, arr] of DAY_GROUPS.entries()) arr.sort((a,b)=>a.caldt-b.caldt);
      DAYS = Array.from(DAY_GROUPS.keys()).sort();
    }

    async function loadSymbolData(sym){
      if (!sym) return false;
      setStatus(`Loading data for ${sym}…`);
      try {
        const path = `data/${sym}_1m.csv`;
        const res = await fetch(path, { cache: 'no-cache' });
        if (!res.ok) throw new Error(`HTTP ${res.status} loading ${path}`);
        const text = await res.text();
        const parsed = Papa.parse(text, { header:true, dynamicTyping:true, skipEmptyLines:true });
        if (parsed.errors && parsed.errors.length) {
          console.warn('CSV parse warnings:', parsed.errors.slice(0,3));
        }
        normalizeAndIndex(parsed.data);
        setStatus(`Loaded ${ROWS.length} rows across ${DAYS.length} day(s).`);
        return true;
      } catch (err) {
        console.error(err);
        setStatus(`Error loading ${sym}: ${err.message}`);
        ROWS = []; DAY_GROUPS = new Map(); DAYS = [];
        return false;
      }
    }

    // -----------------------------
    // Backtest (JS port)
    // -----------------------------
    function backtest({ days, dayGroups, orb_m, target_R, stop_R, risk, max_Lev, AUM_0, commission, direction='both', orb_start_time='9:30', orb_end_time='15:30', entry_cutoff_time='12:00', breakout_buffer=0.01 }) {
      const out = [];
      const orbStartMin = parseTimeHHMM(orb_start_time);
      const orbEndMin = parseTimeHHMM(orb_end_time);
      const entryCutoffMin = parseTimeHHMM(entry_cutoff_time);

      for (let t = 0; t < days.length; t++) {
        const dayKey = days[t];
        const prev_AUM = (t>0 && out[t-1]?.AUM != null) ? out[t-1].AUM : AUM_0;
        const rowOut = { Date: dayKey, ORH: NaN, ORL: NaN, Side: '', EntryTime: null, Entry: NaN, ExitTime: null, Exit: NaN, StopPrice: NaN, TPPrice: NaN, HitType: '', Shares: NaN, PnL: NaN, pnl_R: 0, AUM: prev_AUM, DailyReturn: 0 };

        const df_day = dayGroups.get(dayKey);
        if (!df_day || df_day.length === 0) { rowOut.HitType='NotEnoughBars'; rowOut.Shares=0; out.push(rowOut); continue; }

        const startIdx = df_day.findIndex(r => minutesOfDay(r.caldt) >= orbStartMin);
        if (startIdx < 0 || (startIdx + orb_m) > df_day.length) { rowOut.HitType='NotEnoughBars'; rowOut.Shares=0; out.push(rowOut); continue; }

        let ORH = -Infinity, ORL = Infinity;
        for (let k = startIdx; k < startIdx + orb_m; k++) { const r = df_day[k]; if (r.high>ORH) ORH=r.high; if (r.low<ORL) ORL=r.low; }
        rowOut.ORH = ORH; rowOut.ORL = ORL;

        let entryIdx=null, entry_side=0, entry_price=NaN, entry_time=null;
        for (let i = startIdx + orb_m; i < df_day.length; i++) {
          const r = df_day[i];
          if (minutesOfDay(r.caldt) >= entryCutoffMin) break;
          const long_hit = r.high > (ORH + breakout_buffer);
          const short_hit = r.low < (ORL - breakout_buffer);
          if (direction==='long' && !long_hit) continue;
          if (direction==='short' && !short_hit) continue;
          if (direction==='both' && !(long_hit||short_hit)) continue;
          if (long_hit && !short_hit) entry_side = 1; else if (short_hit && !long_hit) entry_side = -1; else if (direction==='long') entry_side = 1; else if (direction==='short') entry_side = -1; else entry_side = 1;
          entry_price = (entry_side===1) ? (ORH + breakout_buffer) : (ORL - breakout_buffer);
          entryIdx = i; entry_time = new Date(r.caldt);
          rowOut.Side = (entry_side===1) ? 'Long' : 'Short'; rowOut.EntryTime = entry_time; rowOut.Entry = entry_price; break;
        }
        if (entryIdx==null) { rowOut.HitType='NoBreak'; rowOut.Shares=0; out.push(rowOut); continue; }

        const R_price = (ORH - ORL)/2.0;
        const stop_price   = (entry_side===1) ? (entry_price - stop_R*R_price) : (entry_price + stop_R*R_price);
        const target_price = (entry_side===1) ? (entry_price + target_R*R_price) : (entry_price - target_R*R_price);
        rowOut.StopPrice = stop_price; rowOut.TPPrice = target_price;

        const stop_frac = (stop_R * R_price) / entry_price;
        const max_risk_sh = stop_frac > 0 ? (prev_AUM * risk) / (entry_price * stop_frac) : 0;
        const max_lev_sh  = (max_Lev * prev_AUM) / entry_price;
        const shares = Math.floor(Math.min(max_risk_sh, max_lev_sh));
        rowOut.Shares = shares;
        if (!(shares>0)) { rowOut.HitType='NoSize'; rowOut.AUM=prev_AUM; out.push(rowOut); continue; }

        let exitIdx=null, hit='EOD', exit_time=null, exit_price=NaN;
        for (let j = entryIdx + 1; j < df_day.length; j++) {
          const r2 = df_day[j];
          const tp_hit = (entry_side===1) ? (r2.high >= target_price) : (r2.low <= target_price);
          const st_hit = (entry_side===1) ? (r2.low  <= stop_price)   : (r2.high >= stop_price);
          if (tp_hit && !st_hit) { exitIdx=j; hit='TP'; break; }
          if (st_hit && !tp_hit) { exitIdx=j; hit='Stop'; break; }
          if (tp_hit && st_hit)  { exitIdx=j; hit='TP'; break; }
        }
        if (exitIdx==null) {
          let eodIdx = -1;
          for (let idx = df_day.length - 1; idx >= 0; idx--) { if (minutesOfDay(df_day[idx].caldt) === orbEndMin) { eodIdx = idx; break; } }
          exitIdx = (eodIdx>=0) ? eodIdx : (df_day.length-1);
          exit_time = new Date(df_day[exitIdx].caldt);
          exit_price = df_day[exitIdx].close;
        } else {
          exit_time = new Date(df_day[exitIdx].caldt);
          const o_exit = df_day[exitIdx].open;
          exit_price = (hit==='TP') ? ((entry_side===1) ? Math.max(target_price, o_exit) : Math.min(target_price, o_exit))
                                    : ((entry_side===1) ? Math.min(stop_price, o_exit)   : Math.max(stop_price, o_exit));
        }
        rowOut.ExitTime = exit_time; rowOut.Exit = exit_price; rowOut.HitType = hit;

        const pnl = (entry_side===1) ? ((exit_price - entry_price) * shares) : ((entry_price - exit_price) * shares);
        const new_AUM = prev_AUM + pnl - (shares * commission * 2);
        rowOut.PnL = pnl; rowOut.AUM = new_AUM; rowOut.pnl_R = (risk*prev_AUM)!==0 ? Number((pnl/(risk*prev_AUM)).toFixed(2)) : 0; rowOut.DailyReturn = (prev_AUM!==0) ? Number(((pnl/prev_AUM)*100).toFixed(2)) : 0;

        out.push(rowOut);
      }
      return out;
    }

    function renderSummary(out){
      const summary = document.getElementById('summary');
      if (!out || !out.length) { summary.innerHTML=''; return; }
      const trades = out.filter(r => r.Shares>0 && !['NotEnoughBars','NoBreak','NoSize'].includes(r.HitType));
      const total = trades.length;
      const tpWins = trades.filter(r => r.HitType==='TP').length;
      const eodAll = trades.filter(r => r.HitType==='EOD');
      const eodWin = eodAll.filter(r => Number(r.PnL) > 0).length;
      const eodLoss = eodAll.filter(r => Number(r.PnL) < 0).length;
      const stops = trades.filter(r => r.HitType==='Stop').length;
      const wins = tpWins + eodWin;
      const losses = stops + eodLoss;

  const lastAUM = out[out.length-1].AUM;
  const totalPnL = out.reduce((s,r)=> s + (Number.isFinite(r.PnL)?r.PnL:0), 0);
  const avgDailyRet = out.reduce((s,r)=> s + (Number.isFinite(r.DailyReturn)?r.DailyReturn:0), 0) / out.length;

      const cards = [
        { label: 'Days Backtested', value: fmtInt(out.length) },
        { label: 'Final AUM', value: `$${fmtMoney(lastAUM)}` },
        { label: 'Total PnL', value: `$${fmtMoney(totalPnL)}`, cls: (totalPnL > 0) ? 'num-pos' : 'num-neg' },
        { label: 'Avg Daily Return', value: `${fmtPct(avgDailyRet)}%` },
      ];

      const gridHtml = `<div class="grid sm:grid-cols-2 lg:grid-cols-2 gap-4 mb-4">${
        cards.map(c=>`<div class=\"rounded-2xl border p-4\"><div class=\"text-xs text-slate-500\">${c.label}</div><div class=\"text-xl font-semibold tabular-nums font-mono text-right ${c.cls||''}\">${c.value}</div></div>`).join('')
      }</div>`;

      const pct = (n) => total>0 ? `${((n/total)*100).toFixed(1)}%` : '0.0%';
  const tableHtml = `
        <div class="rounded-2xl border p-3 overflow-auto">
          <div class="text-xs text-slate-500 mb-2">Trades breakdown</div>
          <table class="min-w-full text-sm">
            <thead class="bg-slate-50">
              <tr>
        <th class="px-3 py-2 text-left">Total</th>
        <th class="px-3 py-2 text-right">Win</th>
        <th class="px-3 py-2 text-right">Loss</th>
        <th class="px-3 py-2 text-right">EOD</th>
        <th class="px-3 py-2 text-right">EOD Win</th>
        <th class="px-3 py-2 text-right">EOD Loss</th>
              </tr>
            </thead>
            <tbody>
              <tr class="border-b">
        <td class="px-3 py-2">${fmtInt(total)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(wins)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(losses)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(eodAll.length)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(eodWin)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(eodLoss)}</td>
              </tr>
              <tr>
        <td class="px-3 py-2 text-slate-600">100.0%</td>
        <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(wins)}</td>
        <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(losses)}</td>
        <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(eodAll.length)}</td>
        <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(eodWin)}</td>
        <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(eodLoss)}</td>
              </tr>
            </tbody>
          </table>
        </div>
      `;

      summary.innerHTML = gridHtml + tableHtml;
    }

    function renderTable(out){
      const tb = document.getElementById('tbody');
      tb.innerHTML='';
  const rows = Array.isArray(out) ? (VIEW_DIR==='both' ? out : out.filter(r => (r.Shares>0) && ((VIEW_DIR==='long' && r.Side==='Long') || (VIEW_DIR==='short' && r.Side==='Short')))) : [];
      const frag = document.createDocumentFragment();
  for (const r of rows) {
        const tr = document.createElement('tr');
        tr.className='border-b hover:bg-slate-50';
        tr.innerHTML = `
          <td class="px-3 py-2">${r.Date}</td>
          <td class="px-3 py-2 text-right">${fmtNum(r.ORH)}</td>
          <td class="px-3 py-2 text-right">${fmtNum(r.ORL)}</td>
          <td class="px-3 py-2">${r.Side||''}</td>
          <td class="px-3 py-2">${fmtTime(r.EntryTime)}</td>
          <td class="px-3 py-2 text-right">${fmtNum(r.Entry)}</td>
          <td class="px-3 py-2">${fmtTime(r.ExitTime)}</td>
          <td class="px-3 py-2 text-right">${fmtNum(r.Exit)}</td>
          <td class="px-3 py-2 text-right">${fmtNum(r.StopPrice)}</td>
          <td class="px-3 py-2 text-right">${fmtNum(r.TPPrice)}</td>
          <td class="px-3 py-2">${r.HitType==='Stop' ? 'Loss' : r.HitType}</td>
          <td class="px-3 py-2 text-right">${Number.isFinite(r.Shares)?r.Shares:''}</td>
          <td class="px-3 py-2 text-right">${fmtNum(r.PnL)}</td>
          <td class="px-3 py-2 text-right">${fmtNum(r.pnl_R)}</td>
          <td class="px-3 py-2 text-right">${fmtNum(r.AUM)}</td>
          <td class="px-3 py-2 text-right">${fmtPct(r.DailyReturn)}</td>`;
        frag.appendChild(tr);
      }
      tb.appendChild(frag);
    }

    function renderEquityChart(out){
      const el = document.getElementById('equityChart');
      if (!el) return;
      if (!out || !out.length) {
        try { Plotly.purge(el); } catch {}
        el.innerHTML = '<div class="text-sm text-slate-500">No data</div>';
        return;
      }
      const x = out.map(r => r.Date);
      const y = out.map(r => (Number.isFinite(r.AUM) ? r.AUM : null));
      const trace = {
        x, y, type: 'scatter', mode: 'lines',
        line: { color: '#10b981', width: 2 },
        hovertemplate: '%{x}<br>AUM: %{y:$,.2f}<extra></extra>'
      };
      const layout = {
        margin: { l: 56, r: 16, t: 8, b: 40 },
        xaxis: { title: 'Date', type: 'date' },
        yaxis: { title: 'AUM', tickformat: '~s' },
        showlegend: false,
        paper_bgcolor: 'white',
        plot_bgcolor: 'white'
      };
      try {
        Plotly.newPlot(el, [trace], layout, { displayModeBar: false, responsive: true });
      } catch {}
    }

    function computeWinLossStreaks(out){
      const trades = (out||[]).filter(r => r.Shares>0 && !['NotEnoughBars','NoBreak','NoSize'].includes(r.HitType));
      const winsX=[], winsY=[], lossX=[], lossY=[];
      let curType=null; let curLen=0;
      for (let i=0; i<trades.length; i++){
        const r = trades[i];
        const isWin = Number(r.PnL) > 0;
        const isLoss = Number(r.PnL) < 0;
        const type = isWin ? 'win' : (isLoss ? 'loss' : null);
        if (!type){
          if (curType && curLen>0){ const endDate = trades[i-1].Date; if (curType==='win'){ winsX.push(endDate); winsY.push(curLen); } else { lossX.push(endDate); lossY.push(curLen); } }
          curType=null; curLen=0; continue;
        }
        if (curType===null){ curType=type; curLen=1; continue; }
        if (type===curType){ curLen++; }
        else { const endDate = trades[i-1].Date; if (curType==='win'){ winsX.push(endDate); winsY.push(curLen); } else { lossX.push(endDate); lossY.push(curLen); } curType=type; curLen=1; }
      }
      if (curType && curLen>0 && trades.length>0){ const endDate = trades[trades.length-1].Date; if (curType==='win'){ winsX.push(endDate); winsY.push(curLen); } else { lossX.push(endDate); lossY.push(curLen); } }
      return { winsX, winsY, lossX, lossY };
    }

    function renderStreakChart(out){
      const el = document.getElementById('streakChart');
      if (!el) return;
      const { winsX, winsY, lossX, lossY } = computeWinLossStreaks(out);
  if ((winsX.length + lossX.length) === 0){ try { Plotly.purge(el); } catch {}; el.innerHTML = '<div class="text-sm text-slate-500">No data</div>'; return; }
  const traces = [];
  const lossYNeg = lossY.map(v => -Math.abs(v));
  if (winsX.length) traces.push({ x:winsX, y:winsY, type:'bar', name:'Win streak', marker:{ color:'#10b981' }, hoverinfo:'skip' });
  if (lossX.length) traces.push({ x:lossX, y:lossYNeg, type:'bar', name:'Loss streak', marker:{ color:'#ef4444' }, hoverinfo:'skip' });
  const layout = { barmode:'group', margin:{ l:56, r:16, t:8, b:40 }, xaxis:{ title:'Date', type:'date' }, yaxis:{ title:'Consecutive count', zeroline:true }, paper_bgcolor:'white', plot_bgcolor:'white', showlegend:false, hovermode:false };
  try { Plotly.newPlot(el, traces, layout, { displayModeBar:false, responsive:true }); } catch {}
    }

    // -----------------------------
    // Param handling + run
    // -----------------------------
    const riskConst = 0.02, maxLevConst = 4, AUM0Const = 100000, commissionConst = 0, directionConst = 'both', breakoutBufferConst = 0.01, orbStartConst = '9:30', orbEndConst = '15:30', entryCutoffConst = '12:00';

    function computeFilteredDays() {
      if (!Array.isArray(DAYS) || DAYS.length===0) return [];
      // DAYS are keys like YYYY-MM-DD, map to weekday via first row in group
      const out = [];
      for (const dayKey of DAYS) {
        const arr = DAY_GROUPS.get(dayKey);
        if (!arr || !arr.length) continue;
        const dow = arr[0].caldt.getDay(); // 0=Sun..6=Sat
        const mapDow = dow===0 ? 7 : dow; // 1..7 with 7=Sun
  const monthKey = `${dayKey.slice(5,7)}/${dayKey.slice(0,4)}`; // MM/YYYY
  const dowOk = VIEW_DOW.has(mapDow) || (mapDow===7 && VIEW_DOW.has(7));
  const monOk = (VIEW_MONTHS.size===0) || VIEW_MONTHS.has(monthKey);
  if (dowOk && monOk) out.push(dayKey);
      }
      return out;
    }

    function getBacktestParams(){
      const orb = document.getElementById('inp_orb_m');
      const trg = document.getElementById('inp_target_R');
      const stp = document.getElementById('inp_stop_R');
      const tStart = document.getElementById('inp_orb_start');
      const tEnd = document.getElementById('inp_orb_end');
      const tCut = document.getElementById('inp_entry_cutoff');
      const filteredDays = computeFilteredDays();
      return {
        symbol: currentTicker,
        days: filteredDays,
        dayGroups: DAY_GROUPS,
        orb_m: orb ? parseInt(orb.value,10) : 25,
        target_R: trg ? parseFloat(trg.value) : 2,
        stop_R: stp ? parseFloat(stp.value) : 2,
        risk: riskConst,
        max_Lev: maxLevConst,
        AUM_0: AUM0Const,
        commission: commissionConst,
  direction: VIEW_DIR || directionConst,
        orb_start_time: (tStart && tStart.value) ? tStart.value : orbStartConst,
        orb_end_time: (tEnd && tEnd.value) ? tEnd.value : orbEndConst,
        entry_cutoff_time: (tCut && tCut.value) ? tCut.value : entryCutoffConst,
        breakout_buffer: breakoutBufferConst,
      };
    }

    let runTimer = null;
    function scheduleRun(){
      if (runTimer) clearTimeout(runTimer);
      runTimer = setTimeout(runBacktestIfReady, 150);
    }

    function runBacktestIfReady(){
      if (!currentTicker) { setStatus('Pick a symbol.'); return; }
  if (!DAYS.length) { setStatus('No data loaded.'); return; }
      const params = getBacktestParams();
      const t0 = performance.now();
      const out = backtest(params);
      const t1 = performance.now();
      setStatus(`Ran ${out.length} day(s) in ${(t1-t0).toFixed(0)} ms.`);
      renderSummary(out);
  LAST_OUT = out;
  renderTable(LAST_OUT);
  renderEquityChart(LAST_OUT);
  renderStreakChart(LAST_OUT);
    }

    async function loadAndRunForCurrent(){
      if (!currentTicker) return;
      const ok = await loadSymbolData(currentTicker);
  if (ok) { buildMonthOptions(); runBacktestIfReady(); }
    }

    // -----------------------------
    // Symbol segment (existing code with auto-run hook)
    // -----------------------------
    async function populateTickerSegment(){
      const container = document.getElementById('tickerSegment');
      if (!container) return;
      container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';
      const render = (symbols)=>{
        container.innerHTML = '';
        symbols.forEach((s,i)=>{
          const btn = document.createElement('button');
          btn.type = 'button';
          const cls = 'px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100' + (i < symbols.length - 1 ? ' border-r border-slate-200' : '');
          btn.className = cls; btn.setAttribute('data-symbol', s); btn.textContent = s; container.appendChild(btn);
        });
      };
      try {
        const res = await fetch('data/index.json', { cache: 'no-cache' });
        if (res.ok) {
          const list = await res.json();
          if (Array.isArray(list) && list.length) { render(list.map(s=>String(s).toUpperCase())); return; }
        }
      } catch {}
      try {
        const res = await fetch('data/', { cache: 'no-cache' });
        if (res.ok) {
          const text = await res.text();
          const ct = (res.headers.get('content-type')||'').toLowerCase();
          let files = [];
          if (ct.includes('text/html')) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            files = Array.from(doc.querySelectorAll('a')).map(a=>a.getAttribute('href')).filter(Boolean);
          } else { files = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean); }
          const regex = /^([A-Za-z0-9-]+)_1m\.csv$/i;
          const syms = [];
          for (const f of files) { const name = (f||'').split('/').pop(); const m = name.match(regex); if (m) syms.push(m[1].toUpperCase()); }
          const uniq = Array.from(new Set(syms)); if (uniq.length) { render(uniq); return; }
        }
      } catch {}
      render(['TQQQ','TSLA','PLTR','UVXY']);
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#tickerSegment button[data-symbol]');
      if (!btn) return;
      const seg = document.getElementById('tickerSegment'); if (!seg) return;
      seg.querySelectorAll('button').forEach(b => { b.classList.remove('bg-slate-800','text-white','focus:outline-none'); if (!b.classList.contains('bg-white')) b.classList.add('bg-white'); if (!b.classList.contains('hover:bg-slate-100')) b.classList.add('hover:bg-slate-100'); });
      btn.classList.add('bg-slate-800','text-white','focus:outline-none'); btn.classList.remove('bg-white','hover:bg-slate-100');
      setTicker(btn.getAttribute('data-symbol'));
  loadAndRunForCurrent();
    });

    // Direction filter segment handlers
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#dirSegment button[data-dir]');
      if (!btn) return;
      const seg = document.getElementById('dirSegment'); if (!seg) return;
      seg.querySelectorAll('button').forEach(b => { b.classList.remove('bg-slate-800','text-white','focus:outline-none'); if (!b.classList.contains('bg-white')) b.classList.add('bg-white'); if (!b.classList.contains('hover:bg-slate-100')) b.classList.add('hover:bg-slate-100'); });
      btn.classList.add('bg-slate-800','text-white','focus:outline-none'); btn.classList.remove('bg-white','hover:bg-slate-100');
      VIEW_DIR = (btn.getAttribute('data-dir') || 'both');
      // Re-run so summary and trades reflect the selected direction
      scheduleRun();
    });

    function syncDowUI() {
      const seg = document.getElementById('dowSegment'); if (!seg) return;
      seg.querySelectorAll('button[data-dow]').forEach(b => {
        const n = Number(b.getAttribute('data-dow'));
        const active = VIEW_DOW.has(n);
        b.classList.toggle('bg-slate-800', active);
        b.classList.toggle('text-white', active);
        b.classList.toggle('bg-white', !active);
        b.classList.toggle('hover:bg-slate-100', !active);
      });
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#dowSegment button[data-dow]');
      if (!btn) return;
      const n = Number(btn.getAttribute('data-dow'));
      if (VIEW_DOW.has(n)) VIEW_DOW.delete(n); else VIEW_DOW.add(n);
      // Allow empty selection so user can see zero-trade results
      syncDowUI();
      scheduleRun();
    });

    // -----------------------------
    // Month multi-select helpers
    // -----------------------------
    function monthChoicesFromDays() {
      const set = new Set();
      for (const dayKey of DAYS) {
        const mk = `${dayKey.slice(5,7)}/${dayKey.slice(0,4)}`;
        set.add(mk);
      }
      // Sort descending by year-month
      return Array.from(set).sort((a,b)=>{
        const [am,ay] = a.split('/').map(Number);
        const [bm,by] = b.split('/').map(Number);
        if (ay!==by) return by-ay; // year desc
        return bm-am; // month desc
      });
    }

    function buildMonthOptions() {
      AVAILABLE_MONTHS = monthChoicesFromDays();
      const list = document.getElementById('sumMonthMultiList');
      if (!list) return;
      list.innerHTML = AVAILABLE_MONTHS.map(m => `
        <label class="flex items-center gap-2 px-2 py-1 rounded hover:bg-slate-50 cursor-pointer">
          <input type="checkbox" class="h-4 w-4 rounded border-slate-300" data-month="${m}" ${VIEW_MONTHS.has(m)?'checked':''} />
          <span class="text-sm text-slate-800">${m}</span>
        </label>
      `).join('');
      updateMonthLabel();
    }

    function updateMonthLabel(){
      const lbl = document.getElementById('sumMonthMultiLabel'); if (!lbl) return;
      if (VIEW_MONTHS.size===0 || VIEW_MONTHS.size===AVAILABLE_MONTHS.length) { lbl.textContent = 'All months'; return; }
      if (VIEW_MONTHS.size<=2) { lbl.textContent = Array.from(VIEW_MONTHS).sort().join(', '); return; }
      lbl.textContent = `${VIEW_MONTHS.size} selected`;
    }

    // Toggle dropdown open/close
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#sumMonthMultiBtn');
      const menu = document.getElementById('sumMonthMultiMenu');
      if (btn && menu) { menu.classList.toggle('hidden'); return; }
      // Close when clicking outside
      if (menu && !menu.contains(e.target) && !e.target.closest('#sumMonthMultiBtn')) {
        menu.classList.add('hidden');
      }
    });

    // Select all / Clear
    document.addEventListener('click', (e) => {
      const selAll = e.target.closest('#sumMonthSelectAll');
      const clrAll = e.target.closest('#sumMonthClearAll');
      if (!selAll && !clrAll) return;
      if (selAll) VIEW_MONTHS = new Set(AVAILABLE_MONTHS);
      if (clrAll) VIEW_MONTHS = new Set();
      // sync checkboxes
      document.querySelectorAll('#sumMonthMultiList input[type="checkbox"]').forEach(cb => { const m = cb.getAttribute('data-month'); cb.checked = VIEW_MONTHS.has(m); });
      updateMonthLabel();
      scheduleRun();
    });

    // Checkbox toggles
    document.addEventListener('change', (e) => {
      const cb = e.target.closest('#sumMonthMultiList input[type="checkbox"]');
      if (!cb) return;
      const m = cb.getAttribute('data-month');
      if (cb.checked) VIEW_MONTHS.add(m); else VIEW_MONTHS.delete(m);
      updateMonthLabel();
      scheduleRun();
    });

    // Param input clamping + auto-run
    (function(){
      const orb = document.getElementById('inp_orb_m');
      const trg = document.getElementById('inp_target_R');
      const stp = document.getElementById('inp_stop_R');
  const tStart = document.getElementById('inp_orb_start');
  const tEnd = document.getElementById('inp_orb_end');
  const tCut = document.getElementById('inp_entry_cutoff');
      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
      if (orb) ['input','change'].forEach(evt=> orb.addEventListener(evt, ()=> { const v = parseInt(orb.value,10); orb.value = String(clamp(Number.isFinite(v)?v:25, 1, 120)); scheduleRun(); }));
      if (trg) ['input','change'].forEach(evt=> trg.addEventListener(evt, ()=> { const v = parseFloat(trg.value); trg.value = String(clamp(Number.isFinite(v)?v:2, 0, 100)); scheduleRun(); }));
      if (stp) ['input','change'].forEach(evt=> stp.addEventListener(evt, ()=> { const v = parseFloat(stp.value); stp.value = String(clamp(Number.isFinite(v)?v:2, 0, 100)); scheduleRun(); }));
  if (tStart) ['input','change'].forEach(evt=> tStart.addEventListener(evt, scheduleRun));
  if (tEnd) ['input','change'].forEach(evt=> tEnd.addEventListener(evt, scheduleRun));
  if (tCut) ['input','change'].forEach(evt=> tCut.addEventListener(evt, scheduleRun));
    })();

    // init
    populateTickerSegment().catch(()=>{});
  </script>
</body>
</html>
