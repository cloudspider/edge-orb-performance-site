<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ORB Backtest</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.tailframes.com/releases/latest/tailframes.min.js" defer></script>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"
  />
  <!-- Apache ECharts for interactive charts (mobile pinch-zoom supported) -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
  .num-pos { color: #119d6e !important; }
  .num-neg { color: #ff0000 !important; }
  .pnl-strong { font-size: 1.8rem !important; }
    .sticky-th { position: sticky; top: 0; background: white; z-index: 1; }
    .shadow-soft { box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
    thead th { position: sticky; top: 0; background: white; z-index: 1; }
    /* Hide native spin buttons for our numeric inputs (Safari/Chrome/Firefox) */
    #inp_orb_m::-webkit-outer-spin-button,
    #inp_orb_m::-webkit-inner-spin-button,
    #inp_target_R::-webkit-outer-spin-button,
    #inp_target_R::-webkit-inner-spin-button,
    #inp_stop_R::-webkit-outer-spin-button,
    #inp_stop_R::-webkit-inner-spin-button,
    #inp_risk_pct::-webkit-outer-spin-button,
    #inp_risk_pct::-webkit-inner-spin-button,
    #inp_aum0::-webkit-outer-spin-button,
    #inp_aum0::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    #inp_orb_m,
    #inp_target_R,
    #inp_stop_R,
    #inp_risk_pct,
    #inp_aum0 {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Generic: hide spinners for any number input (fallback and future fields) */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Allow ticker chips to wrap within their container */
    #tickerSegment {
      display: flex;
      flex-wrap: wrap;
      max-width: 100%;
      min-width: 0;
      white-space: normal;
    }
    #tickerSegment button {
      flex: 0 0 auto;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <!-- Site navigation -->
  <nav class="bg-white border-b border-slate-200 sticky top-0 z-50 shadow-sm">
  <div class="max-w-screen-2xl mx-auto px-6 py-3 flex items-center gap-3">
      <div class="flex items-center gap-2 font-semibold text-slate-800">
        <svg class="h-5 w-5 text-emerald-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" fill="currentColor" aria-hidden="true"><path d="M192 384L88.5 384C63.6 384 48.3 356.9 61.1 335.5L114 247.3C122.7 232.8 138.3 224 155.2 224L250.2 224C326.3 95.1 439.8 88.6 515.7 99.7C528.5 101.6 538.5 111.6 540.3 124.3C551.4 200.2 544.9 313.7 416 389.8L416 484.8C416 501.7 407.2 517.3 392.7 526L304.5 578.9C283.2 591.7 256 576.3 256 551.5L256 448C256 412.7 227.3 384 192 384L191.9 384zM464 224C464 197.5 442.5 176 416 176C389.5 176 368 197.5 368 224C368 250.5 389.5 272 416 272C442.5 272 464 250.5 464 224z"/></svg>
        <span>ORB</span>
      </div>
      <div class="flex items-center gap-2">
        <a data-nav href="index.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Performance</a>
        <a data-nav href="backtest.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Backtest</a>
        <a data-nav href="results.html" class="px-3 py-1.5 rounded-lg text-sm text-slate-700 hover:bg-slate-100">Results</a>
      </div>
    </div>
  </nav>
  <script>
    // Activate nav item for current page
    (function(){
      try {
        const file = (location.pathname.split('/').pop() || 'backtest.html').toLowerCase();
        document.querySelectorAll('a[data-nav]').forEach(a => {
          const href = (a.getAttribute('href') || '').toLowerCase();
          const active = href === file || (file === '' && href.endsWith('index.html'));
          a.classList.toggle('bg-slate-800', active);
          a.classList.toggle('text-white', active);
          a.classList.toggle('hover:bg-slate-100', !active);
          if (active) a.setAttribute('aria-current','page'); else a.removeAttribute('aria-current');
        });
      } catch {}
    })();
  </script>

  <div class="max-w-screen-2xl mx-auto p-6 space-y-6">
    <header class="mb-2">
      <h1 id="mainTitle" class="text-2xl md:text-3xl font-semibold">ORB Backtest</h1>
      <p class="text-slate-600 mt-1">Pick a symbol and tweak settings.</p>
      <nav class="flex border-b border-slate-200 gap-1" role="tablist">
        <button type="button" class="inline-flex items-center gap-2 border-b-2 border-transparent px-3 py-2 text-sm font-medium text-slate-500 transition hover:text-slate-700" data-mode-tab="backtest">
          <span class="inline-flex h-5 w-5 items-center justify-center text-slate-400">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M6 2a1 1 0 00-1 1v1.382a1 1 0 01-.553.894 4 4 0 000 7.448A1 1 0 015 13.618V15a1 1 0 001 1h2.382a1 1 0 01.894.553 4 4 0 007.448 0A1 1 0 0117 16.382V15a1 1 0 00-1-1h-1.382a1 1 0 01-.894-.553 4 4 0 00-7.448 0A1 1 0 015.382 14H6v-1.382a1 1 0 01.553-.894 4 4 0 000-7.448A1 1 0 016 4.382V3a1 1 0 00-1-1h1z"/></svg>
          </span>
          <span>Single Backtest</span>
        </button>
        <button type="button" class="inline-flex items-center gap-2 border-b-2 border-transparent px-3 py-2 text-sm font-medium text-slate-500 transition hover:text-slate-700" data-mode-tab="auto">
          <span class="inline-flex h-5 w-5 items-center justify-center text-slate-400">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M10.5 2.75a.75.75 0 00-1.5 0V4.6a5.5 5.5 0 00-3.376 9.888l-.955 1.653a.75.75 0 001.302.75l.955-1.653a5.483 5.483 0 002.324.735V17.25a.75.75 0 001.5 0V15.4A5.5 5.5 0 0014.876 5.5l.955-1.653a.75.75 0 00-1.302-.75L13.574 4.6A5.483 5.483 0 0010.5 4.6V2.75z"/></svg>
          </span>
          <span>Auto Backtest</span>
        </button>
        <button type="button" class="inline-flex items-center gap-2 border-b-2 border-transparent px-3 py-2 text-sm font-medium text-slate-500 transition hover:text-slate-700" data-mode-tab="portfolio">
          <span class="inline-flex h-5 w-5 items-center justify-center text-slate-400">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M4 5a2 2 0 00-2 2v2a1 1 0 001 1h.382l.894 5.366A2 2 0 006.254 17h7.492a2 2 0 001.978-1.634L16.618 10H17a1 1 0 001-1V7a2 2 0 00-2-2h-2.5a2.5 2.5 0 00-5 0H4zm4.5-2a1.5 1.5 0 013 0h-3z"/></svg>
          </span>
          <span>Portfolio</span>
        </button>
      </nav>
    </header>

    <!-- Symbol segmented control + Params -->
    <section id="symbolPicker" class="bg-white rounded-2xl shadow-soft p-3 md:p-4">
      <div class="mb-3 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
        <h2 class="font-semibold">ORB Settings</h2>
        <div class="flex flex-wrap items-center gap-2 sm:justify-end">
          <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600" id="btnAddFavorite" aria-pressed="false">
            <i class="fa fa-regular fa-heart"></i>
            <span>Favorite</span>
          </button>
          <div class="relative">
            <select id="favoriteSelect" class="appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-8 py-2 text-sm text-slate-600 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60 min-w-[200px]" disabled>
              <option value="">Load Favorite…</option>
            </select>
            <span class="pointer-events-none absolute inset-y-0 right-3 flex items-center text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.06l3.71-3.83a.75.75 0 111.06 1.06l-4.24 4.39a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
            </span>
          </div>
          <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600" id="btnAddPortfolio">
            <i class="fa fa-regular fa-bookmark"></i>
            <span data-portfolio-add-label>Add to Portfolio</span>
          </button>
        </div>
      </div>
      <div class="flex items-start gap-4 flex-col md:flex-row">
        <div class="flex-1 min-w-0">
          <div class="flex items-center gap-2 mb-2">
            <div class="flex-1 min-w-0 overflow-x-auto">
              <div id="tickerSegment" class="inline-flex min-w-max rounded-xl border border-slate-200 overflow-hidden whitespace-nowrap">
                <span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>
              </div>
            </div>
          </div>
          <div id="status" class="text-xs text-slate-500"></div>
        </div>
        <div class="w-full md:w-[860px] grid grid-cols-3 md:grid-cols-6 gap-3">
          <label class="block">
            <span class="text-sm text-slate-600">orb_m</span>
            <div class="mt-1 relative">
              <input id="inp_orb_m" data-default="25" type="number" min="1" max="120" step="1" value="25" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase orb_m" data-num-target="inp_orb_m" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease orb_m" data-num-target="inp_orb_m" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">target_R</span>
            <div class="mt-1 relative">
              <input id="inp_target_R" data-default="2" type="number" min="0" max="100" step="0.1" value="2" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase target_R" data-num-target="inp_target_R" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease target_R" data-num-target="inp_target_R" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">stop_R</span>
            <div class="mt-1 relative">
              <input id="inp_stop_R" data-default="2" type="number" min="0" max="100" step="0.1" value="2" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase stop_R" data-num-target="inp_stop_R" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease stop_R" data-num-target="inp_stop_R" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">ORB Start</span>
            <div class="mt-1 relative">
              <input id="inp_orb_start" type="time" step="60" value="09:30" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase start time" data-time-target="inp_orb_start" data-time-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease start time" data-time-target="inp_orb_start" data-time-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">ORB End</span>
            <div class="mt-1 relative">
              <input id="inp_orb_end" type="time" step="60" value="15:30" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase end time" data-time-target="inp_orb_end" data-time-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease end time" data-time-target="inp_orb_end" data-time-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block">
            <span class="text-sm text-slate-600">Entry Cutoff</span>
            <div class="mt-1 relative">
              <input id="inp_entry_cutoff" type="time" step="60" value="12:00" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase entry cutoff" data-time-target="inp_entry_cutoff" data-time-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease entry cutoff" data-time-target="inp_entry_cutoff" data-time-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>

          <!-- AUM + At Risk % row under existing fields -->
          <label class="block col-span-3 md:col-span-3">
            <span class="text-sm text-slate-600">AUM</span>
            <div class="mt-1 relative">
              <input id="inp_aum0" data-default="100000" type="number" min="0" max="1000000000" step="1000" value="100000" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase AUM" data-num-target="inp_aum0" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease AUM" data-num-target="inp_aum0" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
          <label class="block col-span-3 md:col-span-3">
            <span class="text-sm text-slate-600">At Risk % (Per Trade)</span>
            <div class="mt-1 relative">
              <input id="inp_risk_pct" data-default="2" type="number" min="0" max="100" step="0.5" value="2" class="w-full appearance-none bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl pl-3 pr-10 py-2 text-sm" />
              <div class="absolute inset-y-0 right-1 flex flex-col justify-center py-1">
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Increase risk %" data-num-target="inp_risk_pct" data-num-step="1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 12.79a.75.75 0 001.06-.02L10 9.06l3.71 3.71a.75.75 0 001.06-1.06l-4.24-4.24a.75.75 0 00-1.06 0l-4.24 4.24a.75.75 0 00.02 1.08z" clip-rule="evenodd"/></svg>
                </button>
                <button type="button" class="h-4 w-6 text-slate-500 hover:text-slate-700" aria-label="Decrease risk %" data-num-target="inp_risk_pct" data-num-step="-1">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.77 7.21a.75.75 0 00-1.06.02L10 10.94 6.29 7.23a.75.75 0 10-1.06 1.06l4.24 4.24a.75.75 0 001.06 0l-4.24-4.24a.75.75 0 00-.02-1.08z" clip-rule="evenodd"/></svg>
                </button>
              </div>
            </div>
          </label>
        </div>
      </div>
    </section>

    <section id="autoBacktestSection" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 hidden space-y-4" data-tab-panel="auto">
      <div>
        <h2 class="font-semibold">Auto Backtest</h2>
      </div>
      <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
        <div class="flex items-center gap-2">
          <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-indigo-500 hover:text-indigo-600 opacity-50 pointer-events-none" id="btnAutoBacktest" disabled data-state="idle">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" data-auto-icon="play"><path d="M4.5 3.75a.75.75 0 011.125-.65l9 5.25a.75.75 0 010 1.3l-9 5.25A.75.75 0 014 14.25V5.75a.75.75 0 01.5-.7z"/></svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 hidden" viewBox="0 0 20 20" fill="currentColor" data-auto-icon="pause"><path d="M6.75 4.5a.75.75 0 00-.75.75v9.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75v-9.5a.75.75 0 00-.75-.75h-1.5zm5 0a.75.75 0 00-.75.75v9.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75v-9.5a.75.75 0 00-.75-.75h-1.5z"/></svg>
            <span data-auto-label>Start Backtest</span>
          </button>
          <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-rose-200 bg-white px-3 py-2 text-sm font-medium text-rose-600 shadow-sm transition hover:border-rose-400 hover:text-rose-700 opacity-50 pointer-events-none" id="btnClearAuto" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M6.28 5.22a.75.75 0 10-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 101.06 1.06L10 11.06l3.72 3.72a.75.75 0 101.06-1.06L11.06 10l3.72-3.72a.75.75 0 10-1.06-1.06L10 8.94 6.28 5.22z"/></svg>
            <span>Clear Auto Data</span>
          </button>
        </div>
        <div class="text-sm text-slate-500" id="autoResultsStatus">No auto backtest results yet.</div>
      </div>
      <div class="overflow-x-auto border border-slate-200 rounded-xl max-h-96">
        <table class="min-w-full text-sm">
          <thead class="bg-slate-50 text-slate-600">
            <tr>
              <th class="px-3 py-2 text-left font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="strategyId">
                  <span>Strategy</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="sortino">
                  <span>Sortino</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="ulcerPerf">
                  <span>UPI</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="mar">
                  <span>MAR</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="totalPnL">
                  <span>Total PnL</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="winPct">
                  <span>Win %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="avgDaily">
                  <span>Avg Daily %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="cagr">
                  <span>CAGR %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="maxDD">
                  <span>Max DD %</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="orb_m">
                  <span>ORB (m)</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="tp_R">
                  <span>TP R</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-right font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="sl_R">
                  <span>SL R</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="start">
                  <span>Start</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="end">
                  <span>End</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
              <th class="px-3 py-2 text-left font-medium">
                <button type="button" class="inline-flex items-center gap-1 text-slate-600 hover:text-slate-800" data-auto-sort="direction">
                  <span>Direction</span>
                  <span class="text-xs text-slate-400" data-sort-indicator style="opacity:0">▲</span>
                </button>
              </th>
            </tr>
          </thead>
          <tbody id="autoResultsTableBody">
            <tr class="border-b last:border-b-0">
              <td colspan="15" class="px-3 py-4 text-center text-sm text-slate-500">No auto backtest results yet.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <section id="portfolioPanel" class="bg-white rounded-2xl shadow-soft p-3 md:p-4 hidden" data-tab-panel="portfolio">
      <div id="portfolioSection" class="space-y-4">
        <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
          <div>
            <h2 class="font-semibold">Portfolio</h2>
            <p class="text-sm text-slate-500">Saved backtests are stored locally in IndexedDB.</p>
          </div>
          <div class="flex flex-wrap items-center gap-2 justify-end">
            <button id="btnCreatePortfolio" type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600">
              <i class="fa fa-regular fa-square-plus"></i>
              <span>New Portfolio</span>
            </button>
            <div class="relative min-w-[200px]">
              <select id="portfolioSelect" class="appearance-none rounded-xl border border-slate-200 bg-white pl-3 pr-8 py-2 text-sm text-slate-600 shadow-sm transition focus:outline-none focus:ring-2 focus:ring-emerald-500/60 min-w-[200px] opacity-50 pointer-events-none" disabled>
                <option value="">Load Portfolio…</option>
              </select>
              <span class="pointer-events-none absolute inset-y-0 right-3 inline-flex items-center text-slate-400">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
              </span>
            </div>
            <button id="btnRunPortfolio" type="button" class="inline-flex items-center gap-2 rounded-xl border border-emerald-500/40 bg-emerald-50 px-3 py-2 text-sm font-medium text-emerald-700 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600">
              <i class="fa fa-regular fa-circle-play"></i>
              <span>Run Portfolio</span>
            </button>
            <button id="btnClearPortfolio" type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-medium text-slate-600 shadow-sm transition hover:border-rose-500 hover:text-rose-600">
              <span>Clear All</span>
            </button>
          </div>
        </div>
        <div class="overflow-x-auto">
          <table class="min-w-full text-sm">
            <thead class="bg-slate-50 text-slate-600">
              <tr>
                <th class="px-3 py-2 text-left font-medium">Strategy</th>
                <th class="px-3 py-2 text-right font-medium">Days</th>
                <th class="px-3 py-2 text-right font-medium">Trades</th>
                <th class="px-3 py-2 text-right font-medium">Win %</th>
                <th class="px-3 py-2 text-right font-medium">Total PnL</th>
                <th class="px-3 py-2 text-right font-medium">Avg Daily %</th>
                <th class="px-3 py-2 text-right font-medium">CAGR %</th>
                <th class="px-3 py-2 text-right font-medium">Max DD %</th>
                <th class="px-3 py-2 text-right font-medium">MAR</th>
                <th class="px-3 py-2 text-right font-medium">Actions</th>
              </tr>
            </thead>
            <tbody id="portfolioTableBody">
              <tr>
                <td colspan="10" class="px-3 py-4 text-center text-sm text-slate-500">No saved strategies yet.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- Filters -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6" data-shared-section="filters">
      <h2 class="font-semibold mb-3">Filters</h2>
      <div class="flex flex-wrap items-center gap-3">
        <div id="dirSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden" aria-label="Direction">
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white" data-dir="both">Both</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-l border-slate-200" data-dir="long">Long</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100 border-l border-slate-200" data-dir="short">Short</button>
        </div>

        <div id="dowSegment" class="inline-flex rounded-xl border border-slate-200 overflow-hidden" aria-label="Weekdays">
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white" data-dow="1">Mon</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="2">Tue</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="3">Wed</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="4">Thu</button>
          <button type="button" class="px-3 py-1.5 text-sm font-medium bg-slate-800 text-white border-l border-slate-200" data-dow="5">Fri</button>
        </div>

        <div class="relative inline-block" aria-label="Months">
          <button id="sumMonthMultiBtn" type="button" class="inline-flex items-center justify-between gap-2 bg-white text-slate-800 ring-1 ring-slate-300 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 shadow-sm rounded-xl px-3 py-2 text-sm min-w-[160px]">
            <span id="sumMonthMultiLabel" class="truncate">All months</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
          </button>
          <div id="sumMonthMultiMenu" class="absolute z-30 mt-1 w-64 bg-white border border-slate-200 rounded-xl shadow-soft p-2 hidden">
            <div class="sticky top-0 bg-white z-10 px-2 pb-2 border-b border-slate-200 flex items-center justify-between gap-2">
              <button id="sumMonthSelectAll" type="button" class="text-xs font-medium text-emerald-700 hover:text-emerald-900 hover:underline">Select all</button>
              <button id="sumMonthClearAll" type="button" class="text-xs text-slate-600 hover:text-slate-800 hover:underline">Clear</button>
            </div>
            <div id="sumMonthMultiList" class="max-h-64 overflow-auto"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Summary -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <h2 class="font-semibold mb-3" id="summaryTitle">Summary</h2>
      <div id="summary" class="grid sm:grid-cols-2 lg:grid-cols-2 gap-4"></div>
    </section>
    
    <!-- Equity Chart -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <h2 class="font-semibold mb-3" id="equityTitle">Equity Curve</h2>
      <div id="equityChart" class="w-full h-[360px]"></div>
    </section>

    <!-- Drawdown Chart -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-semibold" id="drawdownTitle">Drawdown</h2>
        <div class="inline-flex items-center gap-0.5 rounded-xl bg-slate-100 p-0.5" aria-label="Drawdown mode">
          <button id="ddBtnPct" type="button" class="px-2 py-1 text-xs rounded-lg">%</button>
          <button id="ddBtnUsd" type="button" class="px-2 py-1 text-xs rounded-lg">$</button>
        </div>
      </div>
      <div id="drawdownChart" class="w-full h-[320px]"></div>
    </section>

    <!-- Win/Loss Streaks Chart -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <h2 class="font-semibold mb-3" id="streakTitle">Win/Loss Streaks</h2>
      <div id="streakChart" class="w-full h-[280px]"></div>
    </section>

    <!-- Monthly Performance -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-semibold" id="monthlyTitle">Monthly Performance</h2>
        <div class="inline-flex items-center gap-0.5 rounded-xl bg-slate-100 p-0.5" aria-label="Monthly performance mode">
          <button id="mpBtnPct" type="button" class="px-2 py-1 text-xs rounded-lg">%</button>
          <button id="mpBtnUsd" type="button" class="px-2 py-1 text-xs rounded-lg">$</button>
        </div>
      </div>
      <div id="monthlyPerf"></div>
    </section>

    <!-- Trades Table -->
    <section class="bg-white rounded-2xl shadow-soft p-4 md:p-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-semibold">Trades</h2>
        <button id="btnExportCSV" type="button" class="px-3 py-1.5 text-sm rounded-lg bg-white ring-1 ring-slate-300 hover:bg-slate-100">Export CSV</button>
      </div>
      <div class="overflow-auto max-h-[65vh] border rounded-xl">
        <table class="min-w-full text-sm">
          <thead>
              <tr class="border-b">
              <th class="px-3 py-2 text-left">Date</th>
              <th class="px-3 py-2 text-right">ORH</th>
              <th class="px-3 py-2 text-right">ORL</th>
              <th class="px-3 py-2 text-right">OR</th>
              <th class="px-3 py-2 text-right">OR%</th>
              <th class="px-3 py-2">Side</th>
              <th class="px-3 py-2">EntryTime</th>
              <th class="px-3 py-2">ExitTime</th>
              <th class="px-3 py-2 text-right">Entry</th>
              <th class="px-3 py-2 text-right">Exit</th>
              <th class="px-3 py-2 text-right">LossPrice</th>
              <th class="px-3 py-2 text-right">TPPrice</th>
              <th class="px-3 py-2">HitType</th>
              <th class="px-3 py-2 text-right">Shares</th>
              <th class="px-3 py-2 text-right">PnL</th>
              <th class="px-3 py-2 text-right">pnl_R</th>
              <th class="px-3 py-2 text-right">AUM</th>
              <th class="px-3 py-2 text-right">DailyReturn %</th>
              <th class="px-3 py-2 text-left">Strategy</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </section>
  </div>

  <script type="module" src="scripts/optimizer.js"></script>
  <script>
    // -----------------------------
    // Utilities
    // -----------------------------
    const pad2 = (n) => String(n).padStart(2, '0');
    const dateKeyFromStr = (val) => {
      if (val == null) return null;
      if (typeof val === 'string') {
        const m = val.trim().match(/^(\d{4}-\d{2}-\d{2})/);
        if (m) return m[1];
      }
      const d = new Date(val);
      if (isNaN(d)) return null;
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`; // local date key
    };
    const parseTimeHHMM = (hhmm) => { const [h, m] = (hhmm || '').split(':').map(Number); return h * 60 + (m || 0); };
  const toHHMM = (mins) => { const h = Math.floor((mins % (24*60) + 24*60) % (24*60) / 60); const m = ((mins % 60) + 60) % 60; return `${pad2(h)}:${pad2(m)}`; };
    const minutesOfDay = (d) => d.getHours() * 60 + d.getMinutes();
    const fmtNum = (x, digits = 2) => (x == null || isNaN(x) ? '' : Number(x).toFixed(digits));
    const fmtMoney = (x) => (x == null || isNaN(x) ? '' : Number(x).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }));
    const fmtInt = (x) => (x == null || isNaN(x) ? '0' : Math.round(Number(x)).toLocaleString());
    const fmtPct = (x) => (x == null || isNaN(x) ? '' : Number(x).toFixed(2));
    const fmtTime = (d) => d instanceof Date && !isNaN(d) ? `${pad2(d.getHours())}:${pad2(d.getMinutes())}` : '';
    const fmtCompactMoney = (value) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      const abs = Math.abs(num);
      const sign = num < 0 ? '-' : '';
      let scaled = abs;
      let suffix = '';
      if (abs >= 1e12) {
        scaled = abs / 1e12;
        suffix = 'T';
      } else if (abs >= 1e9) {
        scaled = abs / 1e9;
        suffix = 'B';
      } else if (abs >= 1e6) {
        scaled = abs / 1e6;
        suffix = 'M';
      } else if (abs >= 1e3) {
        scaled = abs / 1e3;
        suffix = 'K';
      } else {
        return `${sign}$${Math.round(abs).toLocaleString()}`;
      }
      const digits = scaled >= 10 ? 0 : 1;
      const scaledStr = scaled.toFixed(digits).replace(/\.0$/, '');
      return `${sign}$${scaledStr}${suffix}`;
    };

    const CONTRACT_SPECS = {
      MNQ: { multiplier: 2, maxLeverage: Infinity },
      NQ: { multiplier: 20, maxLeverage: Infinity },
      ES: { multiplier: 50, maxLeverage: Infinity },
      MES: { multiplier: 20, maxLeverage: Infinity },
    };

    const getContractSpec = (symbol) => {
      const sym = (symbol || '').toUpperCase();
      return CONTRACT_SPECS[sym] || { multiplier: 1, maxLeverage: null };
    };

    // -----------------------------
    // Global state
    // -----------------------------
    let currentTicker = '';
    let ROWS = [];        // current symbol rows
    let DAY_GROUPS = new Map();
    let DAYS = [];
    let VIEW_DIR = 'both';
    let LAST_OUT = null;
    let CURRENT_STRATEGY_ID = null;
    let CURRENT_STRATEGY_PARAMS = null;
    let CURRENT_STRATEGY_FAVORITE = false;
  let CURRENT_SYMBOL_FAVORITES = [];
  let CURRENT_MODE_TAB = 'backtest';
  let AUTO_RESULTS_CACHE = new Map();
  let AUTO_RESULTS_LIST = [];
  let AUTO_RESULTS_SORT = { key: 'sortino', direction: 'desc' };
  const AUTO_MAX_DD_LIMIT = 30; // percent drawdown ceiling for auto results
  const AUTO_MAX_INDETERMINATE_PCT = 3; // maximum reachable % of indeterminate trades
  const AUTO_SORTINO_CACHE = new WeakMap();
  const AUTO_MAXDD_CACHE = new WeakMap();
  const AUTO_INDET_CACHE = new WeakMap();
  let AUTO_BACKTEST_TOTAL_COUNT = 0;
  let LAST_PORTFOLIO_RUN = false;
  const PORTFOLIO_LIST_STORAGE_KEY = 'orbPortfolioList_v1';
  const PORTFOLIO_ACTIVE_STORAGE_KEY = 'orbPortfolioActive_v1';
  let PORTFOLIO_LIST = [];
  let CURRENT_PORTFOLIO_ID = '';
    let PORTFOLIO_CACHE = new Map();
    const AUTO_BACKTEST_STATE_STORAGE_KEY = 'orbAutoBacktestState_v1';
    let AUTO_BACKTEST_RUNNING = false;
    let AUTO_BACKTEST_PAUSE_REQUESTED = false;
    let AUTO_BACKTEST_PAUSED = false;
    let AUTO_BACKTEST_STATE_MAP = loadAutoBacktestState();
    let VIEW_DOW = new Set([1, 2, 3, 4, 5]); // 1=Mon ... 5=Fri
    let VIEW_MONTHS = new Set(); // empty => all
    let AVAILABLE_MONTHS = [];
  // ECharts instances
  let equityChartInst = null;
  let drawdownChartInst = null;
  let streakChartInst = null;
  let PORTFOLIO_EQUITY_SERIES = null;

  function getAutoSummary(entry) {
    return entry && entry.summary ? entry.summary : {};
  }

  function getAutoSortino(entry) {
    if (!entry) return null;
    if (AUTO_SORTINO_CACHE.has(entry)) return AUTO_SORTINO_CACHE.get(entry);
    const summary = getAutoSummary(entry);
    const val = Number(summary.sortinoRatio);
    if (Number.isFinite(val)) {
      AUTO_SORTINO_CACHE.set(entry, val);
      return val;
    }
    return null;
  }

  function getAutoMaxDD(entry) {
    if (!entry) return null;
    if (AUTO_MAXDD_CACHE.has(entry)) return AUTO_MAXDD_CACHE.get(entry);
    const summary = getAutoSummary(entry);
    const val = Number(summary.maxDDPct);
    if (Number.isFinite(val)) {
      AUTO_MAXDD_CACHE.set(entry, val);
      return val;
    }
    return null;
  }

  function getAutoIndeterminatePct(entry) {
    if (!entry) return null;
    if (AUTO_INDET_CACHE.has(entry)) return AUTO_INDET_CACHE.get(entry);
    const summary = getAutoSummary(entry);
    const tradeCounts = summary && summary.tradeCounts ? summary.tradeCounts : {};
    let pct = tradeCounts && tradeCounts.pct ? Number(tradeCounts.pct.indeterminate) : NaN;
    if (!Number.isFinite(pct)) {
      const total = Number(tradeCounts.total);
      const indetCount = Number(tradeCounts.indeterminate);
      if (Number.isFinite(total) && total > 0 && Number.isFinite(indetCount) && indetCount >= 0) {
        pct = Number(((indetCount / total) * 100).toFixed(2));
      }
    }
    if (Number.isFinite(pct)) {
      AUTO_INDET_CACHE.set(entry, pct);
      return pct;
    }
    return null;
  }

  function autoEntryPassesFilters(entry) {
    const sortino = getAutoSortino(entry);
    const maxDD = getAutoMaxDD(entry);
    const indetPct = getAutoIndeterminatePct(entry);
    if (sortino == null || maxDD == null || indetPct == null) return false;
    if (!(Math.abs(maxDD) <= AUTO_MAX_DD_LIMIT)) return false;
    return indetPct <= AUTO_MAX_INDETERMINATE_PCT;
  }

  function compareAutoEntries(a, b) {
    const sortinoA = getAutoSortino(a);
    const sortinoB = getAutoSortino(b);
    const scoreA = Number.isFinite(sortinoA) ? sortinoA : -Infinity;
    const scoreB = Number.isFinite(sortinoB) ? sortinoB : -Infinity;
    if (scoreB !== scoreA) return scoreB - scoreA;

    const maxDDA = getAutoMaxDD(a);
    const maxDDB = getAutoMaxDD(b);
    const ddA = Number.isFinite(maxDDA) ? Math.abs(maxDDA) : Infinity;
    const ddB = Number.isFinite(maxDDB) ? Math.abs(maxDDB) : Infinity;
    if (ddA !== ddB) return ddA - ddB; // prefer lower drawdown

    const indetA = getAutoIndeterminatePct(a);
    const indetB = getAutoIndeterminatePct(b);
    const inA = Number.isFinite(indetA) ? indetA : Infinity;
    const inB = Number.isFinite(indetB) ? indetB : Infinity;
    if (inA !== inB) return inA - inB; // prefer fewer indeterminates

    const marA = Number.isFinite(Number(a && a.mar)) ? Number(a.mar) : -Infinity;
    const marB = Number.isFinite(Number(b && b.mar)) ? Number(b.mar) : -Infinity;
    return marB - marA;
  }

  function formatAutoRunCount(count) {
    const num = Number(count);
    if (!Number.isFinite(num) || num < 0) return '0';
    try {
      return num.toLocaleString();
    } catch {
      return String(Math.trunc(num));
    }
  }

  function syncAddPortfolioButton() {
    const btn = document.getElementById('btnAddPortfolio');
    if (!btn) return;
    const label = btn.querySelector('[data-portfolio-add-label]');
    const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
    if (label) label.textContent = `Add to ${portfolioName}`;
  }

  function setPortfolioSelectDisabled(disabled) {
    const select = document.getElementById('portfolioSelect');
    if (!select) return;
    select.disabled = !!disabled;
    select.classList.toggle('opacity-50', !!disabled);
    select.classList.toggle('pointer-events-none', !!disabled);
  }

  function applySectionTitle(id, baseLabel) {
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = LAST_PORTFOLIO_RUN ? `${baseLabel} (Portfolio)` : baseLabel;
  }

  function setPortfolioContext(isPortfolio) {
    LAST_PORTFOLIO_RUN = !!isPortfolio;
    applySectionTitle('summaryTitle', 'Summary');
    applySectionTitle('equityTitle', 'Equity Curve');
    applySectionTitle('drawdownTitle', 'Drawdown');
    applySectionTitle('streakTitle', 'Win/Loss Streaks');
    applySectionTitle('monthlyTitle', 'Monthly Performance');
    syncAddPortfolioButton();
  }

  function getDefaultPortfolioName() {
    return 'Portfolio 1';
  }

  function loadPortfolioListFromStorage() {
    if (typeof localStorage === 'undefined') return [];
    try {
      const raw = localStorage.getItem(PORTFOLIO_LIST_STORAGE_KEY);
      const parsed = raw ? JSON.parse(raw) : [];
      return Array.isArray(parsed) ? parsed.filter(Boolean) : [];
    } catch {
      return [];
    }
  }

  function savePortfolioListToStorage(list) {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem(PORTFOLIO_LIST_STORAGE_KEY, JSON.stringify(list));
    } catch {}
  }

  function saveActivePortfolio(id) {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem(PORTFOLIO_ACTIVE_STORAGE_KEY, id || '');
    } catch {}
  }

  function ensurePortfolioListLoaded() {
    if (!PORTFOLIO_LIST.length) {
      const stored = loadPortfolioListFromStorage();
      const list = stored.length ? stored.slice() : [getDefaultPortfolioName()];
      if (!list.includes(getDefaultPortfolioName())) list.unshift(getDefaultPortfolioName());
      PORTFOLIO_LIST = list;
    }
    let active = CURRENT_PORTFOLIO_ID && PORTFOLIO_LIST.includes(CURRENT_PORTFOLIO_ID) ? CURRENT_PORTFOLIO_ID : null;
    if (!active && typeof localStorage !== 'undefined') {
      try {
        const storedActive = localStorage.getItem(PORTFOLIO_ACTIVE_STORAGE_KEY);
        if (storedActive && PORTFOLIO_LIST.includes(storedActive)) {
          active = storedActive;
        }
      } catch {}
    }
    if (!active) {
      active = PORTFOLIO_LIST[0] || getDefaultPortfolioName();
    }
    if (!PORTFOLIO_LIST.includes(active)) PORTFOLIO_LIST.unshift(active);
    CURRENT_PORTFOLIO_ID = active;
    savePortfolioListToStorage(PORTFOLIO_LIST);
    saveActivePortfolio(CURRENT_PORTFOLIO_ID);
    syncAddPortfolioButton();
  }

  function populatePortfolioSelect() {
    ensurePortfolioListLoaded();
    const select = document.getElementById('portfolioSelect');
    if (!select) return;
    const frag = document.createDocumentFragment();
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Load Portfolio…';
    frag.appendChild(placeholder);
    PORTFOLIO_LIST.forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      frag.appendChild(opt);
    });
    select.innerHTML = '';
    select.appendChild(frag);
    const target = (CURRENT_PORTFOLIO_ID && PORTFOLIO_LIST.includes(CURRENT_PORTFOLIO_ID)) ? CURRENT_PORTFOLIO_ID : (PORTFOLIO_LIST[0] || '');
    if (target) {
      CURRENT_PORTFOLIO_ID = target;
      select.value = target;
    } else {
      select.value = '';
    }
    saveActivePortfolio(CURRENT_PORTFOLIO_ID);
    setPortfolioSelectDisabled(PORTFOLIO_LIST.length === 0);
    syncAddPortfolioButton();
  }

  function setCurrentPortfolio(id, { refresh = true } = {}) {
    ensurePortfolioListLoaded();
    if (!id) id = PORTFOLIO_LIST[0];
    if (!PORTFOLIO_LIST.includes(id)) {
      PORTFOLIO_LIST.push(id);
      savePortfolioListToStorage(PORTFOLIO_LIST);
    }
    CURRENT_PORTFOLIO_ID = id;
    const select = document.getElementById('portfolioSelect');
    if (select) {
      select.value = CURRENT_PORTFOLIO_ID;
    }
    saveActivePortfolio(CURRENT_PORTFOLIO_ID);
    setPortfolioContext(false);
    syncAddPortfolioButton();
    if (refresh) refreshPortfolioTable().catch(() => {});
  }

  function createNewPortfolio() {
    ensurePortfolioListLoaded();
    const base = 'Portfolio ';
    let maxNum = 0;
    PORTFOLIO_LIST.forEach(name => {
      const match = /^Portfolio\s+(\d+)$/.exec(name);
      if (match) {
        const num = parseInt(match[1], 10);
        if (Number.isFinite(num)) maxNum = Math.max(maxNum, num);
      }
    });
    const nextName = `${base}${maxNum + 1}`;
    PORTFOLIO_LIST.push(nextName);
    savePortfolioListToStorage(PORTFOLIO_LIST);
    populatePortfolioSelect();
    setCurrentPortfolio(nextName);
  }

  setPortfolioContext(false);

  const DEFAULT_VIEW_DOW = [1, 2, 3, 4, 5];
  const DB_CONFIG = { name: 'orbBacktestDB', version: 2, store: 'runs', autoStore: 'autoResults' };
  const AUTO_RESULTS_STORE = DB_CONFIG.autoStore;
  const PORTFOLIO_DB_CONFIG = { name: 'orb_portfolio', version: 1, store: 'entries' };
  let dbPromise = null;
  let portfolioDbPromise = null;

  function getDbInstance() {
    if (typeof indexedDB === 'undefined') {
      return Promise.reject(new Error('IndexedDB is not available in this environment'));
    }
    if (!dbPromise) {
      dbPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_CONFIG.name, DB_CONFIG.version);
        request.onerror = () => reject(request.error);
        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains(DB_CONFIG.store)) {
            db.createObjectStore(DB_CONFIG.store, { keyPath: 'id' });
          }
          if (AUTO_RESULTS_STORE && !db.objectStoreNames.contains(AUTO_RESULTS_STORE)) {
            const autoStore = db.createObjectStore(AUTO_RESULTS_STORE, { keyPath: 'id' });
            autoStore.createIndex('symbol', 'symbol', { unique: false });
            autoStore.createIndex('symbol_mar', ['symbol', 'mar'], { unique: false });
          }
        };
        request.onsuccess = () => resolve(request.result);
      }).catch(err => {
        dbPromise = null;
        throw err;
      });
    }
    return dbPromise;
  }

  async function getStrategyRecord(id) {
    if (!id) return null;
    try {
      const db = await getDbInstance();
      if (!db) return null;
      return await new Promise((resolve, reject) => {
        const tx = db.transaction(DB_CONFIG.store, 'readonly');
        const store = tx.objectStore(DB_CONFIG.store);
        const req = store.get(id);
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
      });
    } catch (err) {
      console.error('Failed to read strategy record', err);
      return null;
    }
  }

  async function fetchAutoResults(symbol) {
    if (!symbol || !AUTO_RESULTS_STORE) return [];
    const upper = String(symbol).toUpperCase();
    try {
      const db = await getDbInstance();
      if (!db || !db.objectStoreNames.contains(AUTO_RESULTS_STORE)) return [];
      return await new Promise((resolve, reject) => {
        const tx = db.transaction(AUTO_RESULTS_STORE, 'readonly');
        const store = tx.objectStore(AUTO_RESULTS_STORE);
        const index = store.index('symbol');
        const req = index.getAll(upper);
        req.onsuccess = () => resolve(Array.isArray(req.result) ? req.result : []);
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
    } catch (err) {
      console.error('Failed to fetch auto results', err);
      return [];
    }
  }

  async function updateAutoResultsStore(symbol, newEntries) {
    if (!symbol || !AUTO_RESULTS_STORE) return [];
    const upper = String(symbol).toUpperCase();
    try {
      const db = await getDbInstance();
      if (!db || !db.objectStoreNames.contains(AUTO_RESULTS_STORE)) return [];

      const existing = await fetchAutoResults(upper);
      const map = new Map();
      for (const rec of existing) {
        if (!rec || !rec.strategyId) continue;
        if (!autoEntryPassesFilters(rec)) continue;
        map.set(rec.strategyId, rec);
      }

      const entries = Array.isArray(newEntries) ? newEntries : [];
      for (const entry of entries) {
        if (!entry || !entry.params) continue;
        if (!autoEntryPassesFilters(entry)) continue;
        const strategyId = buildStrategyKey(entry.params);
        if (!strategyId) continue;
        const mar = Number(entry.mar);
        if (!Number.isFinite(mar)) continue;
        const record = {
          id: `${upper}::${strategyId}`,
          symbol: upper,
          strategyId,
          mar,
          params: sanitizeParamsForStorage(entry.params),
          summary: entry.summary || null,
          combo: entry.combo || null,
          elapsedMs: Number.isFinite(entry.elapsedMs) ? Number(entry.elapsedMs) : null,
          updatedAt: new Date().toISOString()
        };
        const existingRec = map.get(strategyId);
        if (!existingRec || compareAutoEntries(existingRec, record) > 0) {
          map.set(strategyId, record);
        }
      }

      const merged = Array.from(map.values())
        .filter(autoEntryPassesFilters)
        .sort(compareAutoEntries)
        .slice(0, 20);

      await new Promise((resolve, reject) => {
        const tx = db.transaction(AUTO_RESULTS_STORE, 'readwrite');
        const store = tx.objectStore(AUTO_RESULTS_STORE);
        const index = store.index('symbol');
        const cursorReq = index.openCursor(upper);
        cursorReq.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            store.delete(cursor.primaryKey);
            cursor.continue();
          } else {
            for (const rec of merged) {
              store.put(rec);
            }
          }
        };
        cursorReq.onerror = () => reject(cursorReq.error || new Error('IndexedDB cursor failed'));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });

      return merged;
    } catch (err) {
      console.error('Failed to update auto results store', err);
      return [];
    }
  }

  async function clearAutoResultsForSymbol(symbol) {
    if (!symbol || !AUTO_RESULTS_STORE) return;
    const upper = String(symbol).toUpperCase();
    try {
      const db = await getDbInstance();
      if (!db || !db.objectStoreNames.contains(AUTO_RESULTS_STORE)) return;
      await new Promise((resolve, reject) => {
        const tx = db.transaction(AUTO_RESULTS_STORE, 'readwrite');
        const store = tx.objectStore(AUTO_RESULTS_STORE);
        const index = store.index('symbol');
        const req = index.openCursor(upper);
        req.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            store.delete(cursor.primaryKey);
            cursor.continue();
          } else {
            resolve();
          }
        };
        req.onerror = () => reject(req.error || new Error('IndexedDB cursor failed'));
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
      AUTO_RESULTS_CACHE = new Map();
      AUTO_RESULTS_LIST = [];
      AUTO_RESULTS_SORT = { key: 'sortino', direction: 'desc' };
    } catch (err) {
      console.error('Failed to clear auto results', err);
    }
  }

  function renderAutoResultsTable(entries) {
    const tbody = document.getElementById('autoResultsTableBody');
    const statusEl = document.getElementById('autoResultsStatus');
    if (!tbody) return;
    tbody.innerHTML = '';

    if (!Array.isArray(entries) || entries.length === 0) {
      if (statusEl) statusEl.textContent = 'No auto backtest results yet.';
      const tr = document.createElement('tr');
      tr.innerHTML = '<td colspan="15" class="px-3 py-4 text-center text-sm text-slate-500">No auto backtest results yet.</td>';
      tbody.appendChild(tr);
      return;
    }

    if (statusEl) {
      const symbolLabel = currentTicker ? currentTicker.toUpperCase() : 'current symbol';
      statusEl.textContent = `Top ${entries.length} result${entries.length === 1 ? '' : 's'} for ${symbolLabel}.`;
    }

    entries.forEach((entry) => {
      const params = entry && entry.params ? entry.params : {};
      const dir = params.direction ? String(params.direction).toUpperCase() : (entry && entry.combo && entry.combo.direction ? String(entry.combo.direction).toUpperCase() : '');
      const mar = Number(entry && entry.mar);
      const orbVal = params.orb_m ?? (entry && entry.combo ? entry.combo.orb_m : null);
      const tpValRaw = params.target_R ?? params.tp_R ?? (entry && entry.combo ? entry.combo.tp_R : null);
      const slValRaw = params.stop_R ?? params.sl_R ?? (entry && entry.combo ? entry.combo.sl_R : null);
      const tpVal = Number(tpValRaw);
      const slVal = Number(slValRaw);
      const tr = document.createElement('tr');
      const summary = entry && entry.summary ? entry.summary : {};
      const totalPnL = Number(summary.totalPnL);
      const avgDaily = Number(summary.avgDailyRet);
      const cagr = Number(summary.cagrPct);
      const maxDD = Number(summary.maxDDPct);
      const sortino = Number(summary.sortinoRatio);
      const ulcerPerf = Number(summary.ulcerPerf);
      const tradeCounts = summary && summary.tradeCounts ? summary.tradeCounts : {};
      const tradePct = tradeCounts && tradeCounts.pct ? tradeCounts.pct : {};
      let winPct = Number(tradePct.wins);
      if (!Number.isFinite(winPct)) {
        const totalTrades = Number(tradeCounts.total);
        const winsCount = Number(tradeCounts.wins);
        if (Number.isFinite(totalTrades) && totalTrades > 0 && Number.isFinite(winsCount) && winsCount >= 0) {
          winPct = (winsCount / totalTrades) * 100;
        }
      }
      const winPctDisplay = Number.isFinite(winPct) ? `${winPct.toFixed(2)}%` : '—';
      const totalPnLDisplay = Number.isFinite(totalPnL) ? `$${totalPnL.toLocaleString()}` : '—';
      const avgDailyDisplay = Number.isFinite(avgDaily) ? `${avgDaily.toFixed(2)}%` : '—';
      const cagrDisplay = Number.isFinite(cagr) ? `${cagr.toFixed(2)}%` : '—';
      const maxDDDisplay = Number.isFinite(maxDD) ? `${maxDD.toFixed(2)}%` : '—';
      const sortinoDisplay = Number.isFinite(sortino) ? sortino.toFixed(2) : '—';
      const ulcerDisplay = Number.isFinite(ulcerPerf) ? ulcerPerf.toFixed(2) : '—';

      tr.innerHTML = `
        <td class="px-3 py-2 font-mono text-xs break-all"><button type="button" class="text-slate-700 hover:text-indigo-600" data-auto-load="${entry.strategyId || ''}">${entry.strategyId || ''}</button></td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${sortinoDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${ulcerDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${Number.isFinite(mar) ? mar.toFixed(2) : ''}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${totalPnLDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${winPctDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${avgDailyDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${cagrDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${maxDDDisplay}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${orbVal ?? ''}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${Number.isFinite(tpVal) ? tpVal.toFixed(2) : (tpValRaw ?? '')}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${Number.isFinite(slVal) ? slVal.toFixed(2) : (slValRaw ?? '')}</td>
        <td class="px-3 py-2 text-sm">${params.orb_start_time || params.start_ny || ''}</td>
        <td class="px-3 py-2 text-sm">${params.orb_end_time || params.end_ny || ''}</td>
        <td class="px-3 py-2 text-sm">${dir}</td>`;
      tr.dataset.autostrategy = entry.strategyId || '';
      tr.className = 'border-b last:border-b-0 hover:bg-slate-50';
      tbody.appendChild(tr);
    });
    highlightAutoResultRow();
  }

  function highlightAutoResultRow() {
    document.querySelectorAll('[data-autostrategy]').forEach(row => {
      const active = row.dataset.autostrategy === CURRENT_STRATEGY_ID && CURRENT_STRATEGY_ID;
      row.classList.toggle('bg-indigo-50', active);
      row.classList.toggle('hover:bg-indigo-100', active);
      row.classList.toggle('hover:bg-slate-50', !active);
    });
  }

  async function loadAutoResultsForSymbol(symbol) {
    const entries = await fetchAutoResults(symbol);
    const filtered = entries.filter(autoEntryPassesFilters).sort(compareAutoEntries);
    AUTO_RESULTS_CACHE = new Map();
    AUTO_RESULTS_LIST = filtered.slice(0, 20);
    AUTO_RESULTS_LIST.forEach(entry => {
      if (entry && entry.strategyId) AUTO_RESULTS_CACHE.set(entry.strategyId, entry);
    });
    AUTO_RESULTS_SORT = { key: 'sortino', direction: 'desc' };
    applyAutoResultsSort();
    syncAutoBacktestButton();
    return AUTO_RESULTS_LIST;
  }

  function getAutoResultValue(entry, key) {
    const params = entry && entry.params ? entry.params : {};
    const summary = entry && entry.summary ? entry.summary : {};
    switch (key) {
      case 'strategyId':
        return entry && entry.strategyId ? String(entry.strategyId) : '';
      case 'sortino':
        return Number(summary.sortinoRatio);
      case 'ulcerPerf':
        return Number(summary.ulcerPerf);
      case 'mar':
        return Number(entry && entry.mar);
      case 'totalPnL':
        return Number(summary.totalPnL);
      case 'winPct': {
        const tradeCounts = summary && summary.tradeCounts ? summary.tradeCounts : {};
        const pctWins = tradeCounts && tradeCounts.pct ? Number(tradeCounts.pct.wins) : NaN;
        if (Number.isFinite(pctWins)) return pctWins;
        const totalTrades = Number(tradeCounts.total);
        const wins = Number(tradeCounts.wins);
        if (Number.isFinite(totalTrades) && totalTrades > 0 && Number.isFinite(wins) && wins >= 0) {
          return (wins / totalTrades) * 100;
        }
        return null;
      }
      case 'avgDaily':
        return Number(summary.avgDailyRet);
      case 'cagr':
        return Number(summary.cagrPct);
      case 'maxDD':
        return Number(summary.maxDDPct);
      case 'orb_m':
        return Number(params.orb_m ?? (entry && entry.combo ? entry.combo.orb_m : null));
      case 'tp_R':
        return Number(params.target_R ?? params.tp_R ?? (entry && entry.combo ? entry.combo.tp_R : null));
      case 'sl_R':
        return Number(params.stop_R ?? params.sl_R ?? (entry && entry.combo ? entry.combo.sl_R : null));
      case 'start':
        return parseTimeHHMM(params.orb_start_time || params.start_ny || '00:00');
      case 'end':
        return parseTimeHHMM(params.orb_end_time || params.end_ny || '00:00');
      case 'direction':
        return (params.direction || (entry && entry.combo ? entry.combo.direction : '') || '').toUpperCase();
      default:
        return null;
    }
  }

  function applyAutoResultsSort() {
    if (!Array.isArray(AUTO_RESULTS_LIST)) {
      renderAutoResultsTable([]);
      return;
    }
    const { key = 'mar', direction = 'desc' } = AUTO_RESULTS_SORT || {};
    const factor = direction === 'asc' ? 1 : -1;
    const sorted = AUTO_RESULTS_LIST.slice().sort((a, b) => {
      const va = getAutoResultValue(a, key);
      const vb = getAutoResultValue(b, key);
      if (va == null && vb == null) return 0;
      if (va == null) return 1;
      if (vb == null) return -1;
      if (typeof va === 'string' || typeof vb === 'string') {
        return factor * String(va).localeCompare(String(vb));
      }
      if (va > vb) return factor;
      if (va < vb) return -factor;
      return 0;
    });
    AUTO_RESULTS_LIST = sorted;
    updateAutoSortHeaders();
    AUTO_RESULTS_CACHE = new Map();
    sorted.forEach(entry => {
      if (entry && entry.strategyId) AUTO_RESULTS_CACHE.set(entry.strategyId, entry);
    });
    renderAutoResultsTable(sorted);
  }

  function updateAutoSortHeaders() {
    document.querySelectorAll('[data-auto-sort]').forEach(btn => {
      const key = btn.getAttribute('data-auto-sort');
      const indicator = btn.querySelector('[data-sort-indicator]');
      const active = AUTO_RESULTS_SORT && AUTO_RESULTS_SORT.key === key;
      btn.classList.toggle('text-slate-900', active);
      btn.classList.toggle('text-slate-600', !active);
      if (indicator) {
        if (active) {
          indicator.style.opacity = '1';
          indicator.textContent = AUTO_RESULTS_SORT.direction === 'asc' ? '▲' : '▼';
        } else {
          indicator.style.opacity = '0';
          indicator.textContent = '▲';
        }
      }
    });
  }

  function highlightTickerButton(symbol) {
    const seg = document.getElementById('tickerSegment');
    if (!seg) return;
    const upper = (symbol || '').toUpperCase();
    seg.querySelectorAll('button[data-symbol]').forEach(btn => {
      const active = (btn.getAttribute('data-symbol') || '').toUpperCase() === upper;
      btn.classList.toggle('bg-slate-800', active);
      btn.classList.toggle('text-white', active);
      btn.classList.toggle('focus:outline-none', active);
      btn.classList.toggle('bg-white', !active);
      btn.classList.toggle('hover:bg-slate-100', !active);
    });
  }

  async function ensureSymbolLoaded(symbol) {
    if (!symbol) return true;
    const upper = symbol.toUpperCase();
    const already = currentTicker === upper;
    if (!already) {
      setTicker(upper);
    }
    highlightTickerButton(upper);
    if (!already) {
      const ok = await loadSymbolData(upper);
      if (!ok) return false;
      buildMonthOptions();
    }
    return true;
  }

  function syncSecondaryNav(name) {
    const secondaryButtons = document.querySelectorAll('[data-secondary-nav]');
    if (!secondaryButtons.length) return;
    secondaryButtons.forEach(btn => {
      const isActive = btn.getAttribute('data-secondary-nav') === name;
      btn.classList.toggle('text-slate-900', isActive);
      btn.classList.toggle('text-slate-500', !isActive);
      if (isActive) {
        btn.setAttribute('aria-current', 'page');
      } else {
        btn.removeAttribute('aria-current');
      }
      const underline = btn.querySelector('[data-secondary-underline]');
      if (underline) {
        underline.classList.toggle('opacity-100', isActive);
        underline.classList.toggle('opacity-0', !isActive);
      }
    });
  }

  function activateModeTab(name) {
    CURRENT_MODE_TAB = name;
    document.querySelectorAll('[data-mode-tab]').forEach(btn => {
      const active = btn.getAttribute('data-mode-tab') === name;
      btn.classList.toggle('text-slate-900', active);
      btn.classList.toggle('text-slate-500', !active);
      btn.classList.toggle('border-blue-500', active);
      btn.classList.toggle('border-transparent', !active);
      const icon = btn.querySelector('span > svg');
      if (icon) {
        icon.classList.toggle('text-blue-500', active);
      }
    });
    document.querySelectorAll('[data-tab-panel]').forEach(panel => {
      const active = panel.getAttribute('data-tab-panel') === name;
      panel.classList.toggle('hidden', !active);
    });
    document.querySelectorAll('[data-shared-section]').forEach(section => {
      const onlyBacktest = section.getAttribute('data-shared-section') === 'filters';
      section.classList.toggle('hidden', onlyBacktest && name !== 'backtest');
    });
    syncSecondaryNav(name);
  }

  function initModeTabs() {
    const buttons = document.querySelectorAll('[data-mode-tab]');
    if (!buttons.length) return;
    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        activateModeTab(btn.getAttribute('data-mode-tab'));
      });
    });
    activateModeTab(CURRENT_MODE_TAB);
    updateAutoSortHeaders();
  }

  function initSecondaryNav() {
    const buttons = document.querySelectorAll('[data-secondary-nav]');
    if (!buttons.length) return;
    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        activateModeTab(btn.getAttribute('data-secondary-nav'));
      });
    });
    syncSecondaryNav(CURRENT_MODE_TAB);
  }

  async function applyAutoResult(entry) {
    if (AUTO_BACKTEST_RUNNING) {
      setStatus('Wait for Auto Backtest to finish before loading a result.');
      return;
    }
    if (!entry || !entry.params) return;
    const params = entry.params;
    if (params.symbol) {
      const ok = await ensureSymbolLoaded(params.symbol);
      if (!ok) {
        setStatus(`Failed to load data for ${params.symbol}.`);
        return;
      }
    }
    setInputValue('inp_orb_m', params.orb_m);
    setInputValue('inp_target_R', params.target_R ?? params.tp_R);
    setInputValue('inp_stop_R', params.stop_R ?? params.sl_R);
    setInputValue('inp_risk_pct', params.risk_pct ?? params.riskPct);
    setInputValue('inp_aum0', params.AUM_0 ?? params.aum_0);
    setInputValue('inp_orb_start', params.orb_start_time ?? params.start_ny);
    setInputValue('inp_orb_end', params.orb_end_time ?? params.end_ny);
    setInputValue('inp_entry_cutoff', params.entry_cutoff_time ?? params.cutoff_time);
    setDirectionFromFavorite(params.direction);
    CURRENT_STRATEGY_ID = entry.strategyId || null;
    CURRENT_STRATEGY_PARAMS = { ...params };
    CURRENT_STRATEGY_FAVORITE = false;
    syncFavoriteButton();
    await runBacktestIfReady();
  }

  async function fetchFavoriteRunsForSymbol(symbol) {
    if (!symbol) return [];
    try {
      const db = await getDbInstance();
      if (!db) return [];
      const runs = await new Promise((resolve, reject) => {
        const tx = db.transaction(DB_CONFIG.store, 'readonly');
        const store = tx.objectStore(DB_CONFIG.store);
        const req = store.getAll();
        req.onsuccess = () => resolve(Array.isArray(req.result) ? req.result : []);
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
      const symUpper = String(symbol || '').toUpperCase();
      return runs.filter(r => {
        if (!r || !r.favorite) return false;
        const params = r.params || {};
        const storedSym = (params.symbol || '').toUpperCase();
        return storedSym === symUpper;
      });
    } catch (err) {
      console.error('Failed to fetch favorite strategies', err);
      return [];
    }
  }

  function getPortfolioDbInstance() {
    if (typeof indexedDB === 'undefined') {
      return Promise.reject(new Error('IndexedDB is not available in this environment'));
    }
    if (!portfolioDbPromise) {
      portfolioDbPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(PORTFOLIO_DB_CONFIG.name, PORTFOLIO_DB_CONFIG.version);
        request.onerror = () => reject(request.error);
        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains(PORTFOLIO_DB_CONFIG.store)) {
            db.createObjectStore(PORTFOLIO_DB_CONFIG.store, { keyPath: 'id' });
          }
        };
        request.onsuccess = () => resolve(request.result);
      }).catch(err => {
        portfolioDbPromise = null;
        throw err;
      });
    }
    return portfolioDbPromise;
  }

  function isDefaultFilterState() {
    if (VIEW_MONTHS.size !== 0) return false;
    if (VIEW_DOW.size !== DEFAULT_VIEW_DOW.length) return false;
    return DEFAULT_VIEW_DOW.every(d => VIEW_DOW.has(d));
  }

  function formatNumberForKey(val) {
    if (val == null || val === '') return '0';
    const num = Number(val);
    if (!Number.isFinite(num)) return '0';
    const str = `${num}`;
    return str.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
  }

  function formatTimeForKey(timeStr) {
    if (typeof timeStr !== 'string' || !timeStr.includes(':')) return timeStr || '';
    return timeStr.replace(':', '.');
  }

  function buildStrategyKey(params) {
    if (!params || !params.symbol) return '';
    const dirLetter = params.direction === 'long' ? 'L' : params.direction === 'short' ? 'S' : 'B';
    const riskPct = Number.isFinite(params.risk) ? params.risk * 100 : 0;
    const parts = [
      (params.symbol || '').toUpperCase(),
      dirLetter,
      formatNumberForKey(params.orb_m),
      formatNumberForKey(params.target_R),
      formatNumberForKey(params.stop_R),
      formatTimeForKey(params.orb_start_time),
      formatTimeForKey(params.orb_end_time),
      formatTimeForKey(params.entry_cutoff_time),
      formatNumberForKey(riskPct)
    ];
    return parts.join('_');
  }

  function sanitizeParamsForStorage(params) {
    if (!params) return null;
    return {
      symbol: (params.symbol || '').toUpperCase(),
      direction: params.direction,
      orb_m: params.orb_m,
      target_R: params.target_R,
      stop_R: params.stop_R,
      orb_start_time: params.orb_start_time,
      orb_end_time: params.orb_end_time,
      entry_cutoff_time: params.entry_cutoff_time,
      risk_pct: Number.isFinite(params.risk) ? Number((params.risk * 100).toFixed(4)) : null,
      AUM_0: params.AUM_0,
      commission: params.commission,
      breakout_buffer: params.breakout_buffer
    };
  }

  function sanitizeTradeValue(value) {
    if (value instanceof Date) {
      return isNaN(value.getTime()) ? null : value.toISOString();
    }
    if (typeof value === 'number') {
      return Number.isFinite(value) ? value : null;
    }
    if (Array.isArray(value)) {
      return value.map(item => sanitizeTradeValue(item));
    }
    if (value && typeof value === 'object') {
      const obj = {};
      for (const [key, val] of Object.entries(value)) {
        obj[key] = sanitizeTradeValue(val);
      }
      return obj;
    }
    return value == null ? null : value;
  }

  function sanitizeTradesForStorage(rows) {
    if (!Array.isArray(rows)) return [];
    return rows.map((row = {}) => {
      const clean = {};
      for (const [key, value] of Object.entries(row)) {
        clean[key] = sanitizeTradeValue(value);
      }
      return clean;
    });
  }

  function parseDateSafe(val) {
    if (!val) return null;
    if (val instanceof Date && !isNaN(val)) return val;
    const parsed = new Date(val);
    return isNaN(parsed) ? null : parsed;
  }

  function hydrateTradeRow(row, strategyId) {
    const clone = { ...(row || {}) };
    const dateFields = ['EntryTime', 'ExitTime', 'caldt'];
    for (const field of dateFields) {
      if (clone[field]) {
        const parsed = parseDateSafe(clone[field]);
        if (parsed) clone[field] = parsed;
      }
    }
    clone.StrategyId = strategyId;
    clone.SourceStrategyId = strategyId;
    clone.PortfolioRun = true;
    return clone;
  }

  function combinePortfolioTrades(entries) {
    if (!Array.isArray(entries) || entries.length === 0) return { trades: [], strategySeries: [] };
    const combined = [];
    const strategySeries = new Map();
    for (const entry of entries) {
      const strategyId = entry && entry.id ? entry.id : 'UNKNOWN';
      const trades = Array.isArray(entry && entry.trades) ? entry.trades.slice() : [];
      trades.sort((a, b) => {
        const tA = parseDateSafe(a && (a.EntryTime || a.caldt || a.Date));
        const tB = parseDateSafe(b && (b.EntryTime || b.caldt || b.Date));
        return (tA ? tA.getTime() : 0) - (tB ? tB.getTime() : 0);
      });
      if (!strategySeries.has(strategyId)) strategySeries.set(strategyId, []);
      const series = strategySeries.get(strategyId);
      for (const trade of trades) {
        const dateKey = trade && trade.Date ? trade.Date : (trade && trade.EntryTime ? dateKeyFromStr(trade.EntryTime) : null);
        const aumVal = trade && Number.isFinite(Number(trade.AUM)) ? Number(trade.AUM) : null;
        if (dateKey) {
          series.push([dateKey, aumVal]);
        }
        const hydrated = hydrateTradeRow(trade, strategyId);
        combined.push(hydrated);
      }
    }

    const sortKey = (row) => {
      const entryTime = parseDateSafe(row.EntryTime);
      if (entryTime) return entryTime.getTime();
      const caldt = parseDateSafe(row.caldt);
      if (caldt) return caldt.getTime();
      if (typeof row.Date === 'string') {
        const d = Date.parse(row.Date);
        if (!Number.isNaN(d)) return d;
      }
      return 0;
    };

    combined.sort((a, b) => sortKey(a) - sortKey(b));

    const totalInitialAUM = entries.reduce((sum, entry) => {
      const params = entry && entry.params;
      const aum0 = params && Number(params.AUM_0);
      return sum + (Number.isFinite(aum0) ? aum0 : 0);
    }, 0);

    let runningAUM = Number.isFinite(totalInitialAUM) && totalInitialAUM > 0 ? totalInitialAUM : 0;
    for (const row of combined) {
      const pnl = Number(row.PnL);
      const prevAUM = Number.isFinite(runningAUM) ? runningAUM : 0;
      const originalAUM = Number(row.AUM);
      if (Number.isFinite(originalAUM)) {
        row.StrategyAUM = originalAUM;
      }
      const nextAUM = prevAUM + (Number.isFinite(pnl) ? pnl : 0);
      runningAUM = nextAUM;
      row.AUM = Number.isFinite(nextAUM) ? Number(nextAUM.toFixed(2)) : nextAUM;
      if (!Number.isFinite(row.pnl_R)) {
        row.pnl_R = Number.isFinite(prevAUM) && prevAUM !== 0
          ? Number((pnl / prevAUM).toFixed(2))
          : 0;
      }
      row.DailyReturn = Number.isFinite(prevAUM) && prevAUM !== 0
        ? Number(((pnl / prevAUM) * 100).toFixed(2))
        : 0;
      row.PortfolioAUM = row.AUM;
    }

    const strategySeriesArr = Array.from(strategySeries.entries()).map(([id, data]) => ({ id, data }));
    return { trades: combined, strategySeries: strategySeriesArr };
  }

  async function evaluateParams(params, options = {}) {
    const { skipPersist = false } = options;
    const start = performance.now();
    const out = backtest(params);
    const summary = computeSummaryMetrics(out);
    if (!skipPersist) {
      await persistStrategyResult(params, out);
    }
    return {
      summary,
      out,
      elapsedMs: performance.now() - start
    };
  }

    function setTicker(sym) {
      currentTicker = (sym || '').toUpperCase();
      const titleEl = document.getElementById('mainTitle');
      if (titleEl) {
        const prefix = currentTicker ? currentTicker + ' - ' : '';
        const full = prefix + 'ORB Backtest';
        titleEl.textContent = full;
        document.title = full;
      }
      CURRENT_STRATEGY_ID = null;
      CURRENT_STRATEGY_PARAMS = null;
      CURRENT_STRATEGY_FAVORITE = false;
      syncFavoriteButton();
      loadFavoritesForSymbol(currentTicker).catch(() => {});
      loadAutoResultsForSymbol(currentTicker).catch(() => {});
      highlightTickerButton(currentTicker);
      const autoState = getAutoBacktestState(currentTicker);
      AUTO_BACKTEST_TOTAL_COUNT = Number.isFinite(autoState.totalProcessed) ? autoState.totalProcessed : 0;
      syncAutoBacktestButton();
    }

    function setStatus(msg) { const el = document.getElementById('status'); if (el) el.textContent = msg || ''; }

    function syncFavoriteButton() {
      const btn = document.getElementById('btnAddFavorite');
      if (!btn) return;
      const active = !!CURRENT_STRATEGY_FAVORITE;
      const hasId = !!CURRENT_STRATEGY_ID;
      btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      btn.classList.remove('bg-emerald-500', 'text-white', 'border-emerald-500');
      btn.classList.remove('opacity-50', 'pointer-events-none');
      btn.disabled = false;
      if (active) {
        btn.classList.remove('border-slate-200', 'bg-white', 'text-slate-600');
        btn.classList.add('bg-emerald-500', 'text-white', 'border-emerald-500');
      } else {
        btn.classList.add('border-slate-200', 'bg-white', 'text-slate-600');
      }
      if (!hasId || !Array.isArray(LAST_OUT) || LAST_OUT.length === 0) {
        btn.disabled = true;
        btn.classList.add('opacity-50', 'pointer-events-none');
      }
    }

  function syncAutoBacktestButton() {
    const btn = document.getElementById('btnAutoBacktest');
    if (!btn) return;
    const ready = !!currentTicker && Array.isArray(DAYS) && DAYS.length > 0;
    const pausePending = AUTO_BACKTEST_RUNNING && AUTO_BACKTEST_PAUSE_REQUESTED;
    const disableDueToPause = pausePending;
    const disabled = !ready || disableDueToPause;
    btn.disabled = disabled;
    btn.classList.toggle('opacity-50', disabled);
    btn.classList.toggle('pointer-events-none', disabled);

    const running = AUTO_BACKTEST_RUNNING && !AUTO_BACKTEST_PAUSE_REQUESTED;
    const hasResults = (Array.isArray(AUTO_RESULTS_LIST) && AUTO_RESULTS_LIST.length > 0) || (AUTO_RESULTS_CACHE && AUTO_RESULTS_CACHE.size > 0);
    const labelEl = btn.querySelector('[data-auto-label]');
    const playIcon = btn.querySelector('[data-auto-icon="play"]');
    const pauseIcon = btn.querySelector('[data-auto-icon="pause"]');
    let label = 'Start Backtest';
    if (pausePending) {
      label = 'Pausing…';
    } else if (running) {
      label = 'Pause Backtest';
    } else if (hasResults) {
      label = 'Resume Backtest';
    }
    if (labelEl && labelEl.textContent !== label) labelEl.textContent = label;
    if (playIcon && pauseIcon) {
      const showPause = running || pausePending;
      playIcon.classList.toggle('hidden', showPause);
      pauseIcon.classList.toggle('hidden', !showPause);
    }
    const btnState = pausePending ? 'pausing' : (running ? 'running' : (AUTO_BACKTEST_PAUSED && hasResults ? 'paused' : 'idle'));
    btn.setAttribute('data-state', btnState);

    const clearBtn = document.getElementById('btnClearAuto');
    if (clearBtn) {
      const key = (currentTicker || '').toUpperCase();
      const state = AUTO_BACKTEST_STATE_MAP[key];
      const hasStateData = !!(state && (state.initialCompleted || (Number.isFinite(state.sobolIndex) && state.sobolIndex > 0)));
      const hasCacheData = !!(AUTO_RESULTS_CACHE && AUTO_RESULTS_CACHE.size);
      const hasData = hasStateData || hasCacheData;
      const clearDisabled = AUTO_BACKTEST_RUNNING || !currentTicker || !hasData;
      clearBtn.disabled = clearDisabled;
      clearBtn.classList.toggle('opacity-50', clearDisabled);
      clearBtn.classList.toggle('pointer-events-none', clearDisabled);
    }
  }

    function loadAutoBacktestState() {
      if (typeof localStorage === 'undefined') return {};
      try {
        const raw = localStorage.getItem(AUTO_BACKTEST_STATE_STORAGE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
      } catch (err) {
        console.warn('Failed to load auto backtest state', err);
        return {};
      }
    }

    function saveAutoBacktestState() {
      if (typeof localStorage === 'undefined') return;
      try {
        localStorage.setItem(AUTO_BACKTEST_STATE_STORAGE_KEY, JSON.stringify(AUTO_BACKTEST_STATE_MAP));
      } catch (err) {
        console.warn('Failed to save auto backtest state', err);
      }
    }

  function getAutoBacktestState(symbol) {
    const key = (symbol || '').toUpperCase();
    if (!AUTO_BACKTEST_STATE_MAP[key]) {
      AUTO_BACKTEST_STATE_MAP[key] = { initialCompleted: false, sobolIndex: 0, initialIndex: 0, totalProcessed: 0 };
    }
    const state = AUTO_BACKTEST_STATE_MAP[key];
    if (typeof state.initialCompleted !== 'boolean') state.initialCompleted = false;
    if (!Number.isFinite(state.sobolIndex)) state.sobolIndex = 0;
    if (!Number.isFinite(state.initialIndex)) state.initialIndex = 0;
    if (!Number.isFinite(state.totalProcessed)) state.totalProcessed = 0;
    return state;
  }

  function resetAutoBacktestState(symbol) {
    const key = (symbol || '').toUpperCase();
    if (AUTO_BACKTEST_STATE_MAP[key]) {
      delete AUTO_BACKTEST_STATE_MAP[key];
      saveAutoBacktestState();
    }
    AUTO_BACKTEST_PAUSED = false;
    AUTO_BACKTEST_PAUSE_REQUESTED = false;
    AUTO_BACKTEST_TOTAL_COUNT = 0;
  }

    async function refreshFavoriteState(id) {
      if (!id) {
        CURRENT_STRATEGY_FAVORITE = false;
        syncFavoriteButton();
        const select = document.getElementById('favoriteSelect');
        if (select) select.value = '';
        return;
      }
      const record = await getStrategyRecord(id);
      CURRENT_STRATEGY_FAVORITE = !!(record && record.favorite);
      syncFavoriteButton();
      const select = document.getElementById('favoriteSelect');
      if (select) {
        if (CURRENT_STRATEGY_FAVORITE && Array.from(select.options).some(opt => opt.value === id)) {
          select.value = id;
        } else if (!CURRENT_STRATEGY_FAVORITE && select.value === id) {
          select.value = '';
        }
      }
    }

    function setFavoriteSelectDisabled(disabled) {
      const select = document.getElementById('favoriteSelect');
      if (!select) return;
      select.disabled = !!disabled;
      select.classList.toggle('opacity-50', !!disabled);
      select.classList.toggle('pointer-events-none', !!disabled);
    }

    async function loadFavoritesForSymbol(symbol) {
      const select = document.getElementById('favoriteSelect');
      if (!select) return;
      CURRENT_SYMBOL_FAVORITES = [];
      const placeholder = '<option value="">Load Favorite…</option>';
      select.innerHTML = placeholder;
      setFavoriteSelectDisabled(true);
      if (!symbol) {
        return;
      }
      const favorites = await fetchFavoriteRunsForSymbol(symbol);
      CURRENT_SYMBOL_FAVORITES = favorites;
      if (!favorites.length) {
        return;
      }
      const frag = document.createDocumentFragment();
      const optionDefault = document.createElement('option');
      optionDefault.value = '';
      optionDefault.textContent = 'Load Favorite…';
      frag.appendChild(optionDefault);
      favorites.forEach(fav => {
        const opt = document.createElement('option');
        opt.value = fav.id || '';
        opt.textContent = fav.id || '(unnamed)';
        frag.appendChild(opt);
      });
      select.innerHTML = '';
      select.appendChild(frag);
      setFavoriteSelectDisabled(false);
      if (CURRENT_STRATEGY_ID && favorites.some(f => f.id === CURRENT_STRATEGY_ID)) {
        select.value = CURRENT_STRATEGY_ID;
      } else {
        select.value = '';
      }
    }

  function setDirectionFromFavorite(dir) {
    const seg = document.getElementById('dirSegment');
    const normalized = (dir || 'both').toLowerCase();
    VIEW_DIR = ['long', 'short'].includes(normalized) ? normalized : 'both';
    if (!seg) return;
      seg.querySelectorAll('button[data-dir]').forEach(btn => {
        const val = (btn.getAttribute('data-dir') || '').toLowerCase();
        const active = val === VIEW_DIR;
        btn.classList.toggle('bg-slate-800', active);
        btn.classList.toggle('text-white', active);
        btn.classList.toggle('focus:outline-none', active);
        btn.classList.toggle('bg-white', !active);
        btn.classList.toggle('hover:bg-slate-100', !active);
      });
    }

    function setInputValue(id, value) {
      const el = document.getElementById(id);
      if (!el || value === undefined || value === null || value === '') return;
      el.value = String(value);
    }

    async function applyFavoriteStrategy(record) {
      if (!record || !record.params) return;
      const params = record.params;
      if (params.symbol) {
        const ok = await ensureSymbolLoaded(params.symbol);
        if (!ok) {
          setStatus(`Failed to load data for ${params.symbol}.`);
          return;
        }
      }
      setInputValue('inp_orb_m', params.orb_m);
      setInputValue('inp_target_R', params.target_R);
      setInputValue('inp_stop_R', params.stop_R);
      setInputValue('inp_risk_pct', params.risk_pct);
      setInputValue('inp_aum0', params.AUM_0);
      setInputValue('inp_orb_start', params.orb_start_time);
      setInputValue('inp_orb_end', params.orb_end_time);
      setInputValue('inp_entry_cutoff', params.entry_cutoff_time);
    setDirectionFromFavorite(params.direction);
    CURRENT_STRATEGY_ID = record.id || null;
    CURRENT_STRATEGY_PARAMS = { ...params };
    CURRENT_STRATEGY_FAVORITE = !!record.favorite;
      syncFavoriteButton();
      const select = document.getElementById('favoriteSelect');
      if (select && CURRENT_STRATEGY_ID) {
        select.value = CURRENT_STRATEGY_ID;
      }
      await runBacktestIfReady();
    }

    function getNextAutoBacktestBatch(state, optimizer) {
      if (!state || !optimizer) return null;
      if (!state.initialCompleted && optimizer.getInitialGridCombos) {
        const combos = optimizer.getInitialGridCombos ? optimizer.getInitialGridCombos() : [];
        const totalInitial = Array.isArray(combos) ? combos.length : 0;
        const startIndex = Math.min(Math.max(Number(state.initialIndex) || 0, 0), totalInitial);
        if (!totalInitial || startIndex >= totalInitial) {
          state.initialCompleted = true;
          state.initialIndex = totalInitial;
          return getNextAutoBacktestBatch(state, optimizer);
        }
        return {
          mode: 'initial',
          modeLabel: 'Seed grid',
          combos: combos.slice(startIndex),
          initialTotal: totalInitial,
          initialStartIndex: startIndex
        };
      }
      if (optimizer.getSobolBatch) {
        const batchSize = optimizer.SOBOL_DEFAULT_BATCH || 500;
        const startIndex = Number(state.sobolIndex) || 0;
        const sobolInfo = optimizer.getSobolBatch(batchSize, startIndex) || {};
        const combos = Array.isArray(sobolInfo.combos) ? sobolInfo.combos : [];
        const nextIndex = Number.isFinite(sobolInfo.nextIndex) ? sobolInfo.nextIndex : startIndex + combos.length;
        if (!combos.length) return null;
        return {
          mode: 'sobol',
          modeLabel: 'Sobol',
          combos,
          sobolStartIndex: startIndex,
          sobolNextIndex: nextIndex
        };
      }
      return null;
    }

    async function runAutoBacktestBatch(batch, state) {
      if (!batch || !Array.isArray(batch.combos) || batch.combos.length === 0) {
        setStatus('No parameter combinations available for Auto Backtest.');
        return { processed: 0, total: 0, completed: true, paused: false, hadError: false };
      }

      const { combos, mode, modeLabel } = batch;
      const total = combos.length;
      const baseParams = getBacktestParams();
      const topResults = [];
      const limit = 100;
      const updateTop = (entry) => {
        if (!autoEntryPassesFilters(entry)) return;
        topResults.push(entry);
        topResults.sort(compareAutoEntries);
        if (topResults.length > limit) topResults.length = limit;
      };

      let processed = 0;
      const yieldInterval = 25;
      let hadError = false;

      setStatus(`Auto backtest (${modeLabel}) running… 0/${total} (total ${formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT)})`);

      try {
        for (const combo of combos) {
          if (AUTO_BACKTEST_PAUSE_REQUESTED) break;
          const params = {
            ...baseParams,
            days: Array.isArray(baseParams.days) ? baseParams.days.slice() : baseParams.days,
            orb_m: combo.orb_m,
            target_R: combo.tp_R,
            stop_R: combo.sl_R,
            orb_start_time: combo.start_ny,
            orb_end_time: combo.end_ny,
            direction: (combo.direction || 'BOTH').toLowerCase()
          };

          const { summary, elapsedMs } = await evaluateParams(params, { skipPersist: true });
          const marValue = summary && Number.isFinite(Number(summary.mar)) ? Number(summary.mar) : null;
          if (marValue !== null) {
            updateTop({ combo, params: { ...params }, summary, mar: marValue, elapsedMs });
          }
          processed += 1;
          AUTO_BACKTEST_TOTAL_COUNT += 1;
          state.totalProcessed = (Number.isFinite(state.totalProcessed) ? state.totalProcessed : 0) + 1;

          if (AUTO_BACKTEST_PAUSE_REQUESTED) {
            setStatus(`Pausing auto backtest… finishing current combo (${processed}/${total}, total ${formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT)}).`);
          } else if (processed % yieldInterval === 0) {
            const bestEntry = topResults.length ? topResults[0] : null;
            const bestSortinoVal = bestEntry ? getAutoSortino(bestEntry) : null;
            const bestSortino = Number.isFinite(bestSortinoVal) ? bestSortinoVal.toFixed(2) : '—';
            const bestId = bestEntry && bestEntry.params ? buildStrategyKey(bestEntry.params) : '—';
            setStatus(`Auto backtest (${modeLabel}) ${processed}/${total} (total ${formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT)}) (best Sortino ${bestSortino}, ${bestId})`);
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }
      } catch (err) {
        hadError = true;
        console.error('Auto backtest failed', err);
        setStatus('Auto backtest encountered an error. See console for details.');
      }

      const bestEntry = topResults.length ? topResults[0] : null;
      const bestSortinoVal = bestEntry ? getAutoSortino(bestEntry) : null;
      const bestSortino = Number.isFinite(bestSortinoVal) ? bestSortinoVal.toFixed(2) : '—';
      const bestId = bestEntry && bestEntry.params ? buildStrategyKey(bestEntry.params) : '—';
      const completed = processed === total && !AUTO_BACKTEST_PAUSE_REQUESTED && !hadError;

      const totalLabel = formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT);

      if (AUTO_BACKTEST_PAUSE_REQUESTED && !hadError) {
        setStatus(`Auto backtest paused after ${processed}/${total} combos (total ${totalLabel}). Best Sortino ${bestSortino}.`);
      } else if (!hadError) {
        if (completed) {
          setStatus(`Auto backtest (${modeLabel}) completed ${processed}/${total} combos (total ${totalLabel}). Best Sortino ${bestSortino}. Strategy ${bestId}.`);
        } else {
          setStatus(`Auto backtest (${modeLabel}) stopped after ${processed}/${total} combos (total ${totalLabel}). Best Sortino ${bestSortino}.`);
        }
      }

      if (mode === 'initial') {
        const start = batch.initialStartIndex || 0;
        const totalInitial = batch.initialTotal || total;
        state.initialIndex = start + processed;
        if (state.initialIndex >= totalInitial || completed) {
          state.initialIndex = Math.min(state.initialIndex, totalInitial);
          state.initialCompleted = true;
        }
        if (!Number.isFinite(state.sobolIndex)) state.sobolIndex = 0;
      } else if (mode === 'sobol') {
        const start = batch.sobolStartIndex || 0;
        if (AUTO_BACKTEST_PAUSE_REQUESTED || hadError) {
          state.sobolIndex = start + processed;
        } else {
          state.sobolIndex = batch.sobolNextIndex || (start + processed);
        }
        state.initialCompleted = true;
      }

      saveAutoBacktestState();

      const runTop = topResults.slice(0, limit);
      let storedTopRecords = [];
      try {
        storedTopRecords = await updateAutoResultsStore(currentTicker, runTop);
      } catch (err) {
        console.error('Failed to update stored auto results', err);
      }

      saveAutoBacktestState();

      try {
        await loadAutoResultsForSymbol(currentTicker);
      } catch (err) {
        console.error('Failed to refresh auto results table', err);
      }

      window.ORBAutoBacktestResults = {
        timestamp: new Date().toISOString(),
        symbol: currentTicker,
        totalCombos: total,
        processedCombos: processed,
        validResults: topResults.length,
        mode: modeLabel,
        batchMode: mode,
        nextSobolIndex: state.sobolIndex || 0,
        paused: AUTO_BACKTEST_PAUSE_REQUESTED,
        hadError,
        rankingMetric: 'sortino',
        bestSortino: Number.isFinite(bestSortinoVal) ? bestSortinoVal : null,
        maxDrawdownLimit: AUTO_MAX_DD_LIMIT,
        totalProcessed: Number.isFinite(state.totalProcessed) ? state.totalProcessed : AUTO_BACKTEST_TOTAL_COUNT,
        runTop,
        storedTop: storedTopRecords,
        top: runTop
      };
      if (runTop.length) {
        console.log('Auto backtest top results (session):', runTop);
      }
      if (storedTopRecords.length) {
        console.log('Auto backtest stored top results:', storedTopRecords);
      }

      return { processed, total, completed, paused: AUTO_BACKTEST_PAUSE_REQUESTED, hadError };
    }

    function pauseAutoBacktest() {
      if (!AUTO_BACKTEST_RUNNING || AUTO_BACKTEST_PAUSE_REQUESTED) return;
      AUTO_BACKTEST_PAUSE_REQUESTED = true;
      setStatus(`Pausing auto backtest… finishing current combo (total ${formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT)}).`);
      syncAutoBacktestButton();
    }

    async function startAutoBacktest() {
      if (AUTO_BACKTEST_RUNNING) return;
      if (!currentTicker) { setStatus('Pick a symbol before running Auto Backtest.'); return; }
      if (!Array.isArray(DAYS) || DAYS.length === 0) { setStatus('Load data before running Auto Backtest.'); return; }
      const optimizer = window.ORBOptimizer;
      if (!optimizer || (!optimizer.getInitialGridCombos && !optimizer.getSobolBatch)) {
        setStatus('Optimizer module not available.');
        return;
      }

      const state = getAutoBacktestState(currentTicker);
      AUTO_BACKTEST_TOTAL_COUNT = Number.isFinite(state.totalProcessed) ? state.totalProcessed : 0;
      AUTO_BACKTEST_PAUSE_REQUESTED = false;
      AUTO_BACKTEST_PAUSED = false;
      AUTO_BACKTEST_RUNNING = true;
      syncAutoBacktestButton();

      try {
        while (!AUTO_BACKTEST_PAUSE_REQUESTED) {
          const batch = getNextAutoBacktestBatch(state, optimizer);
          if (!batch) {
            if (!AUTO_BACKTEST_PAUSE_REQUESTED) {
              setStatus('No parameter combinations available for Auto Backtest.');
            }
            break;
          }

          const result = await runAutoBacktestBatch(batch, state);
          if (result.hadError || AUTO_BACKTEST_PAUSE_REQUESTED) break;

          if (batch.mode === 'initial' && result.completed) {
            AUTO_BACKTEST_PAUSE_REQUESTED = true;
            const totalLabel = formatAutoRunCount(AUTO_BACKTEST_TOTAL_COUNT);
            setStatus(`Auto backtest seed grid completed (total ${totalLabel}). Paused before Sobol sweep. Press Resume Backtest to continue.`);
            break;
          }

          await new Promise(resolve => setTimeout(resolve, 0));
        }
      } finally {
        const wasPaused = AUTO_BACKTEST_PAUSE_REQUESTED;
        AUTO_BACKTEST_RUNNING = false;
        AUTO_BACKTEST_PAUSED = wasPaused;
        AUTO_BACKTEST_PAUSE_REQUESTED = false;
        syncAutoBacktestButton();
        saveAutoBacktestState();
      }
    }

    function normalizeAndIndex(rows) {
      if (!rows || !rows.length) throw new Error('No rows parsed');
      const required = ['caldt', 'day', 'open', 'high', 'low', 'close'];
      const missing = required.filter(c => !(c in rows[0]));
      if (missing.length) throw new Error('Missing columns: ' + missing.join(', '));

      ROWS = rows.map(r => {
        const caldt = new Date(r.caldt);
        const dayKey = dateKeyFromStr(r.day);
        const open = Number(r.open), high = Number(r.high), low = Number(r.low), close = Number(r.close);
        if (!dayKey || isNaN(caldt)) return null;
        if ([open, high, low, close].some(v => !Number.isFinite(v))) return null;
        return { caldt, dayKey, open, high, low, close };
      }).filter(Boolean);

      DAY_GROUPS = new Map();
      for (const row of ROWS) {
        if (!DAY_GROUPS.has(row.dayKey)) DAY_GROUPS.set(row.dayKey, []);
        DAY_GROUPS.get(row.dayKey).push(row);
      }
      for (const [k, arr] of DAY_GROUPS.entries()) arr.sort((a, b) => a.caldt - b.caldt);
      DAYS = Array.from(DAY_GROUPS.keys()).sort();
    }

    async function loadSymbolData(sym) {
      if (!sym) return false;
      setStatus(`Loading data for ${sym}…`);
      try {
        const path = `data/${sym}_1m.csv`;
        const res = await fetch(path, { cache: 'no-cache' });
        if (!res.ok) throw new Error(`HTTP ${res.status} loading ${path}`);
        const text = await res.text();
        const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
        if (parsed.errors && parsed.errors.length) {
          console.warn('CSV parse warnings:', parsed.errors.slice(0, 3));
        }
        normalizeAndIndex(parsed.data);
        setStatus(`Loaded ${ROWS.length} rows across ${DAYS.length} day(s).`);
        syncAutoBacktestButton();
        return true;
      } catch (err) {
        console.error(err);
        setStatus(`Error loading ${sym}: ${err.message}`);
        ROWS = []; DAY_GROUPS = new Map(); DAYS = [];
        syncAutoBacktestButton();
        return false;
      }
    }

    // -----------------------------
    // Backtest (JS port)
    // -----------------------------
    function backtest({
      symbol = '',
      days,
      dayGroups,
      orb_m,
      target_R,
      stop_R,
      risk,
      AUM_0,
      commission,
      direction = 'both',
      orb_start_time = '9:30',
      orb_end_time = '15:30',
      entry_cutoff_time = '12:00',
      breakout_buffer = 0.01,
    }) {
      const out = [];

      // Convert time strings to minutes-of-day format
      const orbStartMin = parseTimeHHMM(orb_start_time);
      const orbEndMin = parseTimeHHMM(orb_end_time);
      const entryCutoffMin = parseTimeHHMM(entry_cutoff_time);

      const { multiplier: contractMultiplier } = getContractSpec(symbol);

      for (let t = 0; t < days.length; t++) {
        const dayKey = days[t];
        const prev_AUM = t > 0 && out[t - 1]?.AUM != null ? out[t - 1].AUM : AUM_0;

        const rowOut = {
          Date: dayKey, ORH: NaN, ORL: NaN, Side: '',
          EntryTime: null, Entry: NaN, ExitTime: null, Exit: NaN,
          StopPrice: NaN, TPPrice: NaN, HitType: '', Shares: NaN,
          PnL: NaN, pnl_R: 0, AUM: prev_AUM, DailyReturn: 0,
        };

        const rawDay = dayGroups && typeof dayGroups.get === 'function' ? dayGroups.get(dayKey) : null;
        const df_day = Array.isArray(rawDay)
          ? rawDay.filter(bar => bar && bar.caldt instanceof Date && !isNaN(bar.caldt.getTime()))
          : [];
        if (!df_day.length) {
          rowOut.HitType = 'NotEnoughBars';
          rowOut.Shares = 0;
          out.push(rowOut);
          continue;
        }

        // Identify the ORB (Opening Range Breakout) window
        const startIdx = df_day.findIndex(r => minutesOfDay(r.caldt) >= orbStartMin);
        if (startIdx < 0 || (startIdx + orb_m) > df_day.length) {
          rowOut.HitType = 'NotEnoughBars';
          rowOut.Shares = 0;
          out.push(rowOut);
          continue;
        }

        // Calculate Opening Range High (ORH) and Low (ORL)
        let ORH = -Infinity, ORL = Infinity;
        let windowValid = true;
        for (let k = startIdx; k < startIdx + orb_m; k++) {
          const bar = df_day[k];
          if (!bar || !Number.isFinite(bar.high) || !Number.isFinite(bar.low)) {
            windowValid = false;
            break;
          }
          ORH = Math.max(ORH, bar.high);
          ORL = Math.min(ORL, bar.low);
        }
        if (!windowValid || !Number.isFinite(ORH) || !Number.isFinite(ORL)) {
          rowOut.HitType = 'NotEnoughBars';
          rowOut.Shares = 0;
          out.push(rowOut);
          continue;
        }
        rowOut.ORH = ORH;
        rowOut.ORL = ORL;

        // Entry logic
        let entryIdx = null, entry_side = 0, entry_price = NaN, entry_time = null;

        for (let i = startIdx + orb_m; i < df_day.length; i++) {
          const r = df_day[i];
          if (!r || !(r.caldt instanceof Date)) continue;
          if (!Number.isFinite(r.high) || !Number.isFinite(r.low)) continue;
          if (minutesOfDay(r.caldt) >= entryCutoffMin) break;

          const long_hit = r.high > (ORH + breakout_buffer);
          const short_hit = r.low < (ORL - breakout_buffer);

          if (
            (direction === 'long' && !long_hit) ||
            (direction === 'short' && !short_hit) ||
            (direction === 'both' && !(long_hit || short_hit))
          ) {
            continue;
          }

          // Decide direction
          if (long_hit && !short_hit) entry_side = 1;
          else if (short_hit && !long_hit) entry_side = -1;
          else entry_side = direction === 'short' ? -1 : 1;

          entry_price = entry_side === 1 ? (ORH + breakout_buffer) : (ORL - breakout_buffer);
          entryIdx = i;
          entry_time = new Date(r.caldt);

          rowOut.Side = entry_side === 1 ? 'Long' : 'Short';
          rowOut.EntryTime = entry_time;
          rowOut.Entry = entry_price;
          break;
        }

        if (entryIdx == null) {
          rowOut.HitType = 'NoBreak';
          rowOut.Shares = 0;
          out.push(rowOut);
          continue;
        }

        // Calculate stop loss and target levels
        const R_price = (ORH - ORL) / 2;
        const stop_price = entry_side === 1 ? entry_price - stop_R * R_price : entry_price + stop_R * R_price;
        const target_price = entry_side === 1 ? entry_price + target_R * R_price : entry_price - target_R * R_price;

        rowOut.StopPrice = stop_price;
        rowOut.TPPrice = target_price;

        // Risk management: position sizing
        const stop_frac = (stop_R * R_price) / entry_price;
        const max_risk_contracts = stop_frac > 0
          ? (prev_AUM * risk) / (entry_price * stop_frac * contractMultiplier)
          : 0;

        const shares = Math.floor(max_risk_contracts);

        rowOut.Shares = shares;
        if (!(shares > 0)) {
          rowOut.HitType = 'NoSize';
          out.push(rowOut);
          continue;
        }

        // Exit logic
        let exitIdx = null, hit = 'EOD', exit_time = null, exit_price = NaN;
        let indeterminate = false;

        for (let j = entryIdx + 1; j < df_day.length; j++) {
          const r2 = df_day[j];
          if (!r2 || !(r2.caldt instanceof Date)) continue;
          if (!Number.isFinite(r2.high) || !Number.isFinite(r2.low)) continue;
          const tp_hit = entry_side === 1 ? r2.high >= target_price : r2.low <= target_price;
          const st_hit = entry_side === 1 ? r2.low <= stop_price : r2.high >= stop_price;

          if (tp_hit && st_hit) {
            exitIdx = j;
            hit = 'Indeterminate';
            indeterminate = true;
            break;
          }
          if (tp_hit) { exitIdx = j; hit = 'TP'; break; }
          if (st_hit) { exitIdx = j; hit = 'Stop'; break; }
        }

        if (indeterminate) {
          const bar = df_day[exitIdx];
          if (bar && bar.caldt instanceof Date) {
            rowOut.ExitTime = new Date(bar.caldt);
          } else {
            rowOut.ExitTime = null;
          }
          rowOut.HitType = 'Indeterminate';
          out.push(rowOut);
          continue;
        }

        // No exit signal: exit at EOD
        if (exitIdx == null) {
          const eodIdx = df_day.findLastIndex(r => r && r.caldt instanceof Date && minutesOfDay(r.caldt) === orbEndMin);
          exitIdx = eodIdx >= 0 ? eodIdx : df_day.length - 1;
          const r_eod = df_day[exitIdx];
          if (r_eod && r_eod.caldt instanceof Date) {
            exit_time = new Date(r_eod.caldt);
          } else {
            exit_time = entry_time;
          }
          exit_price = r_eod && Number.isFinite(r_eod.close) ? r_eod.close : entry_price;
        } else {
          const r_exit = df_day[exitIdx];
          exit_time = r_exit && r_exit.caldt instanceof Date ? new Date(r_exit.caldt) : entry_time;
          const fallbackExit = Number.isFinite(exit_price) ? exit_price : entry_price;
          const o_exit = r_exit && Number.isFinite(r_exit.open) ? r_exit.open : fallbackExit;

          exit_price = (hit === 'TP')
            ? (entry_side === 1 ? Math.max(target_price, o_exit) : Math.min(target_price, o_exit))
            : (entry_side === 1 ? Math.min(stop_price, o_exit) : Math.max(stop_price, o_exit));
        }

        rowOut.ExitTime = exit_time;
        rowOut.Exit = exit_price;
        rowOut.HitType = hit;

        // PnL calculation
        const pnl = entry_side === 1
          ? (exit_price - entry_price) * shares * contractMultiplier
          : (entry_price - exit_price) * shares * contractMultiplier;

        const new_AUM = prev_AUM + pnl - (shares * commission * 2);

        rowOut.PnL = pnl;
        rowOut.AUM = new_AUM;
        rowOut.pnl_R = risk * prev_AUM !== 0 ? Number((pnl / (risk * prev_AUM)).toFixed(2)) : 0;
        rowOut.DailyReturn = prev_AUM !== 0 ? Number(((pnl / prev_AUM) * 100).toFixed(2)) : 0;

        out.push(rowOut);
      }

      return out;
    }

    function computeSummaryMetrics(out) {
      if (!Array.isArray(out) || out.length === 0) return null;
      const trades = out.filter(r => r.Shares > 0 && !['NotEnoughBars', 'NoBreak', 'NoSize'].includes(r.HitType));
      let totalTrades = 0;
      let tpWins = 0;
      let stops = 0;
      let eodCount = 0;
      let eodWin = 0;
      let eodLoss = 0;
      let indeterminate = 0;
      for (const trade of trades) {
        totalTrades += 1;
        const hit = trade.HitType;
        if (hit === 'TP') tpWins += 1;
        else if (hit === 'Stop') stops += 1;
        else if (hit === 'EOD') {
          eodCount += 1;
          if (Number(trade.PnL) > 0) eodWin += 1;
          else if (Number(trade.PnL) < 0) eodLoss += 1;
        } else if (hit === 'Indeterminate') {
          indeterminate += 1;
        }
      }
      const wins = tpWins + eodWin;
      const losses = stops + eodLoss;

      let totalPnL = 0;
      let totalDailyReturn = 0;
      let dailyReturnCount = 0;
      let sumDailyReturnDecimal = 0;
      let downsideSumSquares = 0;
      for (const row of out) {
        if (Number.isFinite(row.PnL)) totalPnL += row.PnL;
        if (Number.isFinite(row.DailyReturn)) {
          totalDailyReturn += row.DailyReturn;
          dailyReturnCount += 1;
          const dailyDec = Number(row.DailyReturn) / 100;
          if (Number.isFinite(dailyDec)) {
            sumDailyReturnDecimal += dailyDec;
            if (dailyDec < 0) {
              downsideSumSquares += dailyDec * dailyDec;
            }
          }
        }
      }
      const avgDailyRet = dailyReturnCount ? totalDailyReturn / dailyReturnCount : 0;
      const avgDailyRetDecimal = dailyReturnCount ? sumDailyReturnDecimal / dailyReturnCount : 0;
      const downsideDeviation = dailyReturnCount ? Math.sqrt(downsideSumSquares / dailyReturnCount) : null;
      const sortinoRatio = (downsideDeviation && downsideDeviation > 0)
        ? (avgDailyRetDecimal * Math.sqrt(252)) / downsideDeviation
        : null;

      const lastRow = out[out.length - 1] || {};
      const lastAUM = Number.isFinite(lastRow.AUM) ? lastRow.AUM : null;

      let cagrPct = 0;
      let maxDDPct = 0;
      let ulcerIndex = null;
      let ulcerPerf = null;
      if (out.length > 1) {
        const firstRow = out[0] || {};
        const startAUM = Number.isFinite(firstRow.AUM) ? firstRow.AUM : null;
        const endAUM = Number.isFinite(lastRow.AUM) ? lastRow.AUM : null;
        const firstDate = firstRow.Date ? new Date(firstRow.Date) : null;
        const lastDate = lastRow.Date ? new Date(lastRow.Date) : null;
        const firstDateValid = firstDate && !isNaN(firstDate);
        const lastDateValid = lastDate && !isNaN(lastDate);
        if (startAUM !== null && endAUM !== null && startAUM > 0 && endAUM > 0 && firstDateValid && lastDateValid) {
          const days = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
          const years = days / 365.25;
          if (years > 0) {
            cagrPct = (Math.pow(endAUM / startAUM, 1 / years) - 1) * 100;
          }
        }
        let peak = startAUM;
        let mdd = 0;
        let ddSquares = 0;
        let ddCount = 0;
        for (const row of out) {
          const a = Number(row.AUM);
          if (!Number.isFinite(a)) continue;
          if (!Number.isFinite(peak) || a > peak) {
            peak = a;
            continue;
          }
          if (Number.isFinite(peak) && peak > 0) {
            const dd = ((a / peak) - 1) * 100;
            if (dd < mdd) mdd = dd;
            const ddDecimal = Math.max(0, (peak - a) / peak);
            ddSquares += ddDecimal * ddDecimal;
            ddCount += 1;
          }
        }
        if (ddCount > 0) {
          const uiDecimal = Math.sqrt(ddSquares / ddCount);
          ulcerIndex = uiDecimal * 100;
          const cagrDecimal = Number.isFinite(cagrPct) ? cagrPct / 100 : null;
          ulcerPerf = (Number.isFinite(cagrDecimal) && uiDecimal > 0) ? cagrDecimal / uiDecimal : null;
          if (ulcerPerf !== null) {
            ulcerPerf = Number(ulcerPerf.toFixed(4));
          }
        }
        maxDDPct = mdd;
      }

      const mar = (Number.isFinite(cagrPct) && maxDDPct < 0) ? cagrPct / Math.abs(maxDDPct) : null;

      const pctOrZero = (count) => totalTrades > 0 ? Number(((count / totalTrades) * 100).toFixed(2)) : 0;

      return {
        totalDays: out.length,
        finalAUM: lastAUM,
        totalPnL,
        avgDailyRet,
        cagrPct,
        maxDDPct,
        mar,
        sortinoRatio,
        downsideDeviation: (downsideDeviation != null) ? downsideDeviation : null,
        ulcerIndex,
        ulcerPerf,
        tradeCounts: {
          total: totalTrades,
          wins,
          losses,
          eodCount,
          eodWin,
          eodLoss,
          indeterminate,
          pct: {
            wins: pctOrZero(wins),
            losses: pctOrZero(losses),
            eod: pctOrZero(eodCount),
            eodWin: pctOrZero(eodWin),
            eodLoss: pctOrZero(eodLoss),
            indeterminate: pctOrZero(indeterminate)
          }
        }
      };
    }

    function renderSummary(out) {
      const summary = document.getElementById('summary');
      if (!summary) return;
      applySectionTitle('summaryTitle', 'Summary');
      const metrics = computeSummaryMetrics(out);
      if (!metrics) { summary.innerHTML = ''; return; }

      const { totalDays, finalAUM, totalPnL, avgDailyRet, cagrPct, maxDDPct, mar, sortinoRatio, ulcerIndex, ulcerPerf, tradeCounts } = metrics;
      const { total, wins, losses, eodCount, eodWin, eodLoss, indeterminate, pct: tradePct = {} } = tradeCounts;

      const cards = [
        { label: 'Days Backtested', value: fmtInt(totalDays) },
        { label: 'Final AUM', value: `$${fmtInt(finalAUM)}` },
        { label: 'CAGR', value: `${fmtPct(cagrPct)}%` },
        { label: 'Avg Daily Return', value: `${fmtPct(avgDailyRet)}%` },
        { label: 'Total PnL', value: `$${fmtInt(totalPnL)}`, cls: ((totalPnL > 0) ? 'num-pos' : 'num-neg') + ' text-3xl' },
        { label: 'Max DD', value: `${fmtPct(maxDDPct)}%` },
        { label: 'Sortino (ann.)', value: sortinoRatio == null ? '—' : `${fmtNum(sortinoRatio, 2)}x` },
        { label: 'Ulcer Index', value: ulcerIndex == null ? '—' : `${fmtPct(ulcerIndex)}%` },
        { label: 'Ulcer Perf (UPI)', value: ulcerPerf == null ? '—' : `${fmtNum(ulcerPerf, 2)}x` },
        { label: 'MAR', value: mar == null ? '—' : `${fmtNum(mar, 2)}x` },
      ];

      const gridHtml = `<div class="grid sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">${cards.map(c => {
        const baseValCls = 'text-xl font-semibold tabular-nums font-mono text-right';
        const valCls = (c.label === 'Total PnL') ? `${baseValCls} text-3xl pnl-strong` : baseValCls;
        return `<div class=\"rounded-2xl border p-4\"><div class=\"text-xs text-slate-500\">${c.label}</div><div class=\"${valCls} ${c.cls || ''}\">${c.value}</div></div>`;
      }).join('')
        }</div>`;

      const pct = (val) => {
        const num = Number(val);
        if (!Number.isFinite(num)) return '0.00%';
        return `${fmtPct(num)}%`;
      };
      const tableHtml = `
      <div class="rounded-2xl border p-3 overflow-auto">
        <div class="text-xs text-slate-500 mb-2">Trades breakdown</div>
        <table class="min-w-full text-sm">
          <thead class="bg-slate-50">
            <tr>
      <th class="px-3 py-2 text-left">Total</th>
      <th class="px-3 py-2 text-right">Win</th>
      <th class="px-3 py-2 text-right">Loss</th>
      <th class="px-3 py-2 text-right">EOD</th>
      <th class="px-3 py-2 text-right">EOD Win</th>
      <th class="px-3 py-2 text-right">EOD Loss</th>
            </tr>
          </thead>
          <tbody>
            <tr class="border-b">
      <td class="px-3 py-2">${fmtInt(total)}</td>
      <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(wins)}</td>
      <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(losses)}</td>
      <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(eodCount)}</td>
      <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(eodWin)}</td>
      <td class="px-3 py-2 text-right tabular-nums font-mono">${fmtInt(eodLoss)}</td>
            </tr>
            <tr>
      <td class="px-3 py-2 text-slate-600">100.0%</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.wins)}</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.losses)}</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.eod)}</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.eodWin)}</td>
      <td class="px-3 py-2 text-right text-slate-600 tabular-nums font-mono">${pct(tradePct.eodLoss)}</td>
            </tr>
          </tbody>
        </table>
        ${indeterminate > 0 ? `<p class="text-xs text-slate-500 mt-2">${fmtInt(indeterminate)} (${pct(tradePct.indeterminate)}) Indeterminate trades: bar range touched both target and stop within the same minute, so the outcome is unknowable at 1-min resolution.</p>` : ''}
      </div>
    `;

      summary.innerHTML = gridHtml + tableHtml;
    }

    async function persistStrategyResult(params, out, opts = {}) {
      if (!params || !Array.isArray(out) || out.length === 0) return;
      const { force = false, favoriteOverride } = opts;
      if (!isDefaultFilterState() && !force) return;
      const key = buildStrategyKey(params);
      if (!key) return;
      const summaryMetrics = computeSummaryMetrics(out);
      if (!summaryMetrics) return;

      const existing = await getStrategyRecord(key);
      const favoriteFlag = (favoriteOverride != null)
        ? !!favoriteOverride
        : !!(existing && existing.favorite);

      const record = {
        id: key,
        savedAt: new Date().toISOString(),
        params: sanitizeParamsForStorage(params),
        summary: summaryMetrics,
        favorite: favoriteFlag
      };

      try {
        const db = await getDbInstance();
        if (!db) return;
        await new Promise((resolve, reject) => {
          const tx = db.transaction(DB_CONFIG.store, 'readwrite');
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
          tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
          tx.objectStore(DB_CONFIG.store).put(record);
        });
      } catch (err) {
        console.error('Failed to persist backtest result', err);
      }
    }

  async function persistPortfolioEntry(params, trades) {
    if (!params || !Array.isArray(trades) || trades.length === 0) return;
    ensurePortfolioListLoaded();
    const strategyId = buildStrategyKey(params);
    if (!strategyId) return;
    const portfolioId = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
    const summary = computeSummaryMetrics(trades);
    if (!summary) return;

    const record = {
      id: `${portfolioId}::${strategyId}`,
      portfolioId,
      strategyId,
      savedAt: new Date().toISOString(),
      params: sanitizeParamsForStorage(params),
      summary,
      trades: sanitizeTradesForStorage(trades)
    };

    try {
      const db = await getPortfolioDbInstance();
      if (!db) return;
      await new Promise((resolve, reject) => {
        const tx = db.transaction(PORTFOLIO_DB_CONFIG.store, 'readwrite');
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
        tx.objectStore(PORTFOLIO_DB_CONFIG.store).put(record);
      });
    } catch (err) {
      console.error('Failed to save portfolio entry', err);
      throw err;
    }
    return record;
  }

  async function fetchPortfolioEntries(portfolioId = CURRENT_PORTFOLIO_ID) {
    try {
      const db = await getPortfolioDbInstance();
      if (!db) return [];
      const activeId = portfolioId || getDefaultPortfolioName();
      return await new Promise((resolve, reject) => {
        const tx = db.transaction(PORTFOLIO_DB_CONFIG.store, 'readonly');
        const store = tx.objectStore(PORTFOLIO_DB_CONFIG.store);
        const req = store.getAll();
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
        req.onsuccess = () => {
          const all = Array.isArray(req.result) ? req.result : [];
          let listChanged = false;
          const normalized = all.map(rec => {
            if (rec && !rec.portfolioId) {
              rec.portfolioId = getDefaultPortfolioName();
            }
            if (rec && rec.portfolioId && !PORTFOLIO_LIST.includes(rec.portfolioId)) {
              PORTFOLIO_LIST.push(rec.portfolioId);
              listChanged = true;
            }
            if (rec && !rec.strategyId) {
              const rawId = rec.id ? String(rec.id) : '';
              const parts = rawId.split('::');
              rec.strategyId = parts.length > 1 ? parts[parts.length - 1] : rawId || '';
            }
            if (rec && rec.portfolioId && rec.strategyId && !rec.id) {
              rec.id = `${rec.portfolioId}::${rec.strategyId}`;
            }
            return rec;
          });
          if (listChanged) {
            savePortfolioListToStorage(PORTFOLIO_LIST);
          }
          resolve(normalized.filter(rec => rec && rec.portfolioId === activeId));
        };
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
      });
    } catch (err) {
      console.error('Failed to load portfolio entries', err);
      return [];
    }
  }

  function renderPortfolioTable(entries) {
    const tbody = document.getElementById('portfolioTableBody');
    if (!tbody) return;
    tbody.innerHTML = '';
    PORTFOLIO_CACHE = new Map();

    const rows = Array.isArray(entries)
      ? entries.slice().sort((a, b) => {
          const da = a && a.savedAt ? new Date(a.savedAt).getTime() : 0;
          const db = b && b.savedAt ? new Date(b.savedAt).getTime() : 0;
          return db - da;
        })
      : [];

    const formatIntDisplay = (val) => {
      const num = Number(val);
      return Number.isFinite(num) ? Math.round(num).toLocaleString() : '—';
    };
    const formatMoneyDisplay = (val) => {
      const num = Number(val);
      return Number.isFinite(num) ? `$${num.toLocaleString(undefined, { maximumFractionDigits: 2 })}` : '—';
    };
    const formatPercentDisplay = (val) => {
      const num = Number(val);
      return Number.isFinite(num) ? `${num.toFixed(2)}%` : '—';
    };
    const formatNumberDisplay = (val, digits = 2) => {
      const num = Number(val);
      return Number.isFinite(num) ? num.toFixed(digits) : '—';
    };

    if (!rows.length) {
      const tr = document.createElement('tr');
      tr.innerHTML = '<td colspan="10" class="px-3 py-4 text-center text-sm text-slate-500">No saved strategies yet.</td>';
      tbody.appendChild(tr);
      return;
    }

    for (const entry of rows) {
      const summary = entry && entry.summary ? entry.summary : {};
      const trades = summary && summary.tradeCounts ? summary.tradeCounts : {};
      const tradePct = trades && trades.pct ? trades.pct : {};
      let winPct = Number(tradePct.wins);
      if (!Number.isFinite(winPct)) {
        const totalTrades = Number(trades.total);
        const winsCount = Number(trades.wins);
        if (Number.isFinite(totalTrades) && totalTrades > 0 && Number.isFinite(winsCount) && winsCount >= 0) {
          winPct = (winsCount / totalTrades) * 100;
        }
      }
      const idValue = entry && entry.id ? String(entry.id) : '';
      if (idValue) PORTFOLIO_CACHE.set(idValue, entry);
      const displayId = entry && entry.strategyId ? entry.strategyId : (idValue ? idValue.split('::').pop() : '—');
      const tr = document.createElement('tr');
      tr.className = 'border-b last:border-b-0 hover:bg-slate-50';
      tr.innerHTML = `
        <td class="px-3 py-2 font-mono text-xs md:text-sm break-all"><button type="button" class="text-slate-700 hover:text-emerald-600" data-portfolio-load="${idValue}">${displayId}</button></td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatIntDisplay(summary.totalDays)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatIntDisplay(trades.total)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(winPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatMoneyDisplay(summary.totalPnL)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.avgDailyRet)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.cagrPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatPercentDisplay(summary.maxDDPct)}</td>
        <td class="px-3 py-2 text-right tabular-nums font-mono">${formatNumberDisplay(summary.mar, 2)}</td>
        <td class="px-3 py-2 text-right">
          <button type="button" class="inline-flex items-center gap-1 rounded-lg border border-slate-200 bg-white px-2 py-1 text-xs font-medium text-slate-600 shadow-sm transition hover:border-rose-500 hover:text-rose-600" ${idValue ? `data-portfolio-delete="${idValue}"` : 'disabled'}>
            Delete
          </button>
        </td>
      `;
      tbody.appendChild(tr);
    }
  }

  async function refreshPortfolioTable() {
    ensurePortfolioListLoaded();
    const entries = await fetchPortfolioEntries(CURRENT_PORTFOLIO_ID);
    populatePortfolioSelect();
    renderPortfolioTable(entries);
  }

  async function deletePortfolioEntry(id) {
    if (!id) return false;
    try {
      const db = await getPortfolioDbInstance();
      if (!db) return false;
      await new Promise((resolve, reject) => {
        const tx = db.transaction(PORTFOLIO_DB_CONFIG.store, 'readwrite');
        const store = tx.objectStore(PORTFOLIO_DB_CONFIG.store);
        const req = store.delete(id);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
        req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
      });
      return true;
    } catch (err) {
      console.error('Failed to delete portfolio entry', err);
      throw err;
    }
  }

  async function clearPortfolioEntries() {
    try {
      const db = await getPortfolioDbInstance();
      if (!db) return false;
      const activeId = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
      await new Promise((resolve, reject) => {
        const tx = db.transaction(PORTFOLIO_DB_CONFIG.store, 'readwrite');
        const store = tx.objectStore(PORTFOLIO_DB_CONFIG.store);
        const cursorReq = store.openCursor();
        cursorReq.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            const value = cursor.value || {};
            const recPortfolio = value.portfolioId || getDefaultPortfolioName();
            if (recPortfolio === activeId) {
              cursor.delete();
            }
            cursor.continue();
          } else {
            resolve();
          }
        };
        cursorReq.onerror = () => reject(cursorReq.error || new Error('IndexedDB cursor failed'));
        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
        tx.onabort = () => reject(tx.error || new Error('IndexedDB transaction aborted'));
      });
      PORTFOLIO_CACHE = new Map();
      return true;
    } catch (err) {
      console.error('Failed to clear portfolio entries', err);
      throw err;
    }
  }

  async function runPortfolio() {
    const statusEl = document.getElementById('status');
    const previousMsg = statusEl ? statusEl.textContent : '';
    CURRENT_STRATEGY_ID = null;
    CURRENT_STRATEGY_PARAMS = null;
    CURRENT_STRATEGY_FAVORITE = false;
    syncFavoriteButton();
    loadFavoritesForSymbol(currentTicker).catch(() => {});
    try {
      ensurePortfolioListLoaded();
      const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
      const entries = await fetchPortfolioEntries(portfolioName);
      if (!entries.length) {
        PORTFOLIO_EQUITY_SERIES = null;
        setPortfolioContext(false);
        setStatus(`${portfolioName} is empty. Nothing to run.`);
        if (statusEl) {
          setTimeout(() => {
            if (statusEl.textContent === `${portfolioName} is empty. Nothing to run.`) {
              statusEl.textContent = previousMsg;
            }
          }, 3000);
        }
        return;
      }
      const { trades: combined, strategySeries } = combinePortfolioTrades(entries);
      if (!combined.length) {
        PORTFOLIO_EQUITY_SERIES = null;
        setPortfolioContext(false);
        setStatus(`No trades found across ${portfolioName}.`);
        if (statusEl) {
          setTimeout(() => {
            if (statusEl.textContent === `No trades found across ${portfolioName}.`) {
              statusEl.textContent = previousMsg;
            }
          }, 3000);
        }
        return;
      }
      LAST_OUT = combined;
      PORTFOLIO_EQUITY_SERIES = Array.isArray(strategySeries) && strategySeries.length ? strategySeries : null;
      setPortfolioContext(true);
      renderSummary(LAST_OUT);
      renderTable(LAST_OUT);
      renderEquityChart(LAST_OUT);
      renderDrawdownChart(LAST_OUT);
      renderStreakChart(LAST_OUT);
      renderMonthlyPerf(LAST_OUT);
      const msg = `Ran ${portfolioName} across ${entries.length} strategies (${combined.length} rows).`;
      setStatus(msg);
      if (statusEl) {
        setTimeout(() => {
          if (statusEl.textContent === msg) {
            statusEl.textContent = previousMsg;
          }
        }, 3000);
      }
    } catch (err) {
      console.error('Failed to run portfolio', err);
      PORTFOLIO_EQUITY_SERIES = null;
      setStatus('Failed to run portfolio.');
      if (statusEl) {
        setTimeout(() => {
          if (statusEl.textContent === 'Failed to run portfolio.') {
            statusEl.textContent = previousMsg;
          }
        }, 4000);
      }
    }
  }

    function renderTable(out) {
      const tb = document.getElementById('tbody');
      tb.innerHTML = '';
      let rows = Array.isArray(out) ? (VIEW_DIR === 'both' ? out.slice() : out.filter(r => (r.Shares > 0) && ((VIEW_DIR === 'long' && r.Side === 'Long') || (VIEW_DIR === 'short' && r.Side === 'Short')))) : [];
      // Sort by date descending (YYYY-MM-DD strings sort lexicographically)
      rows.sort((a, b) => {
        const da = a && a.Date ? a.Date : '';
        const db = b && b.Date ? b.Date : '';
        if (da === db) return 0;
        return da < db ? 1 : -1;
      });
      const frag = document.createDocumentFragment();
      for (const r of rows) {
        const tr = document.createElement('tr');
        // Highlight rows based on HitType and pnl_R
        let highlight = '';
        if (r.HitType === 'TP') {
          highlight = ' bg-emerald-300';
        } else if (r.HitType === 'Indeterminate') {
          highlight = ' bg-amber-100';
        } else if (r.HitType === 'EOD' && Number(r.pnl_R) > 0) {
          highlight = ' bg-emerald-100';
        }
        tr.className = ('border-b' + (highlight ? highlight : ' hover:bg-slate-50'));
  const OR_val = (Number.isFinite(r.ORH) && Number.isFinite(r.ORL)) ? (r.ORH - r.ORL) : NaN;
  const OR_pct = (Number.isFinite(OR_val) && Number.isFinite(r.ORL) && r.ORL !== 0) ? ((OR_val / r.ORL) * 100) : NaN;
  tr.innerHTML = `
  <td class="px-3 py-2">${r.Date}</td>
  <td class="px-3 py-2 text-right">${fmtNum(r.ORH)}</td>
  <td class="px-3 py-2 text-right">${fmtNum(r.ORL)}</td>
  <td class="px-3 py-2 text-right">${fmtNum(OR_val)}</td>
  <td class="px-3 py-2 text-right">${fmtPct(OR_pct)}</td>
  <td class="px-3 py-2">${r.Side || ''}</td>
  <td class="px-3 py-2">${fmtTime(r.EntryTime)}</td>
  <td class="px-3 py-2">${fmtTime(r.ExitTime)}</td>
  <td class="px-3 py-2 text-right">${fmtNum(r.Entry)}</td>
  <td class="px-3 py-2 text-right">${fmtNum(r.Exit)}</td>
        <td class="px-3 py-2 text-right">${fmtNum(r.StopPrice)}</td>
        <td class="px-3 py-2 text-right">${fmtNum(r.TPPrice)}</td>
        <td class="px-3 py-2">${r.HitType === 'Stop' ? 'Loss' : r.HitType}</td>
        <td class="px-3 py-2 text-right">${Number.isFinite(r.Shares) ? r.Shares : ''}</td>
        <td class="px-3 py-2 text-right">${fmtNum(r.PnL)}</td>
        <td class="px-3 py-2 text-right">${fmtNum(r.pnl_R)}</td>
        <td class="px-3 py-2 text-right">${fmtNum(r.AUM)}</td>
        <td class="px-3 py-2 text-right">${fmtPct(r.DailyReturn)}</td>
        <td class="px-3 py-2 text-left text-xs font-mono">${r.SourceStrategyId || r.StrategyId || ''}</td>`;
        frag.appendChild(tr);
      }
      tb.appendChild(frag);
    }

    function renderEquityChart(out){
      applySectionTitle('equityTitle', 'Equity Curve');
      const el = document.getElementById('equityChart');
      if (!el) return;
      if (!out || !out.length) {
        try { if (equityChartInst) { equityChartInst.dispose(); equityChartInst = null; } } catch {}
        el.innerHTML = '<div class="text-sm text-slate-500">No data</div>';
        return;
      }
      // Prepare data as [time,value]
      const portfolioData = out.map(r => [r.Date, Number.isFinite(r.AUM) ? r.AUM : null]).filter(p => p[1] !== null);
      if (!equityChartInst) equityChartInst = echarts.init(el);
      const series = [{
        name: 'Portfolio',
        type: 'line',
        showSymbol: false,
        smooth: false,
        lineStyle: { width: 2, color: '#10b981' },
        data: portfolioData
      }];

      if (Array.isArray(PORTFOLIO_EQUITY_SERIES) && PORTFOLIO_EQUITY_SERIES.length) {
        for (const item of PORTFOLIO_EQUITY_SERIES) {
          const id = item && item.id ? item.id : 'Strategy';
          const dataArr = Array.isArray(item && item.data) ? item.data : [];
          const seriesData = dataArr.map(d => {
            const dateVal = d && d[0];
            const val = d && Number.isFinite(Number(d[1])) ? Number(d[1]) : null;
            return [dateVal, val];
          }).filter(p => p[0] != null);
          series.push({
            name: id,
            type: 'line',
            showSymbol: false,
            smooth: false,
            lineStyle: { width: 1.5 },
            emphasis: { focus: 'series' },
            data: seriesData
          });
        }
      }

      const option = {
        animation: false,
        grid: { left: 56, right: 16, top: 8, bottom: 40 },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'cross' },
          valueFormatter: (v) => (v == null ? '' : `$${Number(v).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2})}`)
        },
        xAxis: { type: 'time', name: 'Date' },
        yAxis: {
          type: 'value', name: 'AUM',
          axisLabel: { formatter: (v) => fmtCompactMoney(v) }
        },
        legend: series.length > 1 ? {
          top: 4,
          left: 'center',
          icon: 'line',
          textStyle: { fontSize: 11 },
          data: series.map(s => s.name)
        } : { show: false },
        dataZoom: [ 
          { type: 'inside', throttle: 50 }, 
          { 
            type: 'slider', 
            fillerColor: 'rgba(0, 0, 0, 0)', 
            height: 40,
            dataBackground: {
              lineStyle: { color: '#50C878' },
              areaStyle: { color: 'rgba(80, 200, 120, 0.2)' }
            }
          },
        ],
        series
      };
      equityChartInst.setOption(option, true);
    }

    function renderDrawdownChart(out) {
      applySectionTitle('drawdownTitle', 'Drawdown');
      const el = document.getElementById('drawdownChart');
      if (!el) return;
      if (!out || !out.length) {
        try { if (drawdownChartInst) { drawdownChartInst.dispose(); drawdownChartInst = null; } } catch {}
        el.innerHTML = '<div class="text-sm text-slate-500">No data</div>';
        return;
      }

      const pctData = [];
      const usdData = [];
      let peak = -Infinity;
      for (const row of out) {
        if (!row || !row.Date) continue;
        const aum = Number(row.AUM);
        if (!Number.isFinite(aum)) continue;
        if (!Number.isFinite(peak) || aum > peak) peak = aum;
        if (!Number.isFinite(peak) || peak <= 0) {
          pctData.push([row.Date, 0]);
          usdData.push([row.Date, 0]);
          continue;
        }
        const ddPct = Math.min(((aum / peak) - 1) * 100, 0);
        const ddUsd = Math.min(aum - peak, 0);
        pctData.push([row.Date, ddPct]);
        usdData.push([row.Date, ddUsd]);
      }

      const mode = (DRAWDOWN_MODE === 'usd') ? 'usd' : 'pct';
      const seriesData = mode === 'usd' ? usdData : pctData;
      const validVals = seriesData.map(p => p[1]).filter(v => Number.isFinite(v));
      if (!validVals.length) {
        try { if (drawdownChartInst) { drawdownChartInst.dispose(); drawdownChartInst = null; } } catch {}
        el.innerHTML = '<div class="text-sm text-slate-500">No data</div>';
        return;
      }

      if (!drawdownChartInst) {
        el.innerHTML = '';
        drawdownChartInst = echarts.init(el);
      }

      const formatCurrency = (val, fractionDigits = 0) => {
        if (!Number.isFinite(val)) return '';
        const abs = Math.abs(val);
        const formatted = abs.toLocaleString(undefined, { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits });
        return `${val < 0 ? '-' : ''}$${formatted}`;
      };

      const option = {
        animation: false,
        grid: { left: 56, right: 16, top: 8, bottom: 40 },
        tooltip: {
          trigger: 'axis',
          axisPointer: { type: 'cross' },
          valueFormatter: (v) => {
            if (v == null) return '';
            return mode === 'usd' ? formatCurrency(Number(v), 2) : `${Number(v).toFixed(2)}%`;
          }
        },
        xAxis: { type: 'time', name: 'Date' },
        yAxis: {
          type: 'value',
          name: mode === 'usd' ? 'Drawdown $' : 'Drawdown %',
          max: 0,
          min: 'dataMin',
          axisLabel: {
            formatter: (v) => {
              if (mode === 'usd') {
                const val = Number(v);
                const digits = Math.abs(val) < 1 ? 2 : 0;
                return formatCurrency(val, digits);
              }
              return `${Number(v).toFixed(0)}%`;
            }
          }
        },
        dataZoom: [
          { type: 'inside', throttle: 50 },
          {
            type: 'slider',
            fillerColor: 'rgba(0, 0, 0, 0)',
            height: 40,
            dataBackground: {
              lineStyle: { color: '#f97316' },
              areaStyle: { color: 'rgba(249, 115, 22, 0.2)' }
            }
          }
        ],
        series: [{
          name: mode === 'usd' ? 'Drawdown ($)' : 'Drawdown (%)',
          type: 'line',
          showSymbol: false,
          smooth: false,
          lineStyle: { width: 2, color: '#ef4444' },
          areaStyle: { color: 'rgba(239, 68, 68, 0.15)' },
          data: seriesData
        }]
      };
      drawdownChartInst.setOption(option, true);
    }

    function computeWinLossStreaks(out) {
      const trades = (out || []).filter(r => r.Shares > 0 && !['NotEnoughBars', 'NoBreak', 'NoSize'].includes(r.HitType));
      const winsX = [], winsY = [], lossX = [], lossY = [];
      let curType = null; let curLen = 0;
      for (let i = 0; i < trades.length; i++) {
        const r = trades[i];
        const isWin = Number(r.PnL) > 0;
        const isLoss = Number(r.PnL) < 0;
        const type = isWin ? 'win' : (isLoss ? 'loss' : null);
        if (!type) {
          if (curType && curLen > 0) { const endDate = trades[i - 1].Date; if (curType === 'win') { winsX.push(endDate); winsY.push(curLen); } else { lossX.push(endDate); lossY.push(curLen); } }
          curType = null; curLen = 0; continue;
        }
        if (curType === null) { curType = type; curLen = 1; continue; }
        if (type === curType) { curLen++; }
        else { const endDate = trades[i - 1].Date; if (curType === 'win') { winsX.push(endDate); winsY.push(curLen); } else { lossX.push(endDate); lossY.push(curLen); } curType = type; curLen = 1; }
      }
      if (curType && curLen > 0 && trades.length > 0) { const endDate = trades[trades.length - 1].Date; if (curType === 'win') { winsX.push(endDate); winsY.push(curLen); } else { lossX.push(endDate); lossY.push(curLen); } }
      return { winsX, winsY, lossX, lossY };
    }

    function renderStreakChart(out) {
      applySectionTitle('streakTitle', 'Win/Loss Streaks');
      const el = document.getElementById('streakChart');
      if (!el) return;
      const { winsX, winsY, lossX, lossY } = computeWinLossStreaks(out);
      if ((winsX.length + lossX.length) === 0) {
        try { if (streakChartInst) { streakChartInst.dispose(); streakChartInst = null; } } catch {}
        el.innerHTML = '<div class="text-sm text-slate-500">No data</div>';
        return;
      }
      if (!streakChartInst) streakChartInst = echarts.init(el);
      const winData = winsX.map((d,i)=>[d, winsY[i]]);
      const lossData = lossX.map((d,i)=>[d, -Math.abs(lossY[i])]);
      const option = {
        animation: false,
        grid: { left: 56, right: 16, top: 8, bottom: 40 },
        tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
        xAxis: { type: 'time', name: 'Date' },
        yAxis: { type: 'value', name: 'Consecutive count' },
        dataZoom: [ 
          { type: 'inside', throttle: 50 }, 
          { 
            type: 'slider',
            fillerColor: 'rgba(0, 0, 0, 0)', 
            height: 40,
            dataBackground: {
              lineStyle: { color: '#50C878' },
              areaStyle: { color: 'rgba(80, 200, 120, 0.2)' }
            }
          } 
        ],
        legend: { show: false },
        series: [
          { name: 'Win streak', type: 'bar', itemStyle: { color: '#10b981' }, data: winData },
          { name: 'Loss streak', type: 'bar', itemStyle: { color: '#ef4444' }, data: lossData }
        ]
      };
      streakChartInst.setOption(option, true);
    }

    // -------- CSV Export (Trades) --------
    function getVisibleRowsForExport() {
      if (!Array.isArray(LAST_OUT)) return [];
      let rows = (VIEW_DIR === 'both') ? LAST_OUT.slice() : LAST_OUT.filter(r => (r.Shares>0) && ((VIEW_DIR==='long' && r.Side==='Long') || (VIEW_DIR==='short' && r.Side==='Short')));
      rows.sort((a,b)=>{
        const da = a && a.Date ? a.Date : '';
        const db = b && b.Date ? b.Date : '';
        if (da===db) return 0;
        return da < db ? 1 : -1;
      });
      return rows;
    }

    function buildAoaFromRows(rows) {
  const headers = ['Date','ORH','ORL','OR','OR%','Side','EntryTime','ExitTime','Entry','Exit','LossPrice','TPPrice','HitType','Shares','PnL','pnl_R','AUM','DailyReturn %','Strategy'];
      const aoa = [headers];
      for (const r of rows) {
        const OR_val = (Number.isFinite(r.ORH) && Number.isFinite(r.ORL)) ? (r.ORH - r.ORL) : NaN;
        const OR_pct = (Number.isFinite(OR_val) && Number.isFinite(r.ORL) && r.ORL !== 0) ? Number(((OR_val / r.ORL) * 100).toFixed(2)) : '';
        aoa.push([
          r.Date,
          Number.isFinite(r.ORH) ? Number(r.ORH) : '',
          Number.isFinite(r.ORL) ? Number(r.ORL) : '',
          Number.isFinite(OR_val) ? Number(OR_val) : '',
          OR_pct,
          r.Side || '',
          (r.EntryTime ? fmtTime(r.EntryTime) : ''),
          (r.ExitTime ? fmtTime(r.ExitTime) : ''),
          Number.isFinite(r.Entry) ? Number(r.Entry) : '',
          Number.isFinite(r.Exit) ? Number(r.Exit) : '',
          Number.isFinite(r.StopPrice) ? Number(r.StopPrice) : '',
          Number.isFinite(r.TPPrice) ? Number(r.TPPrice) : '',
          (r.HitType === 'Stop' ? 'Loss' : (r.HitType || '')),
          Number.isFinite(r.Shares) ? Number(r.Shares) : '',
          Number.isFinite(r.PnL) ? Number(r.PnL) : '',
          Number.isFinite(r.pnl_R) ? Number(r.pnl_R) : '',
          Number.isFinite(r.AUM) ? Number(r.AUM) : '',
          Number.isFinite(r.DailyReturn) ? Number(r.DailyReturn) : '',
          r.SourceStrategyId || r.StrategyId || ''
        ]);
      }
      return aoa;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
    }

    function exportTradesCSV() {
      const rows = getVisibleRowsForExport();
      if (!rows.length) { alert('No rows to export.'); return; }
      const aoa = buildAoaFromRows(rows);
      const csv = aoa.map(row => row.map(cell => {
        const s = (cell === null || cell === undefined) ? '' : String(cell);
        if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
        return s;
      }).join(',')).join('\n');
      downloadBlob(new Blob([csv], { type: 'text/csv;charset=utf-8' }), `trades_${currentTicker || 'SYMBOL'}.csv`);
    }

    // Bind Export CSV button
    (function(){
      const btn = document.getElementById('btnExportCSV');
      if (btn) btn.addEventListener('click', exportTradesCSV);
    })();

    let MONTHLY_PERF_MODE = 'pct'; // 'pct' | 'usd'
    let DRAWDOWN_MODE = 'pct'; // 'pct' | 'usd'

    function computeMonthlyPerf(out){
      // Aggregate by YYYY and month index 1..12: both $ PnL and % return per month
      const agg = new Map(); // year -> { pnl:[12], ret:[12] }
      const monthlyAUM = new Map(); // key YYYY-MM -> {startAUM, endAUM}
      let prevAUM = null;
      for (let i=0;i<(out||[]).length;i++){
        const r = out[i];
        if (!r.Date) continue;
        const [y,m] = r.Date.split('-');
        const key = `${y}-${m}`;
        if (!monthlyAUM.has(key)) monthlyAUM.set(key, { startAUM: (prevAUM ?? r.AUM - (Number.isFinite(r.PnL)?r.PnL:0)), endAUM: r.AUM });
        const rec = monthlyAUM.get(key);
        rec.endAUM = r.AUM;
        prevAUM = r.AUM;
      }
      for (const r of (out||[])){
        if (!r.Date) continue;
        const [y,m] = r.Date.split('-');
        const year = y;
        const monthIdx = parseInt(m,10);
        if (!agg.has(year)) agg.set(year, { pnl: Array(12).fill(0), ret: Array(12).fill(0) });
        const a = agg.get(year);
        a.pnl[monthIdx-1] += (Number.isFinite(r.PnL) ? r.PnL : 0);
      }
      // compute % returns per month from monthlyAUM map
      for (const [ym, v] of monthlyAUM.entries()){
        const [yy,mm] = ym.split('-');
        const year = yy; const idx = parseInt(mm,10)-1;
        if (!agg.has(year)) agg.set(year, { pnl: Array(12).fill(0), ret: Array(12).fill(0) });
        const a = agg.get(year);
        const start = v.startAUM; const end = v.endAUM;
        const ret = (Number.isFinite(start) && start!==0 && Number.isFinite(end)) ? ((end-start)/start)*100 : 0;
        a.ret[idx] = ret;
      }
      const years = Array.from(agg.keys()).sort();
      return { years, data: agg };
    }

    function renderMonthlyPerf(out){
      applySectionTitle('monthlyTitle', 'Monthly Performance');
      const host = document.getElementById('monthlyPerf');
      if (!host) return;
      if (!out || !out.length){ host.innerHTML = '<div class="text-sm text-slate-500">No data</div>'; return; }
      const { years, data } = computeMonthlyPerf(out);
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const shadeGreen = (ratio) => {
        if (ratio > 0.8) return 'bg-emerald-400';
        if (ratio > 0.6) return 'bg-emerald-300';
        if (ratio > 0.4) return 'bg-emerald-200';
        if (ratio > 0.2) return 'bg-emerald-100';
        return 'bg-emerald-50';
      };
      const shadeRed = (ratio) => {
        // Increase minimum shade to >= 150 by flooring at rose-200
        if (ratio > 0.8) return 'bg-rose-400';
        if (ratio > 0.5) return 'bg-rose-300';
        return 'bg-rose-200';
      };
      // compute normalization based on selected mode across all months
      let maxAbs = 0;
      for (const y of years){
        const rec = data.get(y) || { pnl: Array(12).fill(0), ret: Array(12).fill(0) };
        for (let i=0;i<12;i++){
          const v = (MONTHLY_PERF_MODE==='pct') ? rec.ret[i] : rec.pnl[i];
          if (Number.isFinite(v)) maxAbs = Math.max(maxAbs, Math.abs(v));
        }
      }
      const cell = (pnl, ret)=>{
        const v = (MONTHLY_PERF_MODE==='pct') ? ret : pnl;
        if (!Number.isFinite(v) || Math.abs(v) < 1e-9) return '<td class="px-2 py-1 text-right text-slate-500">-</td>';
        const pos = v>0;
        const ratio = maxAbs>0 ? Math.min(Math.abs(v)/maxAbs, 1) : 0;
        const bgCls = pos ? shadeGreen(ratio) : shadeRed(ratio);
        const txtCls = pos ? 'text-emerald-900' : 'text-rose-900';
        const val = (MONTHLY_PERF_MODE==='pct') ? `${fmtPct(v)}%` : `$${fmtInt(v)}`;
        return `<td class="px-2 py-1 text-right tabular-nums font-mono ${bgCls} ${txtCls}">${val}</td>`;
      };
      let html = '<div class="overflow-auto"><table class="min-w-full text-sm"><thead><tr><th class="px-2 py-1 text-left">Year</th>' + months.map(m=>`<th class="px-2 py-1 text-right">${m}</th>`).join('') + '</tr></thead><tbody>';
      for (const y of years){
        const rec = data.get(y) || { pnl: Array(12).fill(0), ret: Array(12).fill(0) };
        html += `<tr class="border-t"><td class="px-2 py-1 font-medium">${y}</td>` + rec.pnl.map((pv, i)=>cell(pv, rec.ret[i])).join('') + '</tr>';
      }
      html += '</tbody></table></div>';
      host.innerHTML = html;
    }

    // -----------------------------
    // Param handling + run
    // -----------------------------
    const riskConst = 0.02, AUM0Const = 100000, commissionConst = 0, directionConst = 'both', breakoutBufferConst = 0.01, orbStartConst = '9:30', orbEndConst = '15:30', entryCutoffConst = '12:00';

    function computeFilteredDays() {
      if (!Array.isArray(DAYS) || DAYS.length === 0) return [];
      // DAYS are keys like YYYY-MM-DD, map to weekday via first row in group
      const out = [];
      for (const dayKey of DAYS) {
        const arr = DAY_GROUPS.get(dayKey);
        if (!arr || !arr.length) continue;
        const dow = arr[0].caldt.getDay(); // 0=Sun..6=Sat
        const mapDow = dow === 0 ? 7 : dow; // 1..7 with 7=Sun
        const monthKey = `${dayKey.slice(5, 7)}/${dayKey.slice(0, 4)}`; // MM/YYYY
        const dowOk = VIEW_DOW.has(mapDow) || (mapDow === 7 && VIEW_DOW.has(7));
        const monOk = (VIEW_MONTHS.size === 0) || VIEW_MONTHS.has(monthKey);
        if (dowOk && monOk) out.push(dayKey);
      }
      return out;
    }

    function getBacktestParams() {
      const orb = document.getElementById('inp_orb_m');
      const trg = document.getElementById('inp_target_R');
      const stp = document.getElementById('inp_stop_R');
      const riskPct = document.getElementById('inp_risk_pct');
      const aum0 = document.getElementById('inp_aum0');
      const tStart = document.getElementById('inp_orb_start');
      const tEnd = document.getElementById('inp_orb_end');
      const tCut = document.getElementById('inp_entry_cutoff');
      const filteredDays = computeFilteredDays();
      return {
        symbol: currentTicker,
        days: filteredDays,
        dayGroups: DAY_GROUPS,
        orb_m: (()=>{ const v = orb ? parseInt(orb.value, 10) : NaN; return Number.isFinite(v) ? v : 25; })(),
        target_R: (()=>{ const v = trg ? parseFloat(trg.value) : NaN; return Number.isFinite(v) ? v : 2; })(),
        stop_R: (()=>{ const v = stp ? parseFloat(stp.value) : NaN; return Number.isFinite(v) ? v : 2; })(),
        risk: (()=>{ const v = riskPct ? parseFloat(riskPct.value) : NaN; return Number.isFinite(v) ? (v/100) : riskConst; })(),
        AUM_0: (()=>{ const v = aum0 ? parseFloat(aum0.value) : NaN; return Number.isFinite(v) ? v : AUM0Const; })(),
        commission: commissionConst,
        direction: VIEW_DIR || directionConst,
        orb_start_time: (tStart && tStart.value) ? tStart.value : orbStartConst,
        orb_end_time: (tEnd && tEnd.value) ? tEnd.value : orbEndConst,
        entry_cutoff_time: (tCut && tCut.value) ? tCut.value : entryCutoffConst,
        breakout_buffer: breakoutBufferConst,
      };
    }

    let runTimer = null;
    function scheduleRun() {
      if (runTimer) clearTimeout(runTimer);
      runTimer = setTimeout(runBacktestIfReady, 150);
    }

    // Time steppers for ORB Start / End / Entry Cutoff
    (function(){
      function adjustTimeInput(id, deltaMin){
        const el = document.getElementById(id);
        if (!el) return;
        const [hh, mm] = (el.value || '00:00').split(':').map(Number);
        const cur = (Number.isFinite(hh) ? hh : 0) * 60 + (Number.isFinite(mm) ? mm : 0);
        const next = cur + (Number(deltaMin) || 0);
        // wrap within 0..1439
        const wrapped = ((next % (24*60)) + (24*60)) % (24*60);
        el.value = toHHMM(wrapped);
        el.dispatchEvent(new Event('change', { bubbles: true }));
      }
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-time-target][data-time-step]');
        if (!btn) return;
        const id = btn.getAttribute('data-time-target');
        const delta = parseInt(btn.getAttribute('data-time-step'), 10) || 0;
        adjustTimeInput(id, delta);
      });
    })();

    // Numeric steppers for orb_m / target_R / stop_R
    (function(){
      function decimals(stepStr){
        if (!stepStr) return 0;
        const s = String(stepStr);
        const idx = s.indexOf('.');
        return idx === -1 ? 0 : (s.length - idx - 1);
      }
      function roundTo(value, step){
        const d = decimals(step);
        return Number(value.toFixed(d));
      }
      function adjustNumberInput(id, deltaUnits){
        const el = document.getElementById(id);
        if (!el) return;
        const stepAttr = parseFloat(el.getAttribute('step') || '1');
        const step = Number.isFinite(stepAttr) && stepAttr > 0 ? stepAttr : 1;
        const minAttr = parseFloat(el.getAttribute('min'));
        const maxAttr = parseFloat(el.getAttribute('max'));
        const defAttr = parseFloat(el.getAttribute('data-default'));
        const curVal = parseFloat(el.value);
        const base = Number.isFinite(curVal) ? curVal : (Number.isFinite(defAttr) ? defAttr : 0);
        const next = base + (Number(deltaUnits) || 0) * step;
        const clamped = Math.min(Number.isFinite(maxAttr) ? maxAttr : Infinity, Math.max(Number.isFinite(minAttr) ? minAttr : -Infinity, next));
        const rounded = roundTo(clamped, step);
        el.value = String(rounded);
        el.dispatchEvent(new Event('change', { bubbles: true }));
      }
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-num-target][data-num-step]');
        if (!btn) return;
        const id = btn.getAttribute('data-num-target');
        const delta = parseFloat(btn.getAttribute('data-num-step')) || 0;
        adjustNumberInput(id, delta);
      });
    })();

    async function runBacktestIfReady() {
      if (!currentTicker) { setStatus('Pick a symbol.'); return; }
      if (!DAYS.length) { setStatus('No data loaded.'); return; }
      const params = getBacktestParams();
      const t0 = performance.now();
      const out = backtest(params);
      const t1 = performance.now();
      setStatus(`Ran ${out.length} day(s) in ${(t1 - t0).toFixed(0)} ms.`);
      setPortfolioContext(false);
      renderSummary(out);
      LAST_OUT = out;
      PORTFOLIO_EQUITY_SERIES = null;
      CURRENT_STRATEGY_PARAMS = params;
      CURRENT_STRATEGY_ID = buildStrategyKey(params);
      CURRENT_STRATEGY_FAVORITE = false;
      syncFavoriteButton();
      syncAutoBacktestButton();
      renderTable(LAST_OUT);
      renderEquityChart(LAST_OUT);
      renderDrawdownChart(LAST_OUT);
      renderStreakChart(LAST_OUT);
      renderMonthlyPerf(LAST_OUT);
      await persistStrategyResult(params, LAST_OUT);
      await refreshFavoriteState(CURRENT_STRATEGY_ID);
    }

    async function loadAndRunForCurrent() {
      if (!currentTicker) return;
      const ok = await loadSymbolData(currentTicker);
      if (ok) { buildMonthOptions(); runBacktestIfReady(); }
    }

    // Responsive charts: resize on window changes
    window.addEventListener('resize', () => {
      try { if (equityChartInst) equityChartInst.resize(); } catch {}
      try { if (drawdownChartInst) drawdownChartInst.resize(); } catch {}
      try { if (streakChartInst) streakChartInst.resize(); } catch {}
    });

    // -----------------------------
    // Symbol segment (existing code with auto-run hook)
    // -----------------------------
    async function populateTickerSegment() {
      const container = document.getElementById('tickerSegment');
      if (!container) return;
      container.innerHTML = '<span class="px-3 py-1.5 text-sm text-slate-500">Loading…</span>';
      const render = (symbols) => {
        container.innerHTML = '';
        symbols.forEach((s, i) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          const cls = 'px-3 py-1.5 text-sm font-medium bg-white hover:bg-slate-100' + (i < symbols.length - 1 ? ' border-r border-slate-200' : '');
          btn.className = cls; btn.setAttribute('data-symbol', s); btn.textContent = s; container.appendChild(btn);
        });
      };
      try {
        const res = await fetch('data/index.json', { cache: 'no-cache' });
        if (res.ok) {
          const list = await res.json();
          if (Array.isArray(list) && list.length) { render(list.map(s => String(s).toUpperCase())); return; }
        }
      } catch { }
      try {
        const res = await fetch('data/', { cache: 'no-cache' });
        if (res.ok) {
          const text = await res.text();
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let files = [];
          if (ct.includes('text/html')) {
            const doc = new DOMParser().parseFromString(text, 'text/html');
            files = Array.from(doc.querySelectorAll('a')).map(a => a.getAttribute('href')).filter(Boolean);
          } else { files = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean); }
          const regex = /^([A-Za-z0-9-]+)_1m\.csv$/i;
          const syms = [];
          for (const f of files) { const name = (f || '').split('/').pop(); const m = name.match(regex); if (m) syms.push(m[1].toUpperCase()); }
          const uniq = Array.from(new Set(syms)); if (uniq.length) { render(uniq); return; }
        }
      } catch { }
      render(['TQQQ', 'TSLA', 'PLTR', 'UVXY']);
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#tickerSegment button[data-symbol]');
      if (!btn) return;
      const seg = document.getElementById('tickerSegment'); if (!seg) return;
      seg.querySelectorAll('button').forEach(b => { b.classList.remove('bg-slate-800', 'text-white', 'focus:outline-none'); if (!b.classList.contains('bg-white')) b.classList.add('bg-white'); if (!b.classList.contains('hover:bg-slate-100')) b.classList.add('hover:bg-slate-100'); });
      btn.classList.add('bg-slate-800', 'text-white', 'focus:outline-none'); btn.classList.remove('bg-white', 'hover:bg-slate-100');
      setTicker(btn.getAttribute('data-symbol'));
      loadAndRunForCurrent();
    });

    // Direction filter segment handlers
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#dirSegment button[data-dir]');
      if (!btn) return;
      const seg = document.getElementById('dirSegment'); if (!seg) return;
      seg.querySelectorAll('button').forEach(b => { b.classList.remove('bg-slate-800', 'text-white', 'focus:outline-none'); if (!b.classList.contains('bg-white')) b.classList.add('bg-white'); if (!b.classList.contains('hover:bg-slate-100')) b.classList.add('hover:bg-slate-100'); });
      btn.classList.add('bg-slate-800', 'text-white', 'focus:outline-none'); btn.classList.remove('bg-white', 'hover:bg-slate-100');
      VIEW_DIR = (btn.getAttribute('data-dir') || 'both');
      // Re-run so summary and trades reflect the selected direction
      scheduleRun();
    });

    function syncDowUI() {
      const seg = document.getElementById('dowSegment'); if (!seg) return;
      seg.querySelectorAll('button[data-dow]').forEach(b => {
        const n = Number(b.getAttribute('data-dow'));
        const active = VIEW_DOW.has(n);
        b.classList.toggle('bg-slate-800', active);
        b.classList.toggle('text-white', active);
        b.classList.toggle('bg-white', !active);
        b.classList.toggle('hover:bg-slate-100', !active);
      });
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#dowSegment button[data-dow]');
      if (!btn) return;
      const n = Number(btn.getAttribute('data-dow'));
      if (VIEW_DOW.has(n)) VIEW_DOW.delete(n); else VIEW_DOW.add(n);
      // Allow empty selection so user can see zero-trade results
      syncDowUI();
      scheduleRun();
    });

    const favoriteSelectEl = document.getElementById('favoriteSelect');
    if (favoriteSelectEl) {
      favoriteSelectEl.addEventListener('change', async (e) => {
        const select = e.target;
        const id = select.value;
        if (!id) return;
        const record = CURRENT_SYMBOL_FAVORITES.find(item => item && item.id === id);
        if (record) {
          try {
            await applyFavoriteStrategy(record);
          } catch {}
        }
      });
    }

    (function initPortfolioButton(){
      const btn = document.getElementById('btnAddPortfolio');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        if (!Array.isArray(LAST_OUT) || LAST_OUT.length === 0) {
          setStatus('Run a backtest before saving to the portfolio.');
          return;
        }
        const params = getBacktestParams();
        if (!params || !params.symbol) {
          setStatus('Pick a symbol before saving to the portfolio.');
          return;
        }
        ensurePortfolioListLoaded();
        const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
        const statusEl = document.getElementById('status');
        const previousMsg = statusEl ? statusEl.textContent : '';
        try {
          await persistPortfolioEntry(params, LAST_OUT);
          await refreshPortfolioTable();
          setStatus(`Saved to ${portfolioName}.`);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === `Saved to ${portfolioName}.`) {
                statusEl.textContent = previousMsg;
              }
            }, 2000);
          }
        } catch (err) {
          setStatus('Failed to save to portfolio.');
          const errStatusEl = document.getElementById('status');
          if (errStatusEl) {
            setTimeout(() => {
              if (errStatusEl.textContent === 'Failed to save to portfolio.') {
                errStatusEl.textContent = '';
              }
            }, 4000);
          }
        }
      });
    })();

    document.addEventListener('click', async (e) => {
      const loadBtn = e.target.closest('[data-portfolio-load]');
      if (loadBtn) {
        const strategyId = loadBtn.getAttribute('data-portfolio-load');
        if (strategyId) {
          const record = PORTFOLIO_CACHE ? PORTFOLIO_CACHE.get(strategyId) : null;
          if (record && record.params) {
            applyFavoriteStrategy({ id: strategyId, params: record.params, favorite: false }).catch(() => {});
          }
        }
        return;
      }

      const btn = e.target.closest('[data-portfolio-delete]');
      if (!btn) return;
      const id = btn.getAttribute('data-portfolio-delete');
      if (!id) return;
      const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
      if (!window.confirm(`Remove this strategy from ${portfolioName}?`)) return;
      const statusEl = document.getElementById('status');
      const previousMsg = statusEl ? statusEl.textContent : '';
      try {
        await deletePortfolioEntry(id);
        await refreshPortfolioTable();
        setStatus(`Removed from ${portfolioName}.`);
        if (statusEl) {
          setTimeout(() => {
            if (statusEl.textContent === `Removed from ${portfolioName}.`) {
              statusEl.textContent = previousMsg;
            }
          }, 2000);
        }
      } catch (err) {
        setStatus('Failed to delete portfolio entry.');
        const errStatusEl = document.getElementById('status');
        if (errStatusEl) {
          setTimeout(() => {
            if (errStatusEl.textContent === 'Failed to delete portfolio entry.') {
              errStatusEl.textContent = previousMsg;
            }
          }, 4000);
        }
      }
    });

    document.addEventListener('click', async (e) => {
      const sortBtn = e.target.closest('[data-auto-sort]');
      if (sortBtn) {
        const key = sortBtn.getAttribute('data-auto-sort');
        if (key) {
          const ascKeys = new Set(['strategyId','direction','start','end']);
          if (AUTO_RESULTS_SORT && AUTO_RESULTS_SORT.key === key) {
            AUTO_RESULTS_SORT.direction = AUTO_RESULTS_SORT.direction === 'desc' ? 'asc' : 'desc';
          } else {
            AUTO_RESULTS_SORT = { key, direction: ascKeys.has(key) ? 'asc' : 'desc' };
          }
          applyAutoResultsSort();
        }
        return;
      }

      const btn = e.target.closest('[data-auto-load]');
      if (!btn) return;
      const id = btn.getAttribute('data-auto-load');
      if (!id) return;
      const entry = AUTO_RESULTS_CACHE.get(id);
      if (entry) {
        try {
          await applyAutoResult(entry);
        } catch {}
      }
    });

    (function initFavoriteButton(){
      const btn = document.getElementById('btnAddFavorite');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        if (!CURRENT_STRATEGY_ID || !Array.isArray(LAST_OUT) || LAST_OUT.length === 0) return;
        const params = CURRENT_STRATEGY_PARAMS || getBacktestParams();
        if (!params) return;
        const nextFavorite = !CURRENT_STRATEGY_FAVORITE;
        const statusEl = document.getElementById('status');
        const previousMsg = statusEl ? statusEl.textContent : '';
        try {
          await persistStrategyResult(params, LAST_OUT, { force: true, favoriteOverride: nextFavorite });
          CURRENT_STRATEGY_FAVORITE = nextFavorite;
          syncFavoriteButton();
          const msg = nextFavorite ? 'Marked strategy as favorite.' : 'Removed strategy from favorites.';
          setStatus(msg);
          await loadFavoritesForSymbol(currentTicker);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === msg) {
                statusEl.textContent = previousMsg;
              }
            }, 2000);
          }
        } catch (err) {
          console.error('Failed to update favorite state', err);
          setStatus('Failed to update favorite.');
          await refreshFavoriteState(CURRENT_STRATEGY_ID);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === 'Failed to update favorite.') {
                statusEl.textContent = previousMsg;
              }
            }, 3000);
          }
        }
      });
    })();

    (function initPortfolioControls(){
      ensurePortfolioListLoaded();
      populatePortfolioSelect();
      refreshPortfolioTable().catch(()=>{});
      const createBtn = document.getElementById('btnCreatePortfolio');
      if (createBtn) {
        createBtn.addEventListener('click', () => {
          createNewPortfolio();
        });
      }
      const select = document.getElementById('portfolioSelect');
      if (select) {
        select.addEventListener('change', () => {
          const val = select.value;
          if (!val) return;
          setCurrentPortfolio(val);
        });
      }
    })();

    (function initRunPortfolioButton(){
      const btn = document.getElementById('btnRunPortfolio');
      if (!btn) return;
      btn.addEventListener('click', () => {
        runPortfolio();
      });
    })();

    (function initAutoBacktestButton(){
      const btn = document.getElementById('btnAutoBacktest');
      if (!btn) return;
      btn.addEventListener('click', () => {
        if (AUTO_BACKTEST_RUNNING) {
          if (!AUTO_BACKTEST_PAUSE_REQUESTED) {
            pauseAutoBacktest();
          }
          return;
        }
        startAutoBacktest();
      });
      syncAutoBacktestButton();
    })();

    (function initClearAutoButton(){
      const btn = document.getElementById('btnClearAuto');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        if (!currentTicker) { setStatus('Pick a symbol before clearing auto data.'); return; }
        if (!window.confirm('Clear saved auto backtest results for this symbol?')) return;
        const statusEl = document.getElementById('status');
        const previousMsg = statusEl ? statusEl.textContent : '';
        setStatus('Clearing auto backtest data…');
        try {
          await clearAutoResultsForSymbol(currentTicker);
          resetAutoBacktestState(currentTicker);
          AUTO_RESULTS_CACHE = new Map();
          await loadAutoResultsForSymbol(currentTicker);
          setStatus('Auto backtest data cleared.');
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === 'Auto backtest data cleared.') {
                statusEl.textContent = previousMsg;
              }
            }, 2000);
          }
        } catch (err) {
          console.error('Failed to clear auto backtest data', err);
          setStatus('Failed to clear auto backtest data.');
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === 'Failed to clear auto backtest data.') {
                statusEl.textContent = previousMsg;
              }
            }, 3000);
          }
        } finally {
          syncAutoBacktestButton();
        }
      });
    })();

    (function initClearPortfolioButton(){
      const btn = document.getElementById('btnClearPortfolio');
      if (!btn) return;
      btn.addEventListener('click', async () => {
        ensurePortfolioListLoaded();
        const portfolioName = CURRENT_PORTFOLIO_ID || getDefaultPortfolioName();
        if (!window.confirm(`Clear all saved strategies from ${portfolioName}?`)) return;
        const statusEl = document.getElementById('status');
        const previousMsg = statusEl ? statusEl.textContent : '';
        try {
          await clearPortfolioEntries();
          await refreshPortfolioTable();
          setPortfolioContext(false);
          setStatus(`${portfolioName} cleared.`);
          if (statusEl) {
            setTimeout(() => {
              if (statusEl.textContent === `${portfolioName} cleared.`) {
                statusEl.textContent = previousMsg;
              }
            }, 2000);
          }
        } catch (err) {
          setStatus('Failed to clear portfolio.');
          const errStatusEl = document.getElementById('status');
          if (errStatusEl) {
            setTimeout(() => {
              if (errStatusEl.textContent === 'Failed to clear portfolio.') {
                errStatusEl.textContent = previousMsg;
              }
            }, 4000);
          }
        }
      });
    })();

    // -----------------------------
    // Month multi-select helpers
    // -----------------------------
    function monthChoicesFromDays() {
      const set = new Set();
      for (const dayKey of DAYS) {
        const mk = `${dayKey.slice(5,7)}/${dayKey.slice(0,4)}`;
        set.add(mk);
      }
      // Sort descending by year-month
      return Array.from(set).sort((a,b)=>{
        const [am,ay] = a.split('/').map(Number);
        const [bm,by] = b.split('/').map(Number);
        if (ay!==by) return by-ay; // year desc
        return bm-am; // month desc
      });
    }

    function buildMonthOptions() {
      AVAILABLE_MONTHS = monthChoicesFromDays();
      const list = document.getElementById('sumMonthMultiList');
      if (!list) return;
      list.innerHTML = AVAILABLE_MONTHS.map(m => `
        <label class="flex items-center gap-2 px-2 py-1 rounded hover:bg-slate-50 cursor-pointer">
          <input type="checkbox" class="h-4 w-4 rounded border-slate-300" data-month="${m}" ${VIEW_MONTHS.has(m)?'checked':''} />
          <span class="text-sm text-slate-800">${m}</span>
        </label>
      `).join('');
      updateMonthLabel();
    }

    function updateMonthLabel(){
      const lbl = document.getElementById('sumMonthMultiLabel'); if (!lbl) return;
      if (VIEW_MONTHS.size===0 || VIEW_MONTHS.size===AVAILABLE_MONTHS.length) { lbl.textContent = 'All months'; return; }
      if (VIEW_MONTHS.size<=2) { lbl.textContent = Array.from(VIEW_MONTHS).sort().join(', '); return; }
      lbl.textContent = `${VIEW_MONTHS.size} selected`;
    }

    // Toggle dropdown open/close
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('#sumMonthMultiBtn');
      const menu = document.getElementById('sumMonthMultiMenu');
      if (btn && menu) { menu.classList.toggle('hidden'); return; }
      // Close when clicking outside
      if (menu && !menu.contains(e.target) && !e.target.closest('#sumMonthMultiBtn')) {
        menu.classList.add('hidden');
      }
    });

    // Select all / Clear
    document.addEventListener('click', (e) => {
      const selAll = e.target.closest('#sumMonthSelectAll');
      const clrAll = e.target.closest('#sumMonthClearAll');
      if (!selAll && !clrAll) return;
      if (selAll) VIEW_MONTHS = new Set(AVAILABLE_MONTHS);
      if (clrAll) VIEW_MONTHS = new Set();
      // sync checkboxes
      document.querySelectorAll('#sumMonthMultiList input[type="checkbox"]').forEach(cb => { const m = cb.getAttribute('data-month'); cb.checked = VIEW_MONTHS.has(m); });
      updateMonthLabel();
      scheduleRun();
    });

    // Checkbox toggles
    document.addEventListener('change', (e) => {
      const cb = e.target.closest('#sumMonthMultiList input[type="checkbox"]');
      if (!cb) return;
      const m = cb.getAttribute('data-month');
      if (cb.checked) VIEW_MONTHS.add(m); else VIEW_MONTHS.delete(m);
      updateMonthLabel();
      scheduleRun();
    });

    // Param input handling: allow clearing on input; clamp on change
    (function () {
      const orb = document.getElementById('inp_orb_m');
      const trg = document.getElementById('inp_target_R');
      const stp = document.getElementById('inp_stop_R');
  const riskPct = document.getElementById('inp_risk_pct');
  const aum0 = document.getElementById('inp_aum0');
      const tStart = document.getElementById('inp_orb_start');
      const tEnd = document.getElementById('inp_orb_end');
      const tCut = document.getElementById('inp_entry_cutoff');
      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
      function onInputNumber(el, def, min, max){
        const raw = el.value;
        if (raw === '') return; // allow clearing; skip run until change/valid
        const v = parseFloat(raw);
        if (!Number.isFinite(v)) return; // ignore partial strings like '-' or '.'
        const clamped = clamp(v, min, max);
        if (clamped !== v) {
          el.value = String(clamped);
        }
        scheduleRun();
      }
      function onChangeNumber(el, def, min, max){
        const v = parseFloat(el.value);
        el.value = String(clamp(Number.isFinite(v) ? v : def, min, max));
        scheduleRun();
      }
      if (orb) {
        orb.addEventListener('input', () => onInputNumber(orb, 25, 1, 120));
        orb.addEventListener('change', () => onChangeNumber(orb, 25, 1, 120));
      }
      if (trg) {
        trg.addEventListener('input', () => onInputNumber(trg, 2, 0, 100));
        trg.addEventListener('change', () => onChangeNumber(trg, 2, 0, 100));
      }
      if (stp) {
        stp.addEventListener('input', () => onInputNumber(stp, 2, 0, 100));
        stp.addEventListener('change', () => onChangeNumber(stp, 2, 0, 100));
      }
      if (riskPct) {
        riskPct.addEventListener('input', () => onInputNumber(riskPct, 2, 0, 100));
        riskPct.addEventListener('change', () => onChangeNumber(riskPct, 2, 0, 100));
      }
      if (aum0) {
        aum0.addEventListener('input', () => onInputNumber(aum0, 100000, 0, 1000000000));
        aum0.addEventListener('change', () => onChangeNumber(aum0, 100000, 0, 1000000000));
      }
      if (tStart) ['input', 'change'].forEach(evt => tStart.addEventListener(evt, scheduleRun));
      if (tEnd) ['input', 'change'].forEach(evt => tEnd.addEventListener(evt, scheduleRun));
      if (tCut) ['input', 'change'].forEach(evt => tCut.addEventListener(evt, scheduleRun));
    })();

    // Drawdown toggle handlers
    (function(){
      const btnPct = document.getElementById('ddBtnPct');
      const btnUsd = document.getElementById('ddBtnUsd');
      function syncUI(){
        if (!btnPct || !btnUsd) return;
        btnPct.classList.toggle('bg-white', DRAWDOWN_MODE === 'pct');
        btnPct.classList.toggle('ring-1', DRAWDOWN_MODE === 'pct');
        btnPct.classList.toggle('ring-slate-300', DRAWDOWN_MODE === 'pct');
        btnUsd.classList.toggle('bg-white', DRAWDOWN_MODE === 'usd');
        btnUsd.classList.toggle('ring-1', DRAWDOWN_MODE === 'usd');
        btnUsd.classList.toggle('ring-slate-300', DRAWDOWN_MODE === 'usd');
      }
      if (btnPct) btnPct.addEventListener('click', () => {
        DRAWDOWN_MODE = 'pct';
        syncUI();
        renderDrawdownChart(LAST_OUT || []);
      });
      if (btnUsd) btnUsd.addEventListener('click', () => {
        DRAWDOWN_MODE = 'usd';
        syncUI();
        renderDrawdownChart(LAST_OUT || []);
      });
      syncUI();
    })();

    // Monthly performance toggle handlers
    (function(){
      const btnPct = document.getElementById('mpBtnPct');
      const btnUsd = document.getElementById('mpBtnUsd');
      function syncUI(){
        if (!btnPct || !btnUsd) return;
        btnPct.classList.toggle('bg-white', MONTHLY_PERF_MODE==='pct');
        btnPct.classList.toggle('ring-1', MONTHLY_PERF_MODE==='pct');
        btnPct.classList.toggle('ring-slate-300', MONTHLY_PERF_MODE==='pct');
        btnUsd.classList.toggle('bg-white', MONTHLY_PERF_MODE==='usd');
        btnUsd.classList.toggle('ring-1', MONTHLY_PERF_MODE==='usd');
        btnUsd.classList.toggle('ring-slate-300', MONTHLY_PERF_MODE==='usd');
      }
      if (btnPct) btnPct.addEventListener('click', ()=>{ MONTHLY_PERF_MODE='pct'; syncUI(); renderMonthlyPerf(LAST_OUT||[]); });
      if (btnUsd) btnUsd.addEventListener('click', ()=>{ MONTHLY_PERF_MODE='usd'; syncUI(); renderMonthlyPerf(LAST_OUT||[]); });
      syncUI();
    })();

    // init
    populateTickerSegment().catch(()=>{});
    initModeTabs();
  initSecondaryNav();
    syncFavoriteButton();
    loadFavoritesForSymbol(currentTicker).catch(()=>{});
    loadAutoResultsForSymbol(currentTicker).catch(()=>{});
  </script>
</body>
</html>
